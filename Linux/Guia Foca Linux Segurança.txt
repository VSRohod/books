Guia Foca - Segurança

Guia Foca - Segurança

Gleydson Mazioli da Silva

<gleydson@guiafoca.org>

Versão 1.00 - segunda, 27 de julho de 2020

Copyright © 1999-2020 - Gleydson Mazioli da Silva

O Guia Foca Segurança é protegido pelos termos da licença CC BY-NC-SA. Para
detalhes, veja “Licença CC BY-NC-SA”

segunda, 27 de julho de 2020

Resumo

Este guia tem por objetivo ser uma referência ao aprendizado do usuário e um
manual de compreensão, configuração e implantação de técnicas de segurança que
podem ser utilizadas em ambientes Linux (e outros sistemas operacionais), bem
como em seu comportamento no dia a dia. As últimas versões do Guia Foca
segurança podem ser encontrados em Página Oficial do Guia Foca Segurança. Novas
versões são lançadas com uma frequência mensal e você pode receber avisos de
novos lançamentos deste guia preenchendo um formulário na página Web, ou
seguindo o perfil oficial do Twitter @guiafoca.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Índice

1. Introdução

    Considerações sobre o nível Segurança
    Antes de começar
    Pré-requisitos para a utilização deste guia
    Distribuições voltadas a Profissionais de Segurança

2. Explicações Básicas

    O que é Segurança e porque tornar um sistema seguro?
    Os 4 pilares da segurança
    LPI 303

3. Arquivos e daemons de Log

    Formato do arquivo de log
    Daemon de log do sistema

        rsyslogd
        Arquivo de configuração rsyslog.conf

    logger
    Programas úteis para monitoração e gerenciamento de arquivos de logs

        logcheck
        logrotate

    Configurando um servidor de logs

4. Gerenciamento de contas e cuidados para a proteção de senhas

    Introdução
    Criação, monitoramento e segurança de contas

        Definindo valores padrões de restrição
        Senhas fáceis de adivinhar e a escolha de boas senhas
        Atualização de senhas de múltiplas contas
        A senha do usuário root

    Tipos de ataques mais comuns para se conseguir uma senha.

        Dedução
        Engenharia Social
        Ataques por dicionário
        Brute Force
        Monitoramento de toques do teclado
        Login falso

    Melhorando a segurança das senhas armazenadas em seu sistema

        Shadow Passwords
        Senhas Sha512, SHA256 e MD5

5. Firewall iptables

    Introdução

        Versão
        Um resumo da história do iptables
        Características do firewall iptables
        Ficha técnica
        Requerimentos
        Arquivos de logs criados pelo iptables
        Instalação
        Enviando Correções/Contribuindo com o projeto
        O que aconteceu com o ipchains e ipfwadm?
        Tipos de firewalls
        O que proteger?
        O que são regras?
        O que são chains?
        O que são tabelas?
        Habilitando o suporte ao iptables no kernel
        Ligando sua rede interna a Internet

    Manipulando chains

        Adicionando regras - A
        Listando regras - L
        Apagando uma regra - D
        Inserindo uma regra - I
        Substituindo uma regra - R
        Criando um novo chain - N
        Renomeando um chain criado pelo usuário - E
        Listando os nomes de todas as tabelas atuais
        Limpando as regras de um chain - F
        Apagando um chain criado pelo usuário - X
        Zerando contador de bytes dos chains - Z
        Especificando a política padrão de um chain - P

    Outras opções do iptables

        Especificando um endereço de origem/destino
        Especificando a interface de origem/destino
        Especificando um protocolo
        Especificando fragmentos
        Especificando uma exceção
        Especificando um alvo
        Salvando e Restaurando regras

    A tabela nat (Network Address Translation) - fazendo nat

        Criando um novo chain na tabela NAT
        Fazendo IP masquerading (para os apressados)
        Fazendo SNAT
        Fazendo DNAT
        Monitorando conexões feitas na tabela nat

    A tabela mangle

        Especificando o tipo de serviço
        Especificando o TOS para tráfego de saída

    Outros módulos do iptables

        Conferindo de acordo com o estado da conexão
        Limitando o número de vezes que a regra confere
        Proteção contra ping da morte
        Proteção contra syn flood
        Proteção contra IP spoofing
        Especificando múltiplas portas de origem/destino
        Especificando o endereço MAC da interface
        Conferindo com quem criou o pacote
        Conferindo com o conteúdo do pacote
        Conferindo com o tempo de vida do pacote
        Conferindo com números RPC
        Conferindo com tipo de pacote
        Conferindo com o tamanho do pacote

    Caminho percorrido pelos pacotes nas tabelas e chains

        Ping de 192.168.1.1 para 192.168.1.1
        Conexão FTP de 192.168.1.1 para 192.168.1.1
        Conexão FTP de 192.168.1.1 para 192.168.1.4
        Conexão FTP de 200.217.29.67 para a máquina ftp.debian.org.br
        Ping de 192.168.1.4 para 192.168.1.1
        Conexão FTP de 192.168.1.4 para 192.168.1.1
        Conexão FTP de 192.168.1.4 para ftp.debian.org.br
        Conexão FTP de 200.198.129.162 para 200.217.29.167
        Gráfico geral da passagem dos pacotes

    Exemplos de configurações do iptables

        Bloqueando conexões de fora para sua máquina
        Monitorando tentativa de conexão de trojans em sua máquina
        Conectando sua rede interna a Internet
        Um exemplo de firewall simples

6. Restrições de acesso, recursos e serviços

    Limitando recursos no bash

        Uso do comando readonly para exportar variáveis
        Restrições nos diretórios de usuários e root
        Restrições básicas do shell bash com bash -r/--restricted, rbash
        Finalizando consoles inativos
        Desabilitando o registro de comandos digitados
        Desabilitando serviços de shell para usuários

    Limitação de recursos usando PAM

        Descobrindo se um determinado programa tem suporte a PAM
        Definindo uma política padrão restritiva
        Restringindo/Bloqueando o login
        Restringindo o acesso a root no su
        Restrições de serviços PAM baseados em dia/hora
        Permitindo acesso a grupos extras
        Limitação de recursos do shell

    Restrições de acesso a programas/diretórios/arquivos usando grupos
    Dando poderes de root para executar determinados programas
    Restringindo o comando su
    Restrições baseadas em usuário/IP
    Restrições por MAC Address/IP
    Desabilitando serviços não usados no Inetd
    Evitando o uso de hosts.equiv e .rhosts
    Restringindo o uso do shutdown
    Restringindo o acesso ao sistema de arquivos /proc
    Limitando o uso de espaço em disco (quotas)

        Instalando o sistema de quotas
        Editando quotas de usuários/grupos
        Modificando a quota de todos os usuários de uma vez
        Verificando a quota disponível ao usuário
        Verificando a quota de todos os usuários/grupos do sistema
        Avisando usuários sobre o estouro de quota

    Suporte a senhas ocultas
    Suporte a senhas com algorítmo SHA e md5
    Restrições no hardware do sistema

        BIOS do sistema
        Retirada da unidade de disquetes
        Placas de rede com eprom de boot
        Protegendo o LILO
        Disco rígido

7. Criptografia

    Introdução
    Introdução aos protocolos SSL e TLS

        SSL
        HTTPS
        Ataque Man in the Middle (MITM)
        TLS

    Introdução a Certificados

        Certificados X509
        Validade de Certificados
        CA Intermediária
        Como é gerado um Certificado assinado por CA?
        Tipos de certificados e suas extensões
        A estrutura básica de um certificado?
        Extensões para uso em certificados

    Cadeia de confiança de certificados

        Certificado raíz
        Autenticação de Certificado SSL TLS
        Tipos de certificados
        Significado de campos usados em certificados
        Nívels de validação do certificado

    openssl

        O arquivo de configuração /etc/ssl/openssl.cnf
        Visualizando conteúdo de um certificado existente
        Convertendo entre formatos de certificados

    Gerenciamento de uma CA e de chaves publicas e privadas

        Gerando uma chave RSA de 2048 bits
        Gerando uma chave PKCS8 de 2048 bits
        Exportando a chave RSA publica para arquivo
        Protegendo a chave privada
        Requisitos para gerenciar uma CA
        Criando uma CA privada
        Criando um certificado de CA
        Assinando um arquivo CRT
        Renovando um Certificado
        Revogando um Certificado
        Revogando uma CA
        Gerando um par de chaves RSA a partir da chave privada
        Extraindo a chave pública a partir da chave privada do certificado
        Extraindo elementos texto do certificado
        Gerando uma chave Pública
        Gerando arquivo binário contendo números aleatórios
        Automatizando preenchimento de dados de certificado
        Usando SNI nos domínios
        Encriptando arquivos grandes
        Especificando níveis de validação no Apache
        Enviando um certificado SSL de cliente para testes
        Verificando uma identidade

    Certificados Auto-Assinados

        Beneficios de rodar uma CA própria
        Criando Certificados Auto-Assinados
        Concatenando os Certificados gerados
        Configurando o Apache e Virtual Hosts
        Testando a conexão SSL
        Sobre certificados usando Curva Eliptica
        Programas para gerenciamento de CA usando ambiente gráfico e WEB

    Teste de cliente/servidor SSL/TLS com openssl

        Servidor OpenSSL
        Cliente OpenSSL
        Cadeia de Confiança
        Testando protocolos que fazem upgrade para TLS
        Extraindo o certificado remoto do cliente
        Usando formatos diferentes de HandShake de conexão
        Testando o suporte a uma versão específica de protocolo SSL
        Testando o suporte a um conjunto de Ciphers
        Testando servidores que requerem SNI
        Testando reuso de conexão no SSL
        Validação de revogação OCSP
        Testando o suporte a OCSP Stapling
        Verificando a revogação de CRL
        Verificando vulnerabilidade HeartBleed
        Determinando o tamanho de parametros DH

    Certificados com extensões X509 V3
    Alternativas seguras a serviços sem criptografia

        http
        Transmissão segura de e-mails
        Servidor pop3
        Transferência de arquivos
        login remoto
        Bate papo via IRC
        Transmissão de mensagens via ICQ

    Usando o GPG para Autenticação e Criptografia

        Instalando o PGP
        Criando um par de chaves pública/privada
        Encriptando Dados
        Decriptando dados com o GPG
        Assinando arquivos
        Checando assinaturas
        Extraindo sua chave pública do chaveiro
        Adicionando chaves públicas ao seu chaveiro pessoal
        Listando chaves de seu chaveiro
        Apagando chaves de seu chaveiro
        Mudando sua FraseSenha
        Assinando uma chave digital
        Listando assinaturas digitais
        Recomendações para a assinatura de chaves GPG

    Criptografia de blocos usando DM-Crypt / cryptsetup

        Encriptando um sistema de arquivos com DM-Crypto / cryptsetup
        Desmontando o dispositivo criptografado
        Listando limites e algoritmos suportados
        Avaliando a performance de cada algoritmo
        Opções de encriptação com o DM-Crypt
        Fazendo dump do cabeçalho de dispositivos
        Gerenciamento de chaves
        Backup e Restore de cabeçalho/chaves
        Convertendo automaticamente sistemas para criptografia e desconvertendo
        Convertendo a partição para Criptografica

    Criptografia de arquivos usando ENCFS

        Limitações
        Instalando
        Criando a Criptografia
        Alterando a senha
        Montando via fstab

    Usando o eCryptfs para encriptar arquivos, montagem automatica do home

        Configurando o ecryptfs
        Remontando o sistema de arquivos criptografado
        ecryptfsd
        Diretório Privado Automático para o usuário
        Migrando o home do usuário para criptografado
        PAM ecryptfs
        Limitações do eCryptfs

    Criptografia usando TrueCrypt/VeraCrypt

8. Segurança de Host

    Introdução

        Segurança de Host

    Chroot, Container e Virtualização

        Chroot
        Container
        Vantagens da Virtualização

    Desativando softwares e serviços desnecessários
    Protegendo BIOS e o GRUB2

        Senha no GRUB2
        Protegendo opçoes do prompt do Grub2
        Protegendo o sistema com senha de boot do Grub
        Protegendo entradas de menus do Grub
        Protegendo a partição de recuperação do Windows

    Limitando o uso de recursos de usuários

        Módulo PAM pam_limits

9. Controle de Acesso

    Introdução

        Controle de Acesso

10. Segurança de Rede

    Introdução

        Segurança em Redes

    Sniffer

        Detectando a presença de sniffers

11. Apêndice

    Sobre este guia
    Sobre o Autor
    Referências de auxílio ao desenvolvimento do guia
    Onde encontrar a versão mais nova do guia?
    Colaboradores do Guia e Agradecimentos
    Marcas Registradas
    Futuras Versões
    Licença CC BY-NC-SA
    Chave Pública PGP

Capítulo 1. Introdução

Índice

Considerações sobre o nível Segurança
Antes de começar
Pré-requisitos para a utilização deste guia
Distribuições voltadas a Profissionais de Segurança

Bem vindo ao Guia Foca Segurança. O nome FOCA significa FOnte de Consulta e A
prendizado. O Guia Foca Segurança aborda principais tópicos relacionados a
defesa e hardening de sistemas (área BlueTeam na segurança da informação):

Entre o conteúdo do Guia Foca Segurança, você encontrará:

  • Análise de logs do sistema GNU/Linux e aplicação para a solução de
    problemas (Capítulo 3, Arquivos e daemons de Log).

  • Gerenciamento de contas de usuários, definição de período automático para
    troca de senha periódica, políticas de segurança, etc (Capítulo 4, 
    Gerenciamento de contas e cuidados para a proteção de senhas).

  • Principais tipos de ataques para descoberta de senhas e alguns métodos de
    como evita-las (“Senhas fáceis de adivinhar e a escolha de boas senhas”).

  • Sistemas de proteção de senhas do sistema (“Melhorando a segurança das
    senhas armazenadas em seu sistema”).

  • Criptografia e segurança na transmissão de dados, usando exemplos práticos
    do uso de sniffers para entender o porque da uso de criptografia para
    transmissão segura de dados (“Introdução”).

  • Uso de serviços alternativos criptográficos (“Alternativas seguras a
    serviços sem criptografia”).

  • Criptografia usando gnupgp (“Usando o GPG para Autenticação e Criptografia”
    ).

  • Uso de sistema de arquivos criptográficos para armazenamento de dados.

  • Maiores considerações a segurança de sistema e a problemas de segurança
    relativos a falhas de configuração (distribuída entre os capítulos de
    daemons e servidores).

  • Montagem de um firewall avançado para proteção do sistema (filtragem de
    pacotes) usando o iptables, redirecionamento de pacotes, nat, bloqueio de
    tráfego P2P, masquerading, balanceamento de carga, marcação de pacotes,
    log, proteção contra port scans (Capítulo 5, Firewall iptables).

  • Restrições de acesso a instalação do computador, acesso a grupos do
    sistema, restrições de login usando PAM (Capítulo 6, Restrições de acesso,
    recursos e serviços).

  • Montagem de shell básico restrito (“Restrições básicas do shell bash com
    bash -r/--restricted, rbash”).

  • Uso do sudo para dar privilégio de execução de programas como root a
    determinados usuários (“Dando poderes de root para executar determinados
    programas”).

Para melhor organização, o Guia Foca Segurança está dividido basicamente em 4
capítulos principais: Criptografia, Controle de Acesso, Segurança de Host e 
Segurança de rede. A última versão deste guia pode ser encontrada em: Página
Oficial do guia Foca Linux.

Caso tiver alguma sugestão, correção, crítica para a melhoria deste guia,
preencha o formuário de sugestões disponíveis na página oficial do guia ou
envie um e-mail para <gleydson@guiafoca.org>.

O Foca Linux é atualizado freqüentemente, por este motivo recomendo que se
inscrena nas Novidades na página web em Página Oficial do Guia Foca Linux no
fim da página principal. Após preencher a ficha do aviso de atualizações, você
receberá um e-mail sobre o lançamento de novas versões do guia e o que foi
modificado, desta forma você poderá decidir em copia-la caso a nova versão
contenha modificações que considera importantes.

Tenho recebido elegios de pessoas do Brasil (e também de outros países)
elogiando o trabalho e a qualidade da documentação. Agradeço a todos pelo
apoio, tenham certeza que este trabalho é desenvolvido pensando em repassar um
pouco do conhecimento que adquiri ao começar o uso do Linux e na vivência.

Também recebo e-mails de pessoas comemorando a aprovação na prova LPI nível 1,
2 e 3 após estudar usando o guia Foca GNU/Linux. Fico bastante feliz por saber
disso, pois nunca tive a intenção de tornar o guia uma referência livre para
estudo da LPI e hoje é usado para estudo desta difícil certificação que aborda
comandos, serviços, configurações, segurança, empacotamento, criptografia, etc.

Considerações sobre o nível Segurança

Este guia foi compilado incluindo o nível Segurança do guia FOCA Linux, ele não
tem a intenção de ser a única referencia na configuração de serviços,
servidores, aplicativos, nem garantia que ele atenderá a determinada finalidade
específica do usuário (principalmente de uma rede, que depende de uma perfeita
compreensão para adaptação de acordo com os requisitos de uma instalação
local). Seu foco principal é guiar o leitor em pontos importantes para
fortalecer sua instalação, comunicação e procedimento de segurança.

Antes de começar

Para quem está começando, muita teoria pode atrapalhar o aprendizado, é mais
produtivo ver na prática o que o computador faz e depois porque ele faz isto.
Mesmo assim, recomendo ler estes capítulos pois seu conteúdo pode ser útil.

Coloquei abaixo algumas dicas para um bom começo:

  • Recomendo que faça a leitura deste guia e pratique imediatamente o que
    aprendeu. Isto facilita o entendimento do programa/comando/configuração.

  • É preciso ter interesse em aprender, se você tiver vontade em aprender
    algo, você terá menos dificuldade do que em algo que não gosta e está se
    obrigando a aprender.

  • Decorar não adianta, pelo contrário, só atrapalha no aprendizado. Você
    precisa entender o que o comando faz, deste modo você estará estimulando e
    desenvolvendo sua interpretação, e entenderá melhor o assunto (talvez até
    me de uma força para melhorar o guia ;-)

  • Curiosidade também é importante. Você talvez possa estar procurando um
    comando que mostre os arquivos que contém um certo texto, e isto fará você
    chegar até o comando grep, depois você conhecerá suas opções, etc.

  • Não desanime vendo outras pessoas que sabem mais que você, lembre-se que
    ninguém nasce sabendo :-). Uma pessoa pode ter mais experiência em um
    assunto no sistema como compilação de programas, configuração, etc., e você
    pode ter mais interesse em redes.

  • Ninguém pode saber tudo da noite para o dia, não procure saber TUDO sobre o
    sistema de uma só vez, senão não entenderá NADA. Caso tenha dúvidas sobre o
    sistema, procure ler novamente a seção do guia, e caso ainda não tenha
    entendido procure ajuda nas página de manual, ou nas listas de discussão ou
    me envie uma mensagem <gleydson@guiafoca.org>.

  • Certamente você buscará documentos na Internet que falem sobre algum
    assunto que este guia ainda não explica. Muito cuidado! O GNU/Linux é um
    sistema que cresce muito rapidamente, a cada semana uma nova versão é
    lançada, novos recursos são adicionados, seria maravilhoso se a
    documentação fosse atualizada com a mesma freqüência.

    Infelizmente a atualização da documentação não segue o mesmo ritmo
    (principalmente aqui no Brasil). É comum você encontrar na Internet
    documentos da época quando o kernel estava na versão 2.2.30, 2.4.8, 2.6.28,
    etc. Estes documentos são úteis para pessoas que por algum motivo
    necessitam operar com versões antigas do Kernel Linux, mas pode trazer
    problemas ou causar má impressão do GNU/Linux em outras pessoas.

    Por exemplo, você pode esbarrar pela Internet com um documento que diz que
    o Kernel não tem suporte aos "nomes extensos" da VFAT (Windows 95), isto é
    verdade para kernels anteriores ao 2.0.31, mas as versões mais novas que a
    2.0.31 reconhecem sem problemas os nomes extensos da partição Windows VFAT.

  • O GNU/Linux é considerado um sistema mais difícil do que os outros, mas
    isto é porque ele requer que a pessoa realmente aprenda e conheça
    computadores e seus periféricos antes de fazer qualquer coisa
    (principalmente se você é um técnico em manutenção, redes, instalações,
    etc., e deseja oferecer suporte profissional a este sistema).

    Você conhecerá mais sobre computadores, redes, hardware, software, discos,
    saberá avaliar os problemas e a buscar a melhor solução, enfim as
    possibilidades de crescimento neste sistema operacional depende do
    conhecimento, interesse e capacidade de cada um.

  • Peça ajuda a outros usuários do GNU/Linux quando estiver em dúvida ou não
    souber fazer alguma coisa no sistema. Você pode entrar em contato
    diretamente com outros usuários ou através de listas de discussão.

Boa Sorte e bem vindo ao GNU/Linux!

Gleydson (<gleydson@guiafoca.org>).

Pré-requisitos para a utilização deste guia

O Guia Foca Segurança não é voltado a usuários iniciantes, isto significa que é
assumido que você já saiba instalar serviços, criar contas e utilizar bem a
console no Linux. Em relação ao conhecimento, é recomendável que tenha ligo
pelo menos até o Guia Foca Intermediário, para que não tenha dificuldade de
entender serviços, configurações de rede, configurações de sistema e como
estruturar integrações em sua máquina.

Este guia não cobre a instalação do sistema. Para detalhes sobre instalação,
consulte a documentação que acompanha sua distribuição GNU/Linux.

Distribuições voltadas a Profissionais de Segurança

Só o Kernel Linux não é suficiente para se ter uma sistema funcional, mas é o
principal.

Existem grupos de pessoas, empresas e organizações que decidem "distribuir" o
Linux junto com outros aplicativos (como por exemplo editores gráficos,
planilhas, bancos de dados, ambientes de programação, formatação de documentos,
firewalls, etc).

Este é o significado essencial de distribuição. Cada distribuição tem sua
característica própria, como o sistema de instalação, o objetivo, a localização
de programas, nomes de arquivos de configuração, etc. A escolha de uma
distribuição é pessoal e depende das necessidades de cada um.

Algumas distribuições bastante conhecidas são: Ubuntu, Debian, Mint, Slackware,
Red Hat, Gentoo, Suse todas usando o SO Linux como kernel principal (a Debian é
uma distribuição independente de kernel e pode ser executada sob outros
kernels, como o GNU hurd ou o kernel BSD).

A escolha de sua distribuição deve ser feita com muita atenção, não adianta
muita coisa assistir canais do YouTube, perguntar em canais do Telegram qual é
a melhor distribuição, ser levado pelas propagandas, pelo vizinho, caso não
tenha testado uma que se adapte bem as suas necessidades. O melhor caminho para
a escolha da distribuição, acredito eu, seria perguntar as características de
cada uma e porque essa pessoa gosta dela ao invés de perguntar qual é a melhor,
porque quem lhe responder isto estará usando uma distribuição que se encaixa de
acordo com suas expectativas.

Segue abaixo as características de algumas distribuições usadas por
profissionais de segurança (Blue Team e Red Team):

KALI Linux

    https://www.kali.org - Baseada em Debian, e com instalação de pacotes e
    customizações voltadas a hacking ético e Pentest. O KALI hoje é considerado
    uma das distribuições mais avançadas e recomendadas para pentest em
    sistemas.

    Possui uma interface gráfica com centenas de programas classificados no
    menu de acordo com o tipo de atividade de Pentest que deseja realizar,
    algumas delas: Sniffer de Pacotes, Brute Force On-line, Brute Force
    off-line, forense, etc.

    https://www.kali.org/downloads/ - Endereço para download do Kali.

Debian

    http://www.debian.org/ - Está aqui por também atender boa parte dos
    requisitos de um Pentester, e possuir uma grande varidade de pacotes
    relacionados a testes de segurança em seu repositório. Distribuição
    desenvolvida e atualizada através do esforço de voluntários espalhados ao
    redor do mundo, seguindo o estilo de desenvolvimento GNU/Linux. Por este
    motivo, foi adotada como a distribuição oficial do projeto GNU. Possui
    suporte a língua Portuguesa, é a única que tem suporte a 9 arquiteturas
    diferentes (AMD64, i386, ARMEL, ARMHF, MIPS,MIPSEL,MIPS64el, etc.) e
    aproximadamente 15 arquitetura não suportadas oficialmente. A instalação da
    distribuição pode ser feita tanto através de flash disks, CD-ROM, Tftp,
    Ftp, NFS, imagem Docker ou através da combinação de vários destes em cada
    etapa de instalação.

    Acompanha mais de 59000 programas distribuídos em forma de pacotes cada um
    destes programas são mantidos e testados pela pessoa ou grupo responsável
    por seu empacotamento. Os pacotes são divididos em diretórios de acordo com
    sua categoria e gerenciados através de um avançado sistema de gerenciamento
    de pacotes (o apt e o dpkg) facilitando a instalação e atualização de
    pacotes. Possui tanto ferramentas para administração de redes e servidores
    quanto para desktops, estações multimídia, jogos, desenvolvimento, web,
    etc.

    A atualização da distribuição ou de pacotes individuais pode ser feita
    facilmente através de 2 comandos, não requerendo adquirir um novo CD para
    usar a última versão da distribuição. É a única distribuição não comercial
    onde todos podem contribuir usando seu conhecimento para o desenvolvimento.
    Para gerenciar os voluntários, conta com centenas de listas de discussão
    envolvendo determinados desenvolvedores das mais diversas partes do mundo.

    São feitos extensivos testes antes do lançamento de cada versão para
    atingir um alto grau de confiabilidade. As falhas encontradas nos pacotes
    podem ser relatados através de um sistema de tratamento de falhas que
    encaminha a falha encontrada diretamente ao responsável para avaliação e
    correção. Qualquer um pode receber a lista de falhas ou sugestões sobre a
    distribuição cadastrando-se em uma das lista de discussão que tratam
    especificamente da solução de falhas encontradas na distribuição
    (disponível na página principal da distribuição).

    Os pacotes podem ser instalados através de Tarefas contendo seleções de
    pacotes de acordo com a utilização do computador (servidor Web,
    desenvolvimento, TeX, jogos, desktop, etc.), Perfis contendo seleções de
    pacotes de acordo com o tipo de usuário (programador, operador, etc.), ou
    através de uma seleção individual de pacotes, garantindo que somente os
    pacotes selecionados serão instalados fazendo uma instalação enxuta.

    Existe um time de desenvolvedores com a tarefa específica de monitorar
    atualizações de segurança em serviços (apache, sendmail, e todos os outros
    59000 pacotes) que possam comprometer o servidor, deixando-o vulnerável a
    ataques. Assim que uma falha é descoberta, é enviado uma alerta (DSA -
    Debian Security Alert) e disponibilizada uma atualização para correção das
    diversas versões da Debian. Isto é geralmente feito em menos de 48 horas
    desde a descoberta da falha até a divulgação da correção. Como quase todas
    as falhas são descobertas nos programas, este método também pode ser usado
    por administradores de outras distribuições para manterem seu sistema
    seguro e atualizado.

    O suporte ao usuário e desenvolvimento da distribuição são feitos através
    de Telegram, listas de discussões e canais IRC. Existem uma lista de
    consultores habilitados a dar suporte e assistência a sistemas Debian ao
    redor do mundo na área consultores do site principal da distribuição.

    http://www.debian.org/ - Endereço para download.

Capítulo 2. Explicações Básicas

Índice

O que é Segurança e porque tornar um sistema seguro?
Os 4 pilares da segurança
LPI 303

Este capítulo traz explicações sobre os principais componentes existentes no
computador e do sistema operacional Linux.

O que é Segurança e porque tornar um sistema seguro?

Vamos iniciar com uma breve descrição do que é segurança: Segurança - Em
tecnologia, significa proteger algo físico ou lógico, permitindo que ele esteja
sempre disponível para quem precisa ter acesso. Desta forma uma das tarefas de
segurança é o bloqueio contra acessos indevidos.

Mas ai você se pergunta: mas segurança não é apenas proteger? Sim, mas fomos
ensinados que segurança esta mais relacionado a bloquear o acesso a algo, mas
isso nos faz cair em uma armadilha mental e evitar mecanismos que nos façam
proteger a informação para que esteja sempre disponível e principalmente:
íntegra. Então abordaremos a segurança no Guia Foca Segurança como ter dados
disponiveis no momento que precisa e de forma íntegra.

Pensando desta forma, entenderá que nada adianta seguir a popular frase de que
um sistema seguro deve estar fora de um ambiente de rede, dentro de um cofre e
desligado da tomada, se houver um incendio no local onde seus dados estão
armazenados, eles simplesmente serão perdidos da mesma forma que um ataque
cracker!

Os 4 pilares da segurança

Os 4 pilares descrevem valores que devem estar sempre presentes quando deseja
proteger algo na segurançda da informação. Eles são os seguintes:

 1. Confidencialidade - Basicamente refere-se as permissões de acesso, dar
    acesso a apenas as pessoas que precisam ter acesso aos dados. Em sistemas 
    Linux podemos por exemplo controlar a confidencialidade com modelos DAC
    (acesso por usuário/grupo/outros) ou modelos de segurança MAC (recursos
    permitidos de acesso a um processo ou usuário).

    Integridade - Aquele dado que está acessando está integro? não foi
    modificado por alguém indevido? o binário /usr/bin/sudo é realmente o sudo
    que foi instalado por sua distribuição? como ter certeza que ele não foi
    alterado? Essas peguntas estão relacionadas a integridade: Garantir que os
    dados são fiéis e não foram alterados de forma inadequada por pessoas,
    processos não autorizados. Uma invasão é um caso onde você tem uma quebra
    de integridade, que precisa ser corrigida.

    Disponibilidade - Disponibilidade está relacionado aos dados estarem
    disponíveis aos usuários quando preciso. Não adianta nada permissões de
    acesso, integridade, se a rede cai constantemente ou se o servidor web não
    comporta a carga de acesso. Sistemas de alta disponibilidade e anti-ataques
    também caem nessa categoria, pois impedem que o sistema tenha o serviço
    interrompido, afetando assim a experiência dos interessados.

    Autenticidade - Garante a validação de que a fonte de dados é quem ela diz
    ser. De nada adianta todos os ítens acima se a origem não for autenticada
    devidamente. A validação de autenticidade pode ser feito com credenciais
    convencionais (login/senha), chaves, certificados identificando devidamente
    a origem da comunicação.

LPI 303

A certificação LPI 303 foi criada para certificar profissionais de segurança
que desejam desempenhar suas funções da melhor forma possível usando Linux como
base. Note que atualmente, a maioria dos appliances de segurança e IOTs são
baseados em Linux, com isso, você terá uma ampla vantagem entendendo
profundamente o sistema e seus mecanismos de segurança de rede, host,
criptografia, etc.

Desta forma o Guia Foca Segurança foi escrito para também atender a pessoas que
desejam fazer a LPI 303.

Capítulo 3. Arquivos e daemons de Log

Índice

Formato do arquivo de log
Daemon de log do sistema

    rsyslogd
    Arquivo de configuração rsyslog.conf

logger
Programas úteis para monitoração e gerenciamento de arquivos de logs

    logcheck
    logrotate

Configurando um servidor de logs

A atividade dos programas são registradas em arquivos localizados em /var/log .
Estes arquivos de registros são chamados de logs e contém a data, hora e a
mensagem emitida pelo programa (violações do sistema, mensagens de erro, alerta
e outros eventos) entre outros campos. Enfim, muitos detalhes úteis ao
administrador tanto para acompanhar o funcionamento do seu sistema,
comportamento dos programas ou ajudar na solução e prevenção de problemas.

Alguns programas como o Apache, exim, ircd e squid criam diversos arquivos de
log e por este motivo estes são organizados em sub-diretórios (a mesma técnica
é usada nos arquivos de configuração em /etc, conforme a padrão FHS atual).

Formato do arquivo de log

Um arquivo de log é normalmente composto pelos seguintes campos:

Data|Hora|Máquina|daemon|mensagem

O campo máquina é o nome do computador que registrou a mensagem (a máquina pode
atuar como um servidor de logs registrando mensagens de diversos computadores
em sua rede). O campo daemon indica qual programa gravou a mensagem.

O uso dos utilitários do console pode ajudar muito na pesquisa e monitoração
dos logs, por exemplo, para obter todas as mensagens do daemon kernel da
estação de trabalho wrk1, eliminando os campos "wrk1" e "kernel":

grep 'wrk1' /var/log/* | grep 'kernel' | cut -d ' ' -f 1,2,3,6-11

Os parâmetros "$1", "$2" do comando awk indica que campos serão listados,
(omitimos $4 e $5 que são respectivamente "wrk1" e "kernel"). Um bom utilitário
para monitoração de logs está documentado em “logcheck”.

Daemon de log do sistema

O Daemon de log simplesmente é um programa que registra as saída de logs do
kernel e sistema. No Linux o daemon mais usado é o syslogd.

A classificação de qual arquivo em /var/log receberá qual tipo de mensagem é
controlado pelo arquivo de configuração /etc/rsyslog.conf através de 
facilidades e níveis (veja “Arquivo de configuração rsyslog.conf” para
detalhes).

rsyslogd

Este daemon controla o registro de logs do sistema.

rsyslogd [opções]

opções, -f

    Especifica um arquivo de configuração alternativo ao /etc/rsyslog.conf.

-h

    Permite redirecionar mensagens recebidas a outros servidores de logs
    especificados.

-n

    Evita que o processo caia automaticamente em background. Necessário
    principalmente se o syslogd for controlado pelo init.

-d

    Ativa o modo de depuração do syslog. O syslog permanecerá operando em
    primeiro plano e mostrará as mensagens no terminal atual.

Na distribuição Debian, o daemon syslogd é iniciado através do script /etc/
init.d/sysklogd.

Arquivo de configuração rsyslog.conf

O arquivo de configuração /etc/rsyslog.conf possui o seguinte formato:

facilidade.nível                    destino

A facilidade e nível são separadas por um "." e contém parâmetros que definem o
que será registrado nos arquivos de log do sistema:

  • facilidade - É usada para especificar que tipo de programa está enviando a
    mensagem. Os seguintes níveis são permitidos (em ordem alfabética):

      □ auth - Mensagens de segurança/autorização (é recomendável usar authpriv
        ao invés deste).

      □ authpriv - Mensagens de segurança/autorização (privativas).

      □ cron - Daemons de agendamento (cron e at).

      □ daemon - Outros daemons do sistema que não possuem facilidades
        específicas.

      □ ftp - Daemon de ftp do sistema.

      □ kern - Mensagens do kernel.

      □ lpr - Subsistema de impressão.

      □ local0 a local7 - Reservados para uso local.

      □ mail - Subsistema de e-mail.

      □ news - Subsistema de notícias da USENET.

      □ security - Sinônimo para a facilidade auth (evite usa-la).

      □ syslog - Mensagens internas geradas pelo syslogd.

      □ user - Mensagens genéricas de nível do usuário.

      □ uucp - Subsistema de UUCP.

      □ * - Confere com todas as facilidades.

    Mais de uma facilidade pode ser especificada na mesma linha do rsyslog.conf
    separando-as com ",".

  • nível - Especifica a importância da mensagem. Os seguintes níveis são
    permitidos (em ordem de importância invertida; da mais para a menos
    importante):

      □ emerg - O sistema está inutilizável.

      □ alert - Uma ação deve ser tomada imediatamente para resolver o
        problema.

      □ crit - Condições críticas.

      □ err - Condições de erro.

      □ warning - Condições de alerta.

      □ notice - Condição normal, mas significante.

      □ info - Mensagens informativas.

      □ debug - Mensagens de depuração.

      □ * - Confere com todos os níveis.

      □ none - Nenhuma prioridade.

    Além destes níveis os seguintes sinônimos estão disponíveis:

      □ error - Sinônimo para o nível err.

      □ panic - Sinônimo para o nível emerg.

      □ warn - Sinônimo para o nível warning.

  • destino - O destino das mensagens pode ser um arquivo, um pipe (se iniciado
    por um "|"), um computador remoto (se iniciado por uma "@"), determinados
    usuários do sistema (especificando os logins separados por vírgula) ou para
    todos os usuários logados via wall (usando "*").

Todas as mensagens com o nível especificado e superiores a esta especificadas
no rsyslog.conf serão registradas, de acordo com as opções usadas. Conjuntos de
facilidades e níveis podem ser agrupadas separando-as por ";".

OBS1: Sempre use TABS ao invés de espaços para separar os parâmetros do
rsyslog.conf.

OBS2: Algumas facilidades como security, emitem um beep de alerta no sistema e
enviam uma mensagem para o console, como forma de alerta ao administrador e
usuários logados no sistema.

Existem ainda 4 caracteres que garantes funções especiais: "*", "=", "!" e "-":

  • "*" - Todas as mensagens da facilidade especificada serão redirecionadas.

  • "=" - Somente o nível especificado será registrado.

  • "!" - Todos os níveis especificados e maiores NÃO serão registrados.

  • "-" - Pode ser usado para desativar o sync imediato do arquivo após sua
    gravação.

Os caracteres especiais "=" e "!" podem ser combinados em uma mesma regra.

Exemplo: Veja abaixo um exemplo de um arquivo /etc/rsyslog.conf padrão de
sistemas Debian

# /etc/rsyslog.conf arquivo de configuração do rsyslog
#
# Para mais detalhes, instale o rsyslog-doc e veja o arquivo
# /usr/share/doc/rsyslog-doc/html/configuration/index.html


#################
#### MODULOS ####
#################

module(load="imuxsock") # fornece suporte para log local do sistema
module(load="imklog")   # fornece suprote a log do kernel (antigo ulogd)
#module(load="immark")  # fornece recurso de colocação da mensagem --MARK--

# fornece suporte a recebimento de mensagens do UDP
#module(load="imudp")
#input(type="imudp" port="514")

# fornece suporte a recebimento de mensagens TCP
#module(load="imtcp")
#input(type="imtcp" port="514")


###########################
#### DIRETIVAS GLOBAIS ####
###########################

#
# Usar o formato tradicional de timestamps.
# Para ativar a precisão de timestamps, comente a seguinte linha.
#
$ActionFileDefaultTemplate RSYSLOG_TraditionalFileFormat

#
# Configura as permissões padrões para todos os arquivos de log
#
$FileOwner root
$FileGroup adm
$FileCreateMode 0640
$DirCreateMode 0755
$Umask 0022

#
# Onde devem ser colocados os arquivos de spool e estado
#
$WorkDirectory /var/spool/rsyslog

#
# Inclui todos os arquivos de configuração que existirem em /etc/rsyslog.d/
#
$IncludeConfig /etc/rsyslog.d/*.conf
#
# Primeiro alguns arquivos de log padrões. Registrados por facilidade
#

auth,authpriv.*                 /var/log/auth.log
*.*;auth,authpriv.none          -/var/log/syslog
cron.*                         /var/log/cron.log
daemon.*                        -/var/log/daemon.log
kern.*                          -/var/log/kern.log
lpr.*                           -/var/log/lpr.log
mail.*                          /var/log/mail.log
user.*                          -/var/log/user.log
uucp.*                          -/var/log/uucp.log

#
# Registro de logs do sistema de mensagens. Divididos para facilitar
# a criação de scripts para manipular estes arquivos.
#
mail.info                       -/var/log/mail.info
mail.warn                       -/var/log/mail.warn
mail.err                        /var/log/mail.err

# Registro para o sistema de news INN
#
news.crit                       /var/log/news/news.crit
news.err                        /var/log/news/news.err
news.notice                     -/var/log/news/news.notice

#
# Alguns arquivos de registro "pega-tudo".
# São usadas "," para especificar mais de uma prioridade (por
# exemplo, "auth,authpriv.none") e ";" para especificar mais de uma
# facilidade.nível que será gravada naquele arquivo.
# Isto permite deixar as regras consideravelmente menores e mais legíveis
#
*.=debug;\
        auth,authpriv.none;\
        news.none;mail.none     -/var/log/debug
*.=info;*.=notice;*.=warn;\
        auth,authpriv.none;\
        cron,daemon.none;\
        mail,news.none          -/var/log/messages

#
# Emergências são enviadas para qualquer um que estiver logado no sistema. Isto
# é feito através da especificação do "*" como destino das mensagens e são
# enviadas através do comando wall.
#
*.emerg                         *

#
# Eu gosto de ter mensagens mostradas no console, mas somente em consoles que
# não utilizo.
#
#daemon,mail.*;\
#       news.=crit;news.=err;news.=notice;\
#       *.=debug;*.=info;\
#       *.=notice;*.=warn       /dev/tty8

# O pipe /dev/xconsole é usado pelo utilitário "xconsole". Para usa-lo,
# você deve executar o "xconsole" com a opção "-file":
#
#    $ xconsole -file /dev/xconsole [...]
#
# NOTA: ajuste as regras abaixo, ou ficará maluco se tiver um site
# muito movimentado...
#
daemon.*;mail.*;\
        news.crit;news.err;news.notice;\
        *.=debug;*.=info;\
        *.=notice;*.=warn       |/dev/xconsole

# A linha baixo envia mensagens importantes para o console em que
# estamos trabalhando logados (principalmente para quem gosta de ter
# controle total sobre o que está acontecendo com seu sistema).
*.err;kern.debug;auth.notice;mail.crit  /dev/console

logger

Este comando permite enviar uma mensagem nos log do sistema. A mensagem é
enviada aos logs via daemon syslogd ou via soquete do sistema, é possível
especificar a prioridade, nível, um nome identificando o processo, etc. Seu uso
é muito útil em shell scripts ou em outros eventos do sistema.

logger [opções] [mensagem]

Onde:

mensagem

    Mensagem que será enviada ao daemon syslog

opções, -i

    Registra o PID do processo

-s

    Envia a mensagem ambos para a saída padrão (STDOUT) e syslog.

-f [arquivo]

    Envia o conteúdo do arquivo especificado como mensagem ao syslog.

-t [nome]

    Especifica o nome do processo responsável pelo log que será exibido antes
    do PID na mensagem do syslog.

-p [prioridade]

    Especifica a prioridade da mensagem do syslog, especificada como
    facilidade.nível. Veja os tipos de prioridade/níveis em “Arquivo de
    configuração rsyslog.conf”. O valor padrão prioridade.nível é user.notice

-u [soquete]

    Envia a mensagem para o [soquete] especificado ao invés do syslog

Mais detalhes sobre o funcionamento sobre o daemon de log do sistema rsyslogd,
veja “rsyslogd”

Exemplos: logger -i -t focalinux Teste teste teste, logger -i -f /tmp/mensagem
-p security.emerg

Programas úteis para monitoração e gerenciamento de arquivos de logs

logcheck

É um programa usado para enviar um e-mail periodicamente ao administrador do
sistema (através do cron ou outro daemon com a mesma função) alertando sobre os
eventos que ocorreram desde a última execução do programa. As mensagens do 
logcheck são tratadas por arquivos em /etc/logcheck e organizadas em categorias
antes de ser enviada por e-mail, isto garante muita praticidade na
interpretação dos eventos ocorridos no sistema.

As categorias são organizadas da mais importantes para a menos importante, e
vão desde "Hacking em andamento" (providências devem ser tomadas imediatamente
para resolver a situação) até "eventos anormais do sistema" (mensagens de
inicialização, mensagens dos daemons do sistema, etc.).

O tipo de mensagem que será incluída/ignorada nos logs enviados podem ser
personalizadas pelo administrador do sistema através dos arquivos/diretórios
dentro de /etc/logcheck. Nomes de arquivos/diretórios contendo a palavra
"ignore" são usados para armazenar expressões regulares que NÃO serão enviadas
pelo logcheck. É permitido o uso de expressões regulares perl/sed para
especificar as mensagens nos arquivos de log.

logrotate

Usado para fazer backups dos logs atuais do sistema (programado via cron, ou
outro daemon com a mesma função) e criando novos arquivos de logs que serão
usados pelo sistema. Opcionalmente os arquivos de logs antigos serão
compactados para diminuir a utilização de espaço em disco ou enviados por
e-mail ao administrador. A rotação dos arquivos de logs proporciona maior
agilidade quando precisamos encontrar algum detalhe útil (que seria mais
difícil de se achar em um arquivo de log de 10MB ou maior).

A rotação de logs é feita de acordo com o tamanho do arquivo de logs
especificado, mas a opção -f pode ser usada para "forçar" a rotação de logs. A
opção -d fornece mais detalhes sobre o que o logrotate está fazendo. Seu
arquivo principal de configuração é o /etc/logrotate.conf. Um modelo deste tipo
de arquivo é o seguinte:

#### Estas opções afetam globalmente o funcionamento do logrotate
# roda os arquivos de log semanalmente
weekly

# mantém as últimas 4 cópias de logs anteriores
rotate 4

# Erros de não existência dos logs são enviados para o usuário root
mail root

# Cria novos arquivos de log (vazios) após rodar os antigos
create

# Descomente isso se desejar seus arquivos de logs compactados. O parâmetro
# delaycompress é usado para que o primeiro log rodado seja mantido
# descompactado
compress
delaycompress

# Executam os scripts em prerotate e postrotate a cada vez que os logs
# forem rodados.
nosharedscripts

# Definimos um diretório que poderá conter definições individuais para
# diversos serviços no sistema, eles podem ir neste arquivo mas
# diversas configurações individuais podem deixar a interpretação
# deste arquivo confusa.
include /etc/logrotate.d


# Define opções específicas para a rotação mensal de /var/log/wtmp, o novo arquivo
# de log somente será rodados caso tenha mais de 5MB (size 5M), será criado
# com a permissão 0664 e pertencerá ao usuário root grupo utmp
# (create 0664 root utmp) e será mantida somente uma cópia do log anterior.
# (rotate 1)
/var/log/wtmp {
    monthly
    create 0664 root utmp
    size 5M
    rotate 1
}

# Define opções específicas para a rotação mensal de /var/log/btmp, se o arquivo
# não existir não será necessário gerar alertas (missinkok) que serão enviados
# ao administrador. O novo arquivo criado deverá ter a permissão 0664 com o
# dono root e grupo utmp (create 0664 root utmp) e será
# mantida somente uma cópia do log anterior.
/var/log/btmp {
    missingok
    monthly
    create 0664 root utmp
    rotate 1
}

# Define opções específicas para a rotação mensal de /var/log/lastlog, o novo
# arquivo será criado com a permissão 0664 com o dono root e grupo
# utmp e será mantida somente uma cópia do arquivo de log anterior
# (rotate 1).
/var/log/lastlog {
    missingok
    monthly
    create 0664 root utmp
    rotate 1
}

# Define opções específicas para a rotação diária de /var/log/messages, o
# arquivo será rodado se atingir o tamanho de 1Mb, então o
# novo arquivo será criado com as mesmas permissões do arquivo anterior.
# O comando killall -1 syslogd será executado após a rotação
# para que o daemon syslogd funcione corretamente mas somente uma vez
# durante a rotação de vários arquivos de logs (sharedscripts).
# Serão mantidas as 10 últimas cópias do arquivo /var/log/messages
# compactadas (o parâmetro compress foi especificado na seção global deste
# arquivo de configuração).
/var/log/messages {
    daily
    size 1M
    sharedscripts
    postrotate
      /sbin/killall -1 syslogd
    endscript
    rotate 10
}

# Define opções específicas para a rotação mensal dos arquivos em /var/log/mirror/*,
# a falta desses arquivos não precisa ser notificada ao administrador (missingok),
# mesmo assim o parâmetro "nomail" evitará isto de qualquer forma. Os logs
# rodados não serão compactados (nocompress) e serão mantidas as últimas 7 cópias
# dos logs.
/var/log/mirror/* {
   montly
   nomail
   missingok
   nocompress
   rotate 7
}

# logs específicos do sistema podem ser configurados aqui. As opções padrões e
# definidas na seção global deste arquivo serão usadas para processar os
# arquivos de logs restantes.

Qualquer definição de parâmetro especificado no arquivo de configuração,
substituirá as definições anteriores. Quando o número máximo de logs mantidos
pela opção rotate [num] é atingida, os logs eliminados serão enviados para o
usuário especificado na opção mail [email]. A utilização da diretiva nomail
evita isso.

Quando for utilizar coringas para se referir a determinados arquivos dentro de
um diretório, não utilize a sintaxe "log-xxx-*" porque isto forçaria a
recompactação de arquivos ".gz" já feitas, gerando arquivos do tipo .gz.gz... e
derrubando o processamento da sua máquina gerada por um loop de compactação e
enchendo as entradas de diretório. Prefira usar a sintaxe log-xxx-*.log (ou
outra, modificando a configuração do programa que gera os logs).

OBS: É importante enviar um sinal HUP ao programa que grava para aquele arquivo
de log para que não ocorram problemas após a rotação, isto é feito usando o
parâmetro postrotate.

Configurando um servidor de logs

As mensagens das máquinas de sua rede podem ser centralizadas em uma única
máquina, isto facilita o gerenciamento, análise e solução de problemas que
ocorrem nas máquinas da rede. Mais importante ainda é que qualquer invasão a
estação de trabalho não será registrada localmente (podendo ser apagada
posteriormente pelo invasor, isso é comum).

Configurando o servidor de logs

    Caso esteja usando o rsyslog, ative os módulos module(load='imudp') e 
    module(load='imtcp'). e a opção input() correspondente ao protocolo usado
    TCP/UDP no /etc/rsyslog.conf colocando a opção e reinicie o serviço usando
    systemctl restart rsyslog.

Configurando máquinas cliente

    Modifique o arquivo /etc/rsyslogd.conf (veja “Arquivo de configuração
    rsyslog.conf” colocando o nome do computador seguido de "@" para
    redirecionar as mensagens dos logs:

    auth,authpriv.*                 @servlog
    *.*;auth,authpriv.none          @servlog
    cron.*                          @servlog
    daemon.*                        @servlog
    kern.*                          -/var/log/kern.log
    kern.*                                          @servlog
    lpr.*                           @servlog
    mail.*                          /var/log/mail.log
    user.*                          -/var/log/user.log
    user.*                                          @servlog
    uucp.*                          -/var/log/uucp.log

    E reinicie o daemon rsyslogd da máquina cliente para re-ler o arquivo de
    configuração: killall -HUP rsyslogd ou systemctl restasrt rsyslog.

OBS1: Mantenha o relógio do servidor de logs sempre atualizado (use o ntpdate
ou chrony ou outro daemon de sincronismo NTP para automatizar esta tarefa).

OBS2: Se desejar modificar a localização padrão do /etc/rsyslog.conf, modifique
o arquivo syslogd.c na linha:

#define _PATH_LOGCONF   "/etc/syslog.conf"

Use a imaginação para escolher um nome de arquivo e localização que dificulte a
localização deste arquivo por pessoas não autorizadas.

OBS3: Em uma grande rede, é recomendável configurar um computador dedicado como
servidor de log (desativando qualquer outro serviço) e configurar o iptables
para aceitar somente o tráfego indo para a porta UDP e TCp 514 (syslogd):

iptables -P INPUT DROP
iptables -A INPUT -p udp --dport 514 -j ACCEPT
iptables -A INPUT -p udp --dport 514 -j ACCEPT

Capítulo 4. Gerenciamento de contas e cuidados para a proteção de senhas

Índice

Introdução
Criação, monitoramento e segurança de contas

    Definindo valores padrões de restrição
    Senhas fáceis de adivinhar e a escolha de boas senhas
    Atualização de senhas de múltiplas contas
    A senha do usuário root

Tipos de ataques mais comuns para se conseguir uma senha.

    Dedução
    Engenharia Social
    Ataques por dicionário
    Brute Force
    Monitoramento de toques do teclado
    Login falso

Melhorando a segurança das senhas armazenadas em seu sistema

    Shadow Passwords
    Senhas Sha512, SHA256 e MD5

Este capítulo traz explicações e comandos úteis para o gerenciamento de contas
e proteção de senhas de usuários em sistemas Linux. Também explica os
principais métodos usados para quebra de senha usando diversos métodos como
engenharia social, brute force, etc., bem como dicas de como escolher boas
senhas para você e seus usuários e métodos automatizados de checagem de senhas
vulneráveis.

Estes métodos são explicados para que você entenda, se previna destes tipos de
ataques além de entender a importância de políticas de proteção de senhas.

Introdução

A criação de uma conta em uma máquina Linux pode expor seu sistema (ou todas
suas redes) a crackers simplesmente com a falta de treinamento e políticas de
segurança. Uma invasor com um simples acesso a uma conta de usuário pode
conseguir acesso a áreas que contém dados importantes expondo seu sistema a
ataques ou roubo de dados.

Um firewall não pode fazer muito em uma situação dessas, um acesso através de
uma conta de sistema válida é difícil de ser auditado e descoberto, a não ser
que o usuário monitore seus acesso via lastlog e o administrador conheça os
hábitos de seus usuários para notar o uso estranho de contas em determinados
dias/horários. Evitar situações como esta depende mais de conscientização e
treinamento tanto do administrador como dos usuários das contas para não expor
o sistema a um ataque direto. Este capítulo do guia explicará as situações mais
comuns e alguns exemplos de como tais ataques acontecem.

ATENÇÃO: - Os dados aqui disponibilizados são puramente para fins didáticos e
compreensão de como tais situações funcionam para se criar mecanismos de defesa
personalizados de acordo com o que deseja proteger.

Criação, monitoramento e segurança de contas

Para adicionar uma conta de usuário ao sistema é simples, basta um comando
adduser [usuário] e alguns poucos segundos para responder as questões do
programa. Quando criamos contas para outros usuários temos 2 alternativas:
deixarmos a senha em branco ou escolher uma senha que será passada ao usuário
para que ele possa fazer a troca mais tarde. A primeira alternativa é muito
perigosa, pois uma pessoa com acesso a /etc/passwd poderá facilmente descobrir
sua lista de usuários (principalmente em uma grande empresa quando conhecemos
as políticas de criação de novas contas). Um funcionário notaria a presença do
novato e poderia aproveitar esta oportunidade para tentar incriminar este
usando a conta recém criada ou tentar outras coisas para obter benefício
próprio através do descuido de outros.

O segundo método de senha inicial é um pouco mais seguro e de preferência a
senha deve ser escolhida pelo usuário para que pessoas que conhecem o estilo de
senhas iniciais escolhidas pelo administrador não possam deduzir a nova senha
criada. É comum vermos senhas como "novo1234", "123456", "abcdef", "a1b3c3", o
"nome do usuário" como senhas iniciais, pois é fácil de lembrar. Senhas deste
tipo são as primeiras a ser tentadas por crackers e programas específicos para
este fim. Mas se o o usuário esquecer de trocar sua senha provisória?

O programa chage e passwd possui recursos que permitem definir limites mínimos
e máximo do tempo para troca de senha de acesso, número máximo de dias após
expirar o tempo de troca da senha em que a conta será permanentemente
desabilitada (até que o administrador a reative) e o período mínimo entre troca
de senhas. Alguns exemplos:

passwd -x 10 -w 3 teste

A senha do usuário teste expirará após 10 dias (-x 10) e ele será avisado com 3
dias de antecedência (-w 3) para trocar sua senha. Após o período máximo o
usuário será obrigado a trocar a senha.

Quando o usuário efetuar o login receberá a seguinte mensagem: Warning: your
password will expire in 3 days.

passwd -x 10 -w 3 -i 2 teste

A senha do usuário teste expirará após 10 dias (-x 10) e ele será avisado com 3
dias de antecedência (-w 3) para trocar sua senha, após a expiração da senha, o
usuário tem 2 dias antes da conta ser desativada (-i 2). Se o período expirar e
o usuário tentar um novo login será mostrada a mensagem:

Your account has expired: Please contact your system administrator

Para reativar a conta acima, remova totalmente o bloqueio da conta do usuário
teste com passwd -x 0 teste, passwd -x 99999 -w 7 -i 0 teste ou especifique um
período de dias maior em adição àqueles especificados para que ele possa trocar
a senha.

Por exemplo, caso tenha passado 3 dias desde que a conta acima expirou e deseje
dar mais 2 dias para o usuário trocar a conta: passwd -x 17 -i 0 teste A conta
será reativada por mais 2 dias dando a oportunidade do usuário trocar a senha.
Preste atenção neste exemplo para entender bem a situação e prazos.

passwd -x 90 -n 60 -w 15 -i 0 teste

A senha do usuário teste expirará após 90 dias (-x 90), ele será avisado para
trocar sua senha com 15 dias antes do prazo final (-w 15) e a conta será
imediatamente desativada caso o prazo máximo para troca da senha expire (-i 0).
O usuário também não poderá trocar sua senha durante os primeiros 60 dias desde
a última troca de senha (-n 60).

Em sistemas onde precisa adicionar restrições a muitos usuários na criação da
conta, é recomendável seguir os métodos descritos em “Definindo valores padrões
de restrição”.

OBS1: Em sistemas com senhas ocultas ativadas (veja “Shadow Passwords”) as
restrições acima serão especificadas no arquivo /etc/shadow, isto garante que
só o usuário root tenha acesso aos detalhes fornecidos neste arquivo.

OBS2: A -d do passwd serve para remover a senha do usuário especificado ou seja
somente será necessário fornecer o nome de usuário para ter acesso ao sistema.

OBS3: Leve em consideração que o uso do recursos de senhas de grupo é um risco
de segurança, pois a mesma senha será compartilhada entre diversas pessoas.

OBS4: O programa useradd combina as funções do adduser e passwd para garantir
que a conta seja criada com as restrições apropriadas. O único inconveniente é
que o useradd quebra o Debian Policy e precisa de todos todos os parâmetros
para a criação correta da conta (como o diretório home, senha criptografada, e
UID numérico). Seu uso é indicado em shell scripts que cuidam automaticamente
da tarefa de adicionar usuários ao sistema.

Definindo valores padrões de restrição

Isto é muito útil quando precisa criar diversos usuários com as mesmas
restrições de contas, isto tornará o gerenciamento do sistema muito mais
prático (tudo em Unix é feito para ser mais prático, só devemos saber onde
mexer). O arquivo /etc/defaults/useradd contém valores padrões que serão usados
pelo useradd e adduser para definir valores de restrições de contas. Estes
valores são gerados usando a opção -D em combinação com as seguintes opções do 
useradd:

  • -b [home] - Especificar o diretório home de usuário. O padrão é /home.

  • -e [data] - Data padrão de expiração de contas, especificada no formato
    AnoMesDia. Por exemplo, 20010920.

  • -f [dias] - Número máximo de dias que a conta permanece válida após a data
    de expiração até ser desativada.

  • -g [gid/grupo] - ID do grupo ou nome do grupo que o usuário pertencerá
    inicialmente.

  • -s [shell] - Shell do usuário. O padrão é /bin/bash.

OBS: Note que nem todas as opções acima terão efeito com o adduser
(principalmente as opções -f, -g e -s que são especificadas no seu arquivo de
configuração /etc/adduser.conf).

Senhas fáceis de adivinhar e a escolha de boas senhas

A senha lhe identifica como o verdadeiro dono de uma conta em um sistema para
garantir acesso a seus recursos. A senha de um sistema é tão importante quanto
uma senha de sua conta bancária, caso caia em mãos erradas as conseqüências
poderão ser catastróficas, todo cuidado é pouco na hora de escolher uma senha.

Senhas fáceis de adivinhar são o primeiro motivo de sucesso de crackers no
acesso a sistemas de computadores (veja “Dedução” e “Engenharia Social”), o
administrador pode forçar o usuário a fazer trocas periódicas de senhas através
dos recursos citados em “Criação, monitoramento e segurança de contas”, mas
quem vai garantir que ele esteja escolhendo boas senhas para que ninguém as
descubra com facilidade? Abaixo uma lista de senhas ruins (que deverá evitar a
todo custo usa-las) e boas:

Senhas Ruins

  • O uso da palavra senha como senha! Isto parece idiota mais existe...

  • Senhas com o mesmo nome do login (joao/joao).

  • Compostas por letras ou números em seqüencia crescente ou decrescente
    (abcdef, 123456, 654321, etc, etc). Este tipo de senha pode ser adivinhada
    por dedução e são uma das primeiras combinações que crackers usam para
    acertar senhas.

  • palavras relacionadas com o gosto pessoal. Por exemplo "volks", "aston",
    "ferrari" se a pessoa é amante de carros.

  • Nome da esposa, filhos, familiares, animal de estimação, time de futebol,
    ídolo da TV/filmes ou qualquer coisa relacionada a familiares ou
    indiretamente ao usuário.

  • Idade, data de aniversário, data de casamento, número de identidade, título
    de eleitor, placa de carro ou qualquer coisa que seja característica do
    usuário.

  • Palavras existentes, algo que existe em alguma literatura. Um ataque de
    dicionário / brute force poderá quebrar facilmente sua senha, ou o tempo de
    dedução será fortemente reduzido.

  • Senhas com menos de 12 caracteres

  • Senhas apenas em minúsculas ou MAIÚSCULAS.

Senhas Boas

  • Uma boa senha nunca deverá ser lida mas fácil de lembrar. Por exemplo pense
    em uma frase importante para você "meu sistema operacional preferido é o
    Linux" e pegue a primeira letra de cada palavra: "msopeol". PRONTO esta
    escolhida uma boa senha que é fácil de se lembrar e difícil de ser quebrada
    por ataques de dicionário, e além disso, fácil de digitar!

  • Uma boa senha deve conter números e letras. A senha acima poderia ser
    modificada para "msopeol1"

  • Conter letras maiúsculas, minúsculas, números, pontuação e caracteres
    especiais: "msopeoL1@!.".

  • Conter no mínimo 12 caracteres sempre que possível. Com o aumento do poder
    de processamento das máquinas e sistemas de cálculo criptográficos (usados
    principalmente em mineração de BitCoins, este é o tamanho mínimo de senha
    recomendável. Isto aumenta bastante o número de combinações necessárias
    para se quebrar uma senha em um ataque brute force (veja “Brute Force”).
    Mesmo que a senha escolhida não chegue a 8 caracteres mínimos, você poderá
    combina-la com números.

  • Não reutilize a senha entre sites; caso a segurança de um site for
    comprometida, e sua senha vazar, outras contas serão igualmente
    comprometidas.

Com as dicas acima, a possibilidade de alguém conseguir quebrar uma senha
criptografada em seu sistema usando os ataques descritos em “Tipos de ataques
mais comuns para se conseguir uma senha.” é praticamente nula! Além do impacto
de uma senha vazada em um site (quando usado em sistemas na internet), não
impactar outros sites que utiliza a mesma conta. Para os paranóicos de plantão,
o utilitário makepasswd pode criar uma senha com caracteres completamente
aleatórios:

makepasswd --chars 12
4y0sBdwMd3#f

Este comando retorna uma string com 12 caracteres (--) "4y0sBdwMd3#f". Se você
entendeu boa parte deste guia tenho certeza que 1 ou 2 dias de treino e se
acostuma com uma senha como esta ;-)

OBS: NUNCA NUNCA dê pistas sobre sua senha! Para você isto pode ser um desafio
lançado a outras pessoas quase impossível de ser resolvido, mas não se esqueça
que muita gente é especializada neste tipo de dedução.

Atualização de senhas de múltiplas contas

O programa chpasswd é usado para tal operação. Deve ser especificado um arquivo
que contém os campos usuário:senha por linha. Caso as senhas estejam
encriptadas deverá ser especificada a opção -e ao programa.

chpasswd -e /localadmin/contas/contas.db

O comando acima atualiza a senha de todos os usuários especificados no arquivo
contas.db de uma só vez.

A senha do usuário root

Esta seção foi retirada do Manual de Instalação da Debian.

A conta root é também chamada de super usuário, este é um login que não possui
restrições de segurança. A conta root somente deve ser usada para fazer a
administração do sistema, e usada o menor tempo possível.

Qualquer senha que criar deverá conter de 6 a 8 caracteres, e também poderá
conter letras maiúsculas e minúsculas, e também caracteres de pontuação. Tenha
um cuidado especial quando escolher sua senha root, porque ela é a conta mais
poderosa. Evite palavras de dicionário ou o uso de qualquer outros dados
pessoais que podem ser adivinhados.

Se qualquer um lhe pedir senha root, seja extremamente cuidadoso. Você
normalmente nunca deve distribuir sua conta root, a não ser que esteja
administrando um computador com mais de um administrador do sistema.

Utilize uma conta de usuário normal ao invés da conta root para operar seu
sistema. Porque não usar a conta root? Bem, uma razão para evitar usar
privilégios root é por causa da facilidade de se cometer danos irreparáveis
como root. Outra razão é que você pode ser enganado e rodar um programa Cavalo
de Tróia -- que é um programa que obtém poderes do super usuário para
comprometer a segurança do seu sistema sem que você saiba.

Tipos de ataques mais comuns para se conseguir uma senha.

Dedução

O cracker se aproveita da ingenuidade de usuários que deixam senhas em branco,
usam senhas simples como o próprio nome, "abcdef", "asdfg", "123456", e outros
tipos de senhas comuns para tentar obter acesso ao sistema. Senhas deduzidas
são geralmente senhas muito simples e muito usadas... Uma situação comum para a
escolha de uma senha deste tipo é o medo de esquecer a senha (quando não se
consegue pensar em algo mais difícil e ao mesmo tempo que seja fácil de
lembrar) e quando o usuário é pego desprevenido e não se sabe o que usar como
senha (como na assinatura de um provedor Internet, muito comum essa situação).

Geralmente é muito rápido e muito eficaz dependendo das habilidades do atacante
dispõe.

Engenharia Social

Ataques por engenharia social são feitos através de pesquisa de dados pessoais
e outras características relacionadas ao usuário (time de futebol, data de
nascimento dele, da esposa, filhos, nome da atriz predileta, etc) e usando
estes dados coletados para auxiliar na descoberta da senha. Este ataque requer
uma pesquisa sobre os hábitos, gostos, etc. Mas existem outros tipos de ataque
baseados em engenharia social, inclusive com o cracker passando-se pelo
usuário. Para diminuir as possibilidades deste tipo de ataque entenda e siga os
procedimentos da parte "Senhas Boas" na “Senhas fáceis de adivinhar e a escolha
de boas senhas” e continue lendo esta seção.

Outro detalhe importante para diminuir as possibilidades de um ataque deste
tipo bem sucedido é permitir somente o acesso do serviço de finger a redes
confiáveis (locais onde uns conhecem os outros). Os detalhes fornecidos pelo
finger podem ser suficientes para garantir sucesso deste tipo de ataque:

#finger joao
Login: joao                             Name: Joao P. M.
Directory: /home/joao                   Shell: /bin/bash
Office: Sala 400 Andar 2, 123-4567  Home: 123-7654
Last login Fri Aug 25 21:20 (AMT) on tty3
No mail.
Grupo de cadastramento.

As últimas linhas da saída do finger são os dados contidos nos arquivos .plan e
.project do diretório de usuário. O cracker com base nos dados fornecidos acima
pelo finger poderia inventar uma situação em que necessitaria de troca de senha
por algum motivo. Abaixo uma situação onde o cracker sabe que não existe
identificador de chamadas na empresa e conhece as fragilidades:

  • Cracker: Disca para o CPD?

  • Vitima: CPD?

  • Cracker: Oi, eu sou o Joao P. M. do grupo de cadastramento aqui do segundo
    andar, estou tentando entrar no sistema mas por algum motivo ele não aceita
    minha senha (fazendo-se de ignorante no assunto).

  • Vitima: Por favor Sr. verifique se o Caps Lock do seu teclado está ativado,
    letras em maiúsculas/minúsculas fazem diferença em nossos sistemas.

  • Cracker: Ok vou checar (espera um tempo). Não, esta tudo Ok, você poderia
    agilizar isto de alguma maneira, preciso lançar algumas fichas no sistema.

  • Vitima: Posso modificar sua senha para um nome qualquer, depois você poderá
    trocar por si próprio.

  • Cracker: Ok, por mim tudo bem.

  • Vitima: Humm, modifiquei para "cad1234", basta você usa-la e terá acesso ao
    sistema. Após isso execute o utilitário passwd para troca-la para algo que
    desejar.

  • Cracker: Ok, muito obrigado. Tenha um bom dia.

Este é um exemplo simples de ataque por engenharia social. Dependendo do
objetivo, este tipo de ataque pode levar semanas e as vezes requer contatos com
diversas empresas criando diversas situações para obter detalhes necessários
para atingir o objetivo.

As políticas de segurança de senhas minimizam riscos deste tipo. Como este é um
caso que o requisitante é um funcionário próximo do departamento de
informática, o mais adequado seria o administrador se deslocar ao setor (ou
enviar um técnico do setor treinado para tal situação) para saber se quem diz
ser quem é está realmente no local enfrentando aquela situação. O contato com o
responsável do setor (conhecido do técnico) também pode ser uma alternativa
antes de entregar uma senha a um desconhecido.

Para casos externos (principalmente para empresas que mantém determinados
serviços em funcionamento em nosso servidor, como servidores de páginas), o
procedimento correto seria passar uma nova senha por e-mail (de preferência
criptografado com pgp) ao invés de telefone. Isto garantirá que a senha não
caia nas mãos erradas.

OBS1: Qualquer detalhe sobre a política de criação de senhas, trocas de senhas,
etc. poderá ter muito valor para um cracker obter acesso ao seu sistema.

OBS2: Dificulte as maneiras para se obter acesso root ao sistema via conta de
usuário comum. É de extrema importância utilizar conexões de dados
criptografadas quando for necessário acesso externo ao seu sistema.

OBS3: Nunca use uma mesma senha para fazer tudo (banco, acessar seu sistema,
conectar-se ao seu provedor, senha de root). Você estará em sérios apuros caso
alguém tenha acesso a esta senha. É difícil lembrar de várias senhas, mas você
pode aditar uma senha e criar modificações a partir dela para utilização em
outros locais, por exemplo: "wekpdm" => "Bwekpdm1" => "3wekpdmS", etc.

Ataques por dicionário

De posse do arquivo de senhas /etc/passwd, o cracker utiliza um arquivo que
contém diversas palavras que serão tentadas como senha. Este trabalho é feito
automaticamente por ferramentas dedicadas a este tipo de tarefa e pode levar
dias dependendo da lista de senhas do cracker e quantidades de usuários
existentes no arquivo de senha.

Note que o uso de criptografia md5 e senhas ocultas dificultam bastante ao
arquivo de senhas e o sucesso de um ataque bem sucedido (veja “Shadow
Passwords” e “Senhas Sha512, SHA256 e MD5”).

Brute Force

De posse do arquivo de senhas /etc/passwd o cracker utiliza uma ferramenta que
tenta diversas combinações de letras seqüencialmente na tentativa de descobrir
uma senha. Este ataque geralmente é usado como último recurso após um ataque
por dicionário, e leva muito tempo para descobrir uma senha.

Dependendo se uma senha conter caracteres aleatórios, combinação de letras
maiúsculas/minúsculas, números, a senha será praticamente impossível de ser
descoberta. Note que o uso de criptografia md5 e senhas ocultas aumentam
bastante a proteção das senhas (veja “Shadow Passwords” e ???).

Monitoramento de toques do teclado

Este ataque (popularmento chamado keylogger) é muito comum em sistemas MAC e
Windows, um programa malicioso é instalado sem o conhecimento do usuário que
grava todos os toques do teclado em um arquivo escondido pelo cracker. Após
certo tempo o cracker obtém acesso ao arquivo e aos dados que ele contém. Este
tipo de ataque é muito perigoso e pode capturar senhas não só do sistema como
números de cartão de crédito digitados (caso o usuário tenha feito compras
on-line), conta bancária+senha e tudo mais que for digitado pelo teclado.

Login falso

Esta é uma forma rápida de se conseguir acesso a um sistema. É criada uma tela
de login idêntica a original do sistema, só que ao digitar nome e senha, estes
são gravados em um arquivo (que será mais tarde recuperado pelo cracker para
obter acesso ao sistema) e uma mensagem de erro será exibida pelo sistema.

Naturalmente o usuário pensará que digitou o nome/senha incorretamente e fará
uma nova tentativa, a segunda ocorrerá com sucesso (fazendo este pensar que
errou *mesmo* a senha).

Sua atenção é muito importante para evitar este tipo de ataque, caso desconfie
de algo errado, entra no sistema e dê um find --type f -cmin -3 para localizar
os arquivos modificados nos últimos 3 minutos e localizar possíveis bancos de
dados de senhas.

Outra alternativa é realmente digitar uma senha inválida intencionalmente (e
diferente da correta) e na segunda tentativa lançar a senha válida (normalmente
sistemas deste tipo bem elaborados chamam o verdadeiro sistema de login na
segunda tentativa).

Melhorando a segurança das senhas armazenadas em seu sistema

Shadow Passwords

Senhas Ocultas (shadow passwords) aumentam consideravelmente a senha do seu
sistema pois as senhas serão armazenadas em um arquivo separado: /etc/shadow
para senhas de usuários e /etc/gshadow para senhas de grupos. Estes dois
arquivos poderão ser acessados somente pelo usuário root. O armazenamento de
senhas no arquivo /etc/passwd e /etc/groups não é seguro, estes arquivos devem
ser lidos por todos os usuários porque muitos programas mapeiam a UID do
usuário com seu nome e vice versa.

O utilitário shadowconfig é usado para ativar/desativar o suporte a senhas
ocultas (de usuários e grupos) em seu sistema. Adicionalmente os utilitários 
pwconv/grpconv podem ser usados separadamente para ativar o suporte a senhas
ocultas de usuários/grupos e pwunconv/grpunconv para desativar este suporte.

ATENÇÃO: Caso você inclua usuários em grupos manualmente no arquivo /etc/
passwd, também precisará fazer isto no arquivo /etc/shadow para que não tenha
problemas. Esta tarefa é feita automaticamente com o comando adduser usuário
grupo. O programa vipw e vigr também podem ser usados com a opção -s para
editar os arquivos /etc/shadow e /etc/gshadow respectivamente.

Senhas Sha512, SHA256 e MD5

O sistema de criptografia usado pelo SHA512 é mais seguro que o SHA256, e este
é mais seguro que o MD5. Na escala de algoritmos mais seguros para o menos
seguro, seguido da respectiva forma de identificar qual é qual no /etc/shadow
temos o seguintes:

 1. SHA512

    - Tipicammente inicia por $6$Salt$Encriptacao

 1. SHA256

    - Tipicammente inicia por $5$Salt$Encriptacao

 1. Blowfish

    - Tipicammente inicia por $2$Salt$Encriptacao

 1. Blowfish (com correçao caracteres 8 bits)

    - Tipicammente inicia por $2y$Salt$Encriptacao

 1. MD5

    - Tipicammente inicia por $1$Salt$Encriptacao. O uso de MD5 é desencorajado
    hoje em dia devido ao ataque de colisão de hash

 1. Crypto

    - Obsoleto, não deve ser mais utilizado de forma alguma! Limitado ao máximo
    de 8 caracteres. Uso é totalmente desencorajado hoje em dia.

O Salt de uma senha pode ter até 16 caracteres, e Encriptacao é a senha
criptografada.

Para gerar uma senha com um algoritmo específico, utilize: mkpasswd --method=
sha512 --salt=abacabbXYZ SENHA

Caso utilize senhas SHA512 em um sistema com PAM, inclua a palavra SHA5125 na
linha de configuração do método de autenticação password do módulo pam_unix.so:

password required pam_unix.so sha512

Capítulo 5. Firewall iptables

Índice

Introdução

    Versão
    Um resumo da história do iptables
    Características do firewall iptables
    Ficha técnica
    Requerimentos
    Arquivos de logs criados pelo iptables
    Instalação
    Enviando Correções/Contribuindo com o projeto
    O que aconteceu com o ipchains e ipfwadm?
    Tipos de firewalls
    O que proteger?
    O que são regras?
    O que são chains?
    O que são tabelas?
    Habilitando o suporte ao iptables no kernel
    Ligando sua rede interna a Internet

Manipulando chains

    Adicionando regras - A
    Listando regras - L
    Apagando uma regra - D
    Inserindo uma regra - I
    Substituindo uma regra - R
    Criando um novo chain - N
    Renomeando um chain criado pelo usuário - E
    Listando os nomes de todas as tabelas atuais
    Limpando as regras de um chain - F
    Apagando um chain criado pelo usuário - X
    Zerando contador de bytes dos chains - Z
    Especificando a política padrão de um chain - P

Outras opções do iptables

    Especificando um endereço de origem/destino
    Especificando a interface de origem/destino
    Especificando um protocolo
    Especificando fragmentos
    Especificando uma exceção
    Especificando um alvo
    Salvando e Restaurando regras

A tabela nat (Network Address Translation) - fazendo nat

    Criando um novo chain na tabela NAT
    Fazendo IP masquerading (para os apressados)
    Fazendo SNAT
    Fazendo DNAT
    Monitorando conexões feitas na tabela nat

A tabela mangle

    Especificando o tipo de serviço
    Especificando o TOS para tráfego de saída

Outros módulos do iptables

    Conferindo de acordo com o estado da conexão
    Limitando o número de vezes que a regra confere
    Proteção contra ping da morte
    Proteção contra syn flood
    Proteção contra IP spoofing
    Especificando múltiplas portas de origem/destino
    Especificando o endereço MAC da interface
    Conferindo com quem criou o pacote
    Conferindo com o conteúdo do pacote
    Conferindo com o tempo de vida do pacote
    Conferindo com números RPC
    Conferindo com tipo de pacote
    Conferindo com o tamanho do pacote

Caminho percorrido pelos pacotes nas tabelas e chains

    Ping de 192.168.1.1 para 192.168.1.1
    Conexão FTP de 192.168.1.1 para 192.168.1.1
    Conexão FTP de 192.168.1.1 para 192.168.1.4
    Conexão FTP de 200.217.29.67 para a máquina ftp.debian.org.br
    Ping de 192.168.1.4 para 192.168.1.1
    Conexão FTP de 192.168.1.4 para 192.168.1.1
    Conexão FTP de 192.168.1.4 para ftp.debian.org.br
    Conexão FTP de 200.198.129.162 para 200.217.29.167
    Gráfico geral da passagem dos pacotes

Exemplos de configurações do iptables

    Bloqueando conexões de fora para sua máquina
    Monitorando tentativa de conexão de trojans em sua máquina
    Conectando sua rede interna a Internet
    Um exemplo de firewall simples

Este capítulo documenta o funcionamento do firewall iptables que acompanha a
série do kernel 2.4, opções usadas, e aponta alguns pontos fundamentais para
iniciar a configuração e construção de bons sistemas de firewall.

Introdução

O Firewall é um programa que como objetivo proteger a máquina contra acessos
indesejados, tráfego indesejado, proteger serviços que estejam rodando na
máquina e bloquear a passagem de coisas que você não deseja receber (como
conexões vindas da Internet para sua segura rede local, evitando acesso aos
dados corporativos de uma empresa ou a seus dados pessoais). No kernel do Linux
2.4, foi introduzido o firewall iptables (também chamado de netfilter) que
substitui o ipchains dos kernels da série 2.2. Este novo firewall tem como
vantagem ser muito estável (assim como o ipchains e ipfwadm), confiável,
permitir muita flexibilidade na programação de regras pelo administrador do
sistema, mais opções disponíveis ao administrador para controle de tráfego,
controle independente do tráfego da rede local/entre redes/interfaces devido a
nova organização das etapas de roteamento de pacotes.

O iptables é um firewall em nível de pacotes e funciona baseado no endereço/
porta de origem/destino do pacote, prioridade, etc. Ele funciona através da
comparação de regras para saber se um pacote tem ou não permissão para passar.
Em firewalls mais restritivos, o pacote é bloqueado e registrado para que o
administrador do sistema tenha conhecimento sobre o que está acontecendo em seu
sistema.

Ele também pode ser usado para modificar e monitorar o tráfego da rede, fazer
NAT (masquerading, source nat, destination nat), redirecionamento de pacotes,
marcação de pacotes, modificar a prioridade de pacotes que chegam/saem do seu
sistema, contagem de bytes, dividir tráfego entre máquinas, criar proteções
anti-spoofing, contra syn flood, DoS, etc. O tráfego vindo de máquinas
desconhecidas da rede pode também ser bloqueado/registrado através do uso de
simples regras. As possibilidades oferecidas pelos recursos de filtragem 
iptables como todas as ferramentas UNIX maduras dependem de sua imaginação,
pois ele garante uma grande flexibilidade na manipulação das regras de acesso
ao sistema, precisando apenas conhecer quais interfaces o sistema possui, o que
deseja bloquear, o que tem acesso garantido, quais serviços devem estar
acessíveis para cada rede, e iniciar a construção de seu firewall.

O iptables ainda tem a vantagem de ser modularizável, funções podem ser
adicionadas ao firewall ampliando as possibilidades oferecidas. Usei por 2 anos
o ipchains e afirmo que este é um firewall que tem possibilidades de gerenciar
tanto a segurança em máquinas isoladas como roteamento em grandes organizações,
onde a passagem de tráfego entre redes deve ser minuciosamente controlada.

Um firewall não funciona de forma automática (instalando e esperar que ele faça
as coisas por você), é necessário pelo menos conhecimentos básicos de rede tcp/
ip, roteamento e portas para criar as regras que farão a segurança de seu
sistema. A segurança do sistema depende do controle das regras que serão
criadas por você, as falhas humanas são garantia de mais de 95% de sucesso nas
invasões.

Enfim o iptables é um firewall que agradará tanto a pessoas que desejam uma
segurança básica em seu sistema, quando administradores de grandes redes que
querem ter um controle minucioso sobre o tráfego que passam entre suas
interfaces de rede (controlando tudo o que pode passar de uma rede a outra),
controlar o uso de tráfego, monitoração, etc.

Versão

É assumido que esteja usando a versão 1.2.3 do iptables e baseadas nas opções
do kernel 2.4.16 (sem o uso de módulos experimentais). As explicações contidas
aqui podem funcionar para versões posteriores, mas é recomendável que leia a
documentação sobre modificações no programa (changelog) em busca de mudanças
que alterem o sentido das explicações fornecidas aqui.

Um resumo da história do iptables

O iptables é um código de firewall das versões 2.4 do kernel, que substituiu o 
ipchains (presente nas séries 2.2 do kernel). Ele foi incluído no kernel da
série 2.4 em meados de Junho/Julho de 1999.

A história do desenvolvimento (desde o porte do ipfw do BSD para o Linux até o 
iptables (que é a quarta geração de firewalls do kernel) está disponível no
documento, Netfilter-howto.

Características do firewall iptables

  • Especificação de portas/endereço de origem/destino

  • Suporte a protocolos TCP/UDP/ICMP (incluindo tipos de mensagens icmp)

  • Suporte a interfaces de origem/destino de pacotes

  • Manipula serviços de proxy na rede

  • Tratamento de tráfego dividido em chains (para melhor controle do tráfego
    que entra/sai da máquina e tráfego redirecionado.

  • Permite um número ilimitado de regras por chain

  • Muito rápido, estável e seguro

  • Possui mecanismos internos para rejeitar automaticamente pacotes duvidosos
    ou mal formados.

  • Suporte a módulos externos para expansão das funcionalidades padrões
    oferecidas pelo código de firewall

  • Suporte completo a roteamento de pacotes, tratadas em uma área diferente de
    tráfegos padrões.

  • Suporte a especificação de tipo de serviço para priorizar o tráfego de
    determinados tipos de pacotes.

  • Permite especificar exceções para as regras ou parte das regras

  • Suporte a detecção de fragmentos

  • Permite enviar alertas personalizados ao syslog sobre o tráfego aceito/
    bloqueado.

  • Redirecionamento de portas

  • Masquerading

  • Suporte a SNAT (modificação do endereço de origem das máquinas para um
    único IP ou faixa de IP's).

  • Suporte a DNAT (modificação do endereço de destino das máquinas para um
    único IP ou fixa de IP's)

  • Contagem de pacotes que atravessaram uma interface/regra

  • Limitação de passagem de pacotes/conferência de regra (muito útil para
    criar proteções contra, syn flood, ping flood, DoS, etc).

Ficha técnica

Pacote:

  • iptables - Sistema de controle principal para protocolos ipv4

  • ip6tables - Sistema de controle principal para protocolos ipv6

  • iptables-save - Salva as regras atuais em um arquivo especificado como
    argumento. Este utilitário pode ser dispensado por um shell script contendo
    as regras executado na inicialização da máquina.

  • iptables-restore - Restaura regras salvas pelo utilitário iptables-save.

Requerimentos

É necessário que o seu kernel tenha sido compilado com suporte ao iptables
(veja “Habilitando o suporte ao iptables no kernel”. O requerimento mínimo de
memória necessária para a execução do iptables é o mesmo do kernel 2.4 (4MB).
Dependendo do tráfego que será manipulado pela(s) interface(s) do firewall ele
poderá ser executado com folga em uma máquina 386 SX com 4MB de RAM.

Como as configurações residem no kernel não é necessário espaço extra em disco
rígido para a execução deste utilitário.

Arquivos de logs criados pelo iptables

Todo tráfego que for registrado pelo iptables é registrado por padrão no
arquivo /var/log/kern.log.

Instalação

apt-get install iptables

O pacote contém o utilitário iptables (e ip6tables para redes ipv6) necessários
para inserir suas regras no kernel. Se você não sabe o que é ipv6, não
precisará se preocupar com o utilitário ip6tables por enquanto.

Enviando Correções/Contribuindo com o projeto

A página principal do projeto é http://netfilter.filewatcher.org. Sugestões
podem ser enviadas para a lista de desenvolvimento oficial do iptables: http://
lists.samba.org.

O que aconteceu com o ipchains e ipfwadm?

O iptables faz parte da nova geração de firewalls que acompanha o kernel 2.4,
mas o suporte ao ipchains e ipfwadm ainda será mantido através de módulos de
compatibilidade do kernel até 2004. Seria uma grande falta de consideração
retirar o suporte a estes firewalls do kernel como forma de obrigar a
"aprenderem" o iptables (mesmo o suporte sendo removido após este período,
acredito que criarão patches "externos" para futuros kernels que não trarão
mais este suporte). Se precisa do suporte a estes firewalls antes de passar em
definitivo para o iptables leia “Habilitando o suporte ao iptables no kernel”.

Se você é um administrador que gosta de explorar todos os recursos de um
firewall, usa todos os recursos que ele oferece ou mantém uma complexa rede
corporativa, tenho certeza que gostará do iptables.

Tipos de firewalls

Existem basicamente dois tipos de firewalls:

  • nível de aplicação - Este tipo de firewall analisam o conteúdo do pacote
    para tomar suas decisões de filtragem. Firewalls deste tipo são mais
    intrusivos (pois analisam o conteúdo de tudo que passa por ele) e permitem
    um controle relacionado com o conteúdo do tráfego. Alguns firewalls em
    nível de aplicação combinam recursos básicos existentes em firewalls em
    nível de pacotes combinando as funcionalidade de controle de tráfego/
    controle de acesso em uma só ferramenta. Servidores proxy, como o squid,
    são um exemplo deste tipo de firewall.

  • nível de pacotes - Este tipo de firewall toma as decisões baseadas nos
    parâmetros do pacote, como porta/endereço de origem/destino, estado da
    conexão, e outros parâmetros do pacote. O firewall então pode negar o
    pacote (DROP) ou deixar o pacote passar (ACCEPT). O iptables é um excelente
    firewall que se encaixa nesta categoria.

    Firewall em nível de pacotes é o assunto explicado nesta seção do guia mas
    será apresentada uma explicação breve sobre o funcionamento de análise de
    strings do iptables.

Os dois tipos de firewalls podem ser usados em conjunto para fornecer uma
camada dupla de segurança no acesso as suas máquinas/máquinas clientes.

O que proteger?

Antes de iniciar a construção do firewall é bom pensar nos seguintes pontos:

  • Quais serviços precisa proteger. Serviços que devem ter acesso garantido a
    usuários externos e quais serão bloqueados a todas/determinadas máquinas. É
    recomendável bloquear o acesso a todas portas menores que 1024 por
    executarem serviços que rodam com privilégio de usuário root, e autorizar
    somente o acesso as portas que realmente deseja (configuração restritiva
    nesta faixa de portas).

  • Que tipo de conexões eu posso deixar passar e quais bloquear. Serviços com
    autenticação em texto plano e potencialmente inseguros como rlogin, telnet,
    ftp, NFS, DNS, LDAP, SMTP RCP, X-Window são serviços que devem ser ter
    acesso garantido somente para máquinas/redes que você confia. Estes
    serviços podem não ser só usados para tentativa de acesso ao seu sistema,
    mas também como forma de atacar outras pessoas aproveitando-se de problemas
    de configuração.

    A configuração do firewall ajuda a prevenir isso, mesmo se um serviço
    estiver mal configurado e tentando enviar seus pacotes para fora, será
    impedido. Da mesma forma se uma máquina Windows de sua rede for infectada
    por um trojan não haverá pânico: o firewall poderá estar configurado para
    bloquear qualquer tentativa de conexão vinda da internet (cracker) para as
    máquinas de sua rede.

    Para cópia de arquivos via rede insegura (como através da Internet), é
    recomendado o uso de serviços que utilizam criptografia para login e
    transferência de arquivos (veja ???) ou a configuração de uma VPN.

  • Que máquinas terão acesso livre e quais serão restritas.

  • Que serviços deverão ter prioridade no processamento.

  • Que máquinas/redes NUNCA deverão ter acesso a certas/todas máquinas.

  • O volume de tráfego que o servidor manipulará. Através disso você pode ter
    que balancear o tráfego entre outras máquinas, configurar proteções contra
    DoS, syn flood, etc.

  • O que tem permissão de passar de uma rede para outra (em máquinas que atuam
    como roteadores/gateways de uma rede interna).

  • Etc.

A análise destes pontos pode determinar a complexidade do firewall, custos de
implementação, prazo de desenvolvimento e tempo de maturidade do código para
implementação. Existem muitos outros pontos que podem entrar na questão de
desenvolvimento de um sistema de firewall, eles dependem do tipo de firewall
que está desenvolvendo e das políticas de segurança de sua rede.

O que são regras?

As regras são como comandos passados ao iptables para que ele realize uma
determinada ação (como bloquear ou deixar passar um pacote) de acordo com o
endereço/porta de origem/destino, interface de origem/destino, etc. As regras
são armazenadas dentro dos chains e processadas na ordem que são inseridas.

As regras são armazenadas no kernel, o que significa que quando o computador
for reiniciado tudo o que fez será perdido. Por este motivo elas deverão ser
gravadas em um arquivo para serem carregadas a cada inicialização.

Um exemplo de regra: iptables -A INPUT -s 123.123.123.1 -j DROP.

O que são chains?

Os Chains são locais onde as regras do firewall definidas pelo usuário são
armazenadas para operação do firewall. Existem dois tipos de chains: os
embutidos (como os chains INPUT, OUTPUT e FORWARD) e os criados pelo usuário.
Os nomes dos chains embutidos devem ser especificados sempre em maiúsculas
(note que os nomes dos chains são case-sensitive, ou seja, o chain input é
completamente diferente de INPUT).

O que são tabelas?

Tabelas são os locais usados para armazenar os chains e conjunto de regras com
uma determinada característica em comum. As tabelas podem ser referenciadas com
a opção -t tabela e existem 3 tabelas disponíveis no iptables:

  • filter - Esta é a tabela padrão, contém 3 chains padrões:

      □ INPUT - Consultado para dados que chegam a máquina

      □ OUTPUT - Consultado para dados que saem da máquina

      □ FORWARD - Consultado para dados que são redirecionados para outra
        interface de rede ou outra máquina.

    Os chains INPUT e OUTPUT somente são atravessados por conexões indo/se
    originando de localhost.

    OBS: Para conexões locais, somente os chains INPUT e OUTPUT são consultados
    na tabela filter.

  • nat - Usada para dados que gera outra conexão (masquerading, source nat,
    destination nat, port forwarding, proxy transparente são alguns exemplos).
    Possui 3 chains padrões:

      □ PREROUTING - Consultado quando os pacotes precisam ser modificados logo
        que chegam. É o chain ideal para realização de DNAT e redirecionamento
        de portas (“Fazendo DNAT”).

      □ OUTPUT - Consultado quando os pacotes gerados localmente precisam ser
        modificados antes de serem roteados. Este chain somente é consultado
        para conexões que se originam de IPs de interfaces locais.

      □ POSTROUTING - Consultado quando os pacotes precisam ser modificados
        após o tratamento de roteamento. É o chain ideal para realização de
        SNAT e IP Masquerading (“Fazendo SNAT”).

  • mangle - Utilizada para alterações especiais de pacotes (como modificar o
    tipo de serviço (TOS) ou outros detalhes que serão explicados no decorrer
    do capítulo. Possui 2 chains padrões:

      □ INPUT - Consultado quando os pacotes precisam ser modificados antes de
        serem enviados para o chain INPUT da tabela filter.

      □ FORWARD - Consultado quando os pacotes precisam ser modificados antes
        de serem enviados para o chain FORWARD da tabela filter.

      □ PREROUTING - Consultado quando os pacotes precisam ser modificados
        antes de ser enviados para o chain PREROUTING da tabela nat.

      □ POSTROUTING - Consultado quando os pacotes precisam ser modificados
        antes de serem enviados para o chain POSTROUTING da tabela nat.

      □ OUTPUT - Consultado quando os pacotes precisam ser modificados antes de
        serem enviados para o chain OUTPUT da tabela nat.

    Veja “A tabela mangle” para mais detalhes sobre a tabela mangle.

Habilitando o suporte ao iptables no kernel

Para usar toda a funcionalidade do firewall iptables, permitindo fazer o
controle do que tem ou não permissão de acessar sua máquina, fazer Masquerading
/NAT em sua rede, etc., você precisará dos seguintes componentes compilados em
seu kernel (os módulos experimentais fora ignorados intencionalmente):

*
* Network Options:
*

Network packet filtering (replaces ipchains) [Y/m/n/?]
 Network packet filtering debugging [Y/m/n/?]

e na Subseção:

*
*   IP: Netfilter Configuration
*
Connection tracking (required for masq/NAT) (CONFIG_IP_NF_CONNTRACK) [M/n/y/?]
  FTP protocol support (CONFIG_IP_NF_FTP) [M/n/?]
  IRC protocol support (CONFIG_IP_NF_IRC) [M/n/?]
IP tables support (required for filtering/masq/NAT) (CONFIG_IP_NF_IPTABLES) [Y/m/n/?]
  limit match support (CONFIG_IP_NF_MATCH_LIMIT) [Y/m/n/?]
  MAC address match support (CONFIG_IP_NF_MATCH_MAC) [M/n/y/?]
  netfilter MARK match support (CONFIG_IP_NF_MATCH_MARK) [M/n/y/?]
  Multiple port match support (CONFIG_IP_NF_MATCH_MULTIPORT) [M/n/y/?]
  TOS match support (CONFIG_IP_NF_MATCH_TOS) [M/n/y/?]
  LENGTH match support (CONFIG_IP_NF_MATCH_LENGTH) [M/n/y/?]
  TTL match support (CONFIG_IP_NF_TTL) [M/n/y/?]
  tcpmss match support (CONFIG_IP_NF_MATCH_TCPMSS) [M/n/y/?]
  Connection state match support (CONFIG_IP_NF_MATCH_STATE) [M/n/?]
  Packet filtering (CONFIG_IP_NF_FILTER) [M/n/y/?]
    REJECT target support (CONFIG_IP_NF_TARGET_REJECT) [M/n/?]
  Full NAT (CONFIG_IP_NF_NAT) [M/n/?]
    MASQUERADE target support (CONFIG_IP_NF_TARGET_MASQUERADE) [M/n/?]
    REDIRECT target support (CONFIG_IP_NF_TARGET_REDIRECT) [M/n/?]
  Packet mangling (CONFIG_IP_NF_MANGLE) [M/n/y/?]
    TOS target support (CONFIG_IP_NF_TARGET_TOS) [M/n/?]
    MARK target support (CONFIG_IP_NF_TARGET_MARK) [M/n/?]
  LOG target support (CONFIG_IP_NF_TARGET_LOG) [M/n/y/?]
  TCPMSS target support (CONFIG_IP_NF_TARGET_TCPMSS) [M/n/y/?]

Esta configuração permite que você não tenha problemas para iniciar o uso e
configuração do seu firewall iptables, ela ativa os módulos necessários para
utilização de todos os recursos do firewall iptables. Quando conhecer a função
de cada um dos parâmetros acima (durante o decorrer do texto), você poderá
eliminar muitas das opções desnecessárias para seu estilo de firewall ou
continuar fazendo uso de todas ;-)

OBS1: A configuração acima leva em consideração que você NÃO executará os
códigos antigos de firewall ipfwadm e ipchains. Caso deseje utilizar o ipchains
ou o ipfwadm, será preciso responder com "M" a questão "IP tables support
(required for filtering/masq/NAT) (CONFIG_IP_NF_IPTABLES)". Será necessário
carregar manualmente o módulo correspondente ao firewall que deseja utilizar
(modprobe iptables_filter.o no caso do iptables).

Não execute mais de um tipo de firewall ao mesmo tempo!!!

OBS2: É recomendável ativar o daemon kmod para carga automática de módulos,
caso contrário será necessário compilar todas as partes necessárias embutidas
no kernel, carregar os módulos necessários manualmente ou pelo iptables
(através da opção --modprobe=módulo).

Ligando sua rede interna a Internet

Se a sua intenção (como da maioria dos usuários) é conectar sua rede interna a
Internet de forma rápida e simples, leia “Fazendo IP masquerading (para os
apressados)” ou “Fazendo SNAT”. Um exemplo prático de configuração de
Masquerading deste tipo é encontrado em “Conectando sua rede interna a
Internet”.

Após configurar o masquerading, você só precisará especificar o endereço IP da
máquina masquerading (servidor) como Gateway da rede. No Windows 9x/NT/2000
isto é feito no Painel de Controle/Rede/Propriedades de Tcp/IP. No Linux pode
ser feito com route add default gw IP_do_Servidor.

Manipulando chains

O iptables trabalha com uma tabela de regras que é analisada uma a uma até que
a última seja processada. Por padrão, se uma regra tiver qualquer erro, uma
mensagem será mostrada e ela descartada. O pacote não conferirá e a ação final
(se ele vai ser aceito ou rejeitado) dependerá das regras seguintes.

As opções passadas ao iptables usadas para manipular os chains são SEMPRE em
maiúsculas. As seguintes operações podem ser realizadas:

Adicionando regras - A

Como exemplo vamos criar uma regra que bloqueia o acesso a nosso própria
máquina (127.0.0.1 - loopback). Primeiro daremos um ping para verificar seu
funcionamento:

#ping 127.0.0.1
PING 127.0.0.1 (127.0.0.1): 56 data bytes
64 bytes from 127.0.0.1: icmp_seq=0 ttl=255 time=0.6 ms
64 bytes from 127.0.0.1: icmp_seq=1 ttl=255 time=0.5 ms

--- 127.0.0.1 ping statistics ---
2 packets transmitted, 2 packets received, 0% packet loss
round-trip min/avg/max = 0.5/0.5/0.6 ms

Ok, a máquina responde, agora vamos incluir uma regra no chain INPUT (-A INPUT)
que bloqueie (-j DROP) qualquer acesso indo ao endereço 127.0.0.1 (-d 127.0.0.1
):

iptables -t filter -A INPUT -d 127.0.0.1 -j DROP

Agora verificamos um novo ping:

#ping 127.0.0.1
PING 127.0.0.1 (127.0.0.1): 56 data bytes

--- 127.0.0.1 ping statistics ---
2 packets transmitted, 0 packets received, 100% packet loss

Desta vez a máquina 127.0.0.1 não respondeu, pois todos os pacotes com o
destino 127.0.0.1 (-d 127.0.0.1) são rejeitados (-j DROP). A opção -A é usada
para adicionar novas regras no final do chain. Além de -j DROP que serve para
rejeitar os pacotes, podemos também usar -j ACCEPT para aceitar pacotes. A
opção -j é chamada de alvo da regra ou somente alvo pois define o destino do
pacote que atravessa a regra (veja “Especificando um alvo”). Bem vindo a base
de um sistema de firewall :-)

OBS1: - O acesso a interface loopback não deve ser de forma alguma bloqueado,
pois muitos aplicativos utilizam soquetes tcp para realizarem conexões, mesmo
que você não possua uma rede interna.

OBS2: - A tabela filter será usada como padrão caso nenhuma tabela seja
especificada através da opção -t.

Listando regras - L

A seguinte sintaxe é usada para listar as regras criadas:

iptables [-t tabela] -L [chain] [opções]

Onde:

tabela

    É uma das tabelas usadas pelo iptables. Se a tabela não for especificada, a
    tabela filter será usada como padrão. Veja “O que são tabelas?” para
    detalhes.

chain

    Um dos chains disponíveis na tabela acima (veja “O que são tabelas?”) ou
    criado pelo usuário (“Criando um novo chain - N”). Caso o chain não seja
    especificado, todos os chains da tabela serão mostrados.

opções

    As seguintes opções podem ser usadas para listar o conteúdo de chains:

      □ -v - Exibe mais detalhes sobre as regras criadas nos chains.

      □ -n - Exibe endereços de máquinas/portas como números ao invés de tentar
        a resolução DNS e consulta ao /etc/services. A resolução de nomes pode
        tomar muito tempo dependendo da quantidade de regras que suas tabelas
        possuem e velocidade de sua conexão.

      □ -x - Exibe números exatos ao invés de números redondos. Também mostra a
        faixa de portas de uma regra de firewall.

      □ --line-numbers - Exibe o número da posição da regra na primeira coluna
        da listagem.

Para listar a regra criada anteriormente usamos o comando:

#iptables -t filter -L INPUT

Chain INPUT (policy ACCEPT)
target     prot opt source               destination
DROP       all  --  anywhere             localhost

O comando iptables -L INPUT -n tem o mesmo efeito, a diferença é que são
mostrados números ao invés de nomes:

#iptables -L INPUT -n

Chain INPUT (policy ACCEPT)
target     prot opt source               destination
DROP       all  --  0.0.0.0/0            127.0.0.1


#iptables -L INPUT -n --line-numbers

Chain INPUT (policy ACCEPT)
num target     prot opt source               destination
1   DROP       all  --  0.0.0.0/0            127.0.0.1

#iptables -L INPUT -n -v
Chain INPUT (policy ACCEPT 78 packets, 5820 bytes)
 pkts bytes target     prot opt in     out     source               destination
    2   194 DROP       icmp --  *      *       0.0.0.0/0            127.0.0.1

Os campos assim possuem o seguinte significado:

Chain INPUT

    Nome do chain listado

(policy ACCEPT 78 packets, 5820 bytes)

    política padrão do chain (veja “Especificando a política padrão de um chain
    - P”).

pkts

    Quantidade de pacotes que atravessaram a regra (veja “Zerando contador de
    bytes dos chains - Z”).

bytes

    Quantidade de bytes que atravessaram a regra. Pode ser referenciado com K
    (Kilobytes), M (Megabytes), G (Gigabytes).

target

    O alvo da regra, o destino do pacote. Pode ser ACCEPT, DROP ou outro chain.
    Veja “Especificando um alvo” para detalhes sobre a especificação de um
    alvo.

prot

    Protocolo especificado pela regra. Pode ser udp, tcp, icmp ou all. Veja
    “Especificando um protocolo” para detalhes.

opt

    Opções extras passadas a regra. Normalmente "!" (veja “Especificando uma
    exceção”) ou "f" (veja “Especificando fragmentos”).

in

    Interface de entrada (de onde os dados chegam). Veja “Especificando a
    interface de origem/destino”.

out

    Interface de saída (para onde os dados vão). Veja “Especificando a
    interface de origem/destino”.

source

    Endereço de origem. Veja “Especificando um endereço de origem/destino”.

destination

    Endereço de destino. Veja “Especificando um endereço de origem/destino”.

outras opções

    Estas opções normalmente aparecem quando são usadas a opção -x:

      □ dpt ou dpts - Especifica a porta ou faixa de portas de destino.

      □ reject-with icmp-port-unreachable - Significa que foi usado o alvo
        REJECT naquela regra (veja “Alvo REJECT”).

Apagando uma regra - D

Para apagar um chain, existem duas alternativas:

 1. Quando sabemos qual é o número da regra no chain (listado com a opção -L)
    podemos referenciar o número diretamente. Por exemplo, para apagar a regra
    criada acima:

    iptables -t filter -D INPUT 1

    Esta opção não é boa quando temos um firewall complexo com um grande número
    de regras por chains, neste caso a segunda opção é a mais apropriada.

 2. Usamos a mesma sintaxe para criar a regra no chain, mas trocamos -A por -D:

    iptables -t filter -D INPUT -d 127.0.0.1 -j DROP

    Então a regra correspondentes no chain INPUT será automaticamente apagada
    (confira listando o chain com a opção "-L"). Caso o chain possua várias
    regras semelhantes, somente a primeira será apagada.

    OBS: Não é possível apagar os chains defaults do iptables (INPUT, OUTPUT
    ...).

Inserindo uma regra - I

Precisamos que o tráfego vindo de 192.168.1.15 não seja rejeitado pelo nosso
firewall. Não podemos adicionar uma nova regra (-A) pois esta seria incluída no
final do chain e o tráfego seria rejeitado pela primeira regra (nunca atingindo
a segunda). A solução é inserir a nova regra antes da regra que bloqueia todo o
tráfego ao endereço 127.0.0.1 na posição 1:

iptables -t filter -I INPUT 1 -s 192.168.1.15 -d 127.0.0.1 -j ACCEPT

Após este comando, temos a regra inserida na primeira posição do chain (repare
no número 1 após INPUT) e a antiga regra número 1 passa a ser a número 2. Desta
forma a regra acima será consultada, se a máquina de origem for 192.168.1.15
então o tráfego estará garantido, caso contrário o tráfego com o destino
127.0.0.1 será bloqueado na regra seguinte.

Substituindo uma regra - R

Após criar nossa regra, percebemos que a nossa intenção era somente bloquear os
pings com o destino 127.0.0.1 (pacotes ICMP) e não havia necessidade de
bloquear todo o tráfego da máquina. Existem duas alternativas: apagar a regra e
inserir uma nova no lugar ou modificar diretamente a regra já criada sem afetar
outras regras existentes e mantendo a sua ordem no chain (isso é muito
importante). Use o seguinte comando:

iptables -R INPUT 2 -d 127.0.0.1 -p icmp -j DROP

O número 2 é o número da regra que será substituída no chain INPUT, e deve ser
especificado. O comando acima substituirá a regra 2 do chain INPUT (-R INPUT 2)
bloqueando (-j DROP) qualquer pacote icmp (-p icmp) com o destino 127.0.0.1 (-d
127.0.0.1).

Criando um novo chain - N

Em firewalls organizados com um grande número de regras, é interessante criar
chains individuais para organizar regras de um mesmo tipo ou que tenha por
objetivo analisar um tráfego de uma mesma categoria (interface, endereço de
origem, destino, protocolo, etc) pois podem consumir muitas linhas e tornar o
gerenciamento do firewall confuso (e conseqüentemente causar sérios riscos de
segurança). O tamanho máximo de um nome de chain é de 31 caracteres e podem
conter tanto letras maiúsculas quanto minúsculas.

iptables [-t tabela] [-N novochain]

Para criar o chain internet (que pode ser usado para agrupar as regras de
internet) usamos o seguinte comando:

 iptables -t filter -N internet

Para inserir regras no chain internet basta especifica-lo após a opção -A:

 iptables -t filter -A internet -s 200.200.200.200 -j DROP

E então criamos um pulo (-j) do chain INPUT para o chain internet:

iptables -t filter -A INPUT -j internet

OBS: O chain criando pelo usuário pode ter seu nome tanto em maiúsculas como
minúsculas.

Se uma máquina do endereço 200.200.200.200 tentar acessar sua máquina, o 
iptables consultará as seguintes regras:

`INPUT'                         `internet'
 ----------------------------    -----------------------------
 | Regra1: -s 192.168.1.15  |    | Regra1: -s 200.200.200.200|
 |--------------------------|    |---------------------------|
 | Regra2: -s 192.168.1.1   |    | Regra2: -d 192.168.1.1    |
 |--------------------------|    -----------------------------
 | Regra3: -j DROP          |
 ----------------------------

O pacote tem o endereço de origem
200.200.200.200, ele passa pela
primeira e segunda regras do chain
INPUT, a terceira regra direciona
para o chain internet

                                    _______________________________________
                           v       /                                      v
 /-------------------------|-\    / /-------------------------------------|-\
 | Regra1: -s 192.168.1.15 | |   /  | Regra1: -s 200.200.200.200 -j DROP  \_____\
 |-------------------------|-|  /   |---------------------------------------|   /
 | Regra2: -s 192.168.1.1  | | /    | Regra2: -d 200.200.200.202 -j DROP    |
 |-------------------------|-|/     \---------------------------------------/
 | Regra3: -j internet      /|
 |---------------------------|       No chain internet, a primeira regra confere
 | Regra4: -j DROP           |       com o endereço de origem 200.200.200.200 e
 \---------------------------/       o pacote é bloqueado.


Se uma máquina com o endereço de origem 200.200.200.201 tentar acessar a máquina,
então as regra consultadas serão as seguintes:


O pacote tem o endereço de origem
200.200.200.201, ele passa pela
primeira e segunda regras do chain
INPUT, a terceira regra direciona
para o chain internet               ______________________________________
                           v       /                                      v
 /-------------------------|-\    / /-------------------------------------|-\
 | Regra1: -s 192.168.1.15 | |   /  | Regra1: -s 200.200.200.200 -j DROP  | |
 |-------------------------|-|  /   |-------------------------------------|-|
 | Regra2: -s 192.168.1.1  | | /    | Regra2: -s 200.200.200.202 -j DROP  | |
 |-------------------------|-|/     \-------------------------------------|-/
 | Regra3: -j internet      /|                                            v
 |---------------------------|                                           /
 | Regra4: -j DROP         --+-------------------------------------------
 \------------------------/-/       O pacote passa pelas regras 1 e 2 do chain
                          |         internet, como ele não confere com nenhuma
                          v         das 2 regras ele retorna ao chain INPUT e é
 Esta regra é a número 4            analisado pela regra seguinte.
 que diz para rejeitar o
 pacote.

Renomeando um chain criado pelo usuário - E

Se por algum motivo precisar renomear um chain criado por você na tabela filter
, nat ou mangle, isto poderá ser feito usando a opção -E do iptables:

iptables -t filter -E chain-antigo novo-chain

Note que não é possível renomear os chains defaults do iptables.

Listando os nomes de todas as tabelas atuais

Use o comando cat /proc/net/ip_tables_names para fazer isto. É interessante dar
uma olhada nos arquivos dentro do diretório /proc/net, pois os arquivos
existentes podem lhe interessar para outras finalidades.

Limpando as regras de um chain - F

Para limpar todas as regras de um chain, use a seguinte sintaxe:

iptables [-t tabela] [-F chain]

Onde:

tabela

    Tabela que contém o chain que desejamos zerar.

chain

    Chain que desejamos limpar. Caso um chain não seja especificado, todos os
    chains da tabela serão limpos.

  iptables -t filter -F INPUT
  iptables -t filter -F

Apagando um chain criado pelo usuário - X

Para apagarmos um chain criado pelo usuário, usamos a seguinte sintaxe:

iptables [-t tabela] [-X chain]

Onde:

tabela

    Nome da tabela que contém o chain que desejamos excluir.

chain

    Nome do chain que desejamos apagar. Caso não seja especificado, todos os
    chains definidos pelo usuário na tabela especificada serão excluídos.

OBS: - Chains embutidos nas tabelas não podem ser apagados pelo usuário. Veja
os nomes destes chains em “O que são tabelas?”.

 iptables -t filter -X internet
 iptables -X

Zerando contador de bytes dos chains - Z

Este comando zera o campo pkts e bytes de uma regra do iptables. Estes campos
podem ser visualizados com o comando iptables -L -v. A seguinte sintaxe é
usada:

iptables [-t tabela] [-Z chain] [-L]

Onde:

tabela

    Nome da tabela que contém o chain que queremos zerar os contadores de bytes
    e pacotes.

chain

    Chain que deve ter os contadores zerados. Caso não seja especificado, todos
    os chains da tabela terão os contadores zerados. Note que as opções -Z e -L
    podem ser usadas juntas, assim o chain será listado e imediatamente zerado.
    Isto evita a passagem de pacotes durante a listagem de um chain.

 iptables -t filter -Z INPUT

Especificando a política padrão de um chain - P

A política padrão determina o que acontecerá com um pacote quando ele chegar ao
final das regras contidas em um chain. A política padrão do iptables é "ACCEPT"
mas isto pode ser alterado com o comando:

iptables [-t tabela] [-P chain] [ACCEPT/DROP]

Onde:

tabela

    Tabela que contém o chain que desejamos modificar a política padrão.

chain

    Define o chain que terá a política modificada. O chain deve ser
    especificado.

ACCEPT/DROP

    ACCEPT aceita os pacotes caso nenhuma regra do chain conferir (usado em
    regras permissivas). DROP rejeita os pacotes caso nenhuma regra do chain
    conferir (usado em regras restritivas).

A política padrão de um chain é mostrada com o comando iptables -L:

# iptables -L INPUT

Chain INPUT (policy ACCEPT)
target     prot opt source               destination
DROP       icmp --  anywhere             localhost

No exemplo acima, a política padrão de INPUT é ACCEPT (policy ACCEPT), o que
significa que qualquer pacote que não seja rejeitado pela regra do chain, será
aceito. Para alterar a política padrão deste chain usamos o comando:

 iptables -t filter -P INPUT DROP

NOTA: As políticas de acesso PERMISSIVASS (ACCEPT) normalmente são usadas em
conjunto com regras restritivas no chain correspondentes (tudo é bloqueado e o
que sobrar é liberado) e políticas RESTRITIVAS (DROP) são usadas em conjunto
com regras permissivas no chain correspondente (tudo é liberado e o que sobrar
é bloqueado pela política padrão).

Outras opções do iptables

Especificando um endereço de origem/destino

As opções -s (ou --src/--source)e -d (ou --dst/--destination) servem para
especificar endereços de origem e destino respectivamente. É permitido usar um
endereço IP completo (como 192.168.1.1), um hostname (debian), um endereço fqdn
(www.debian.org) ou um par rede/máscara (como 200.200.200.0/255.255.255.0 ou
200.200.200.0/24).

Caso um endereço/máscara não sejam especificados, é assumido 0/0 como padrão
(todos as máquinas de todas as redes). A interpretação dos endereços de origem/
destino dependem do chain que está sendo especificado (como INPUT e OUTPUT por
exemplo).

OBS: Caso seja especificado um endereço fqdn e este resolver mais de um
endereço IP, serão criadas várias regras, cada uma se aplicando a este endereço
IP específico. É recomendável sempre que possível a especificação de endereços
IP's nas regras, pois além de serem muito rápidos (pois não precisar de
resolução DNS) são mais seguros para evitar que nosso firewall seja enganado
por um ataque de IP spoofing.

# Bloqueia o tráfego vindo da rede 200.200.200.*:
 iptables -A INPUT -s 200.200.200.0/24 -j DROP

# Bloqueia conexões com o destino 10.1.2.3:
iptables -A OUTPUT -d 10.1.2.3 -j DROP

# Bloqueia o tráfego da máquina www.dominio.teste.org a rede 210.21.1.3
# nossa máquina possui o endereço 210.21.1.3
iptables -A INPUT -s www.dominio.teste.org -d 210.21.1.3 -j DROP

Especificando a interface de origem/destino

As opções -i (ou --in-interface) e -o (ou --out-interface) especificam as
interfaces de origem/destino de pacotes. Nem todos as chains aceitam as
interfaces de origem/destino simultaneamente, a interface de entrada (-i) nunca
poderá ser especificada em um chain OUTPUT e a interface de saída (-o) nunca
poderá ser especificada em um chain INPUT. Abaixo uma rápida referência:


          +---------------------+--------------------------------+
  TABELA  |      CHAIN          |            INTERFACE           |
          |                     +----------------+---------------+
          |                     |  ENTRADA (-i)  |    SAÍDA (-o) |
+---------+---------------------+----------------+---------------+
|         |  INPUT              |      SIM       |      NÃO      |
| filter  |  OUTPUT             |      NÃO       |      SIM      |
|         |  FORWARD            |      SIM       |      SIM      |
+---------+---------------------+----------------+---------------+
|         | PREROUTING          |      SIM       |      NÃO      |
| nat     | OUTPUT              |      NÃO       |      SIM      |
|         | POSTROUTING         |      NÃO       |      SIM      |
+---------+---------------------+----------------+---------------+
|         | PREROUTING          |      SIM       |      NÃO      |
| mangle  |                     |                |               |
|         | OUTPUT              |      NÃO       |      SIM      |
+---------+---------------------+----------------+---------------+

O caminho do pacote na interface será determinado pelo tipo da interface e pela
posição dos chains nas etapas de seu roteamento. O chain OUTPUT da tabela
filter somente poderá conter a interface de saída (veja a tabela acima). O
chain FORWARD da tabela filter é o único que aceita a especificação de ambas as
interfaces, este é um ótimo chain para controlar o tráfego que passa entre
interfaces do firewall.

Por exemplo para bloquear o acesso do tráfego de qualquer máquina com o
endereço 200.123.123.10 vinda da interface ppp0 (uma placa de fax-modem):

iptables -A INPUT -s 200.123.123.10 -i ppp0 -j DROP

A mesma regra pode ser especificada como

iptables -A INPUT -s 200.123.123.10 -i ppp+ -j DROP

O sinal de "+" funciona como um coringa, assim a regra terá efeito em qualquer
interface de ppp0 a ppp9. As interfaces ativas no momento podem ser listadas
com o comando ifconfig, mas é permitido especificar uma regra que faz
referência a uma interface que ainda não existe, isto é interessante para
conexões intermitentes como o PPP. Para bloquear qualquer tráfego local para a
Internet:

iptables -A OUTPUT -o ppp+ -j DROP

Para bloquear a passagem de tráfego da interface ppp0 para a interface eth1 (de
uma de nossas redes internas):

iptables -A FORWARD -i ppp0 -o eth1 -j DROP

Especificando um protocolo

A opção -p (ou --protocol) é usada para especificar protocolos no iptables.
Podem ser especificados os protocolos tcp, udp e icmp. Por exemplo, para
rejeitar todos os pacotes UDP vindos de 200.200.200.200:

 iptables -A INPUT -s 200.200.200.200 -p udp -j DROP

OBS1: Tanto faz especificar os nomes de protocolos em maiúsculas ou minúsculas.

Especificando portas de origem/destino

As portas de origem/destino devem ser especificadas após o protocolo e podem
ser precedidas por uma das seguintes opções:

  • --source-port ou --sport - Especifica uma porta ou faixa de portas de
    origem.

  • --destination-port ou --dport - Especifica uma porta ou faixa de portas de
    destino.

Uma faixa de portas pode ser especificada através de PortaOrigem:PortaDestino:

# Bloqueia qualquer pacote indo para 200.200.200.200 na faixa de
# portas 0 a 1023
iptables -A OUTPUT -d 200.200.200.200 -p tcp --dport :1023 -j DROP

Caso a PortaOrigem de uma faixa de portas não seja especificada, 0 é assumida
como padrão, caso a Porta Destino não seja especificada, 65535 é assumida como
padrão. Caso precise especificar diversas regras que envolvam o tratamento de
portas diferentes, recomendo da uma olhada em “Especificando múltiplas portas
de origem/destino”, antes de criar um grande número de regras.

Especificando mensagens do protocolo ICMP

O protocolo ICMP não possui portas, mas é possível fazer um controle maior
sobre o tráfego ICMP que entra/sai da rede através da especificação dos tipos
de mensagens ICMP. Os tipos de mensagens devem ser especificados com a opção
"--icmp-type CódigoICMP" logo após a especificação do protocolo icmp:

iptables -A INPUT -s 200.123.123.10 -p icmp --icmp-type time-exceeded -i ppp+ -j DROP

A regra acima rejeitará mensagens ICMP do tipo "time-exceeded" (tempo de
requisição excedido) que venham do endereço 200.123.123.10 através da interface
ppp+.

Alguns tipos de mensagens ICMP são classificados por categoria (como o próprio
"time-exceeded"), caso a categoria "time-exceeded" seja especificada, todas as
mensagens daquela categoria (como "ttl-zero-during-transit",
"ttl-zero-during-reassembly") conferirão na regra especificada.Os tipos de
mensagens ICMP podem ser obtidos com o comando iptables -p icmp -h:

echo-reply (pong)
destination-unreachable
   network-unreachable
   host-unreachable
   protocol-unreachable
   port-unreachable
   fragmentation-needed
   source-route-failed
   network-unknown
   host-unknown
   network-prohibited
   host-prohibited
   TOS-network-unreachable
   TOS-host-unreachable
   communication-prohibited
   host-precedence-violation
   precedence-cutoff
source-quench
redirect
   network-redirect
   host-redirect
   TOS-network-redirect
   TOS-host-redirect
echo-request (ping)
router-advertisement
router-solicitation
time-exceeded (ttl-exceeded)
   ttl-zero-during-transit
   ttl-zero-during-reassembly
parameter-problem
   ip-header-bad
   required-option-missing
timestamp-request
timestamp-reply
address-mask-request
address-mask-reply

OBS1: Não bloqueie mensagens do tipo "host-unreachable" e "source-quench", pois
terá sérios problemas no controle de suas conexões. A primeira diz que o
destino está inalcançavel e a segunda que o host está sobrecarregado, assim os
pacotes devem ser enviados mais lentamente.

Especificando pacotes syn

Pacotes syn são usados para iniciarem uma conexão, o uso da opção --syn serve
para especificar estes tipos de pacotes. Desta maneira é possível bloquear
somente os pacotes que iniciam uma conexão, sem afetar os pacotes restantes.
Para que uma conexão ocorra é necessário que a máquina obtenha a resposta a
pacotes syn enviados, caso ele seja bloqueado a resposta nunca será retornada e
a conexão não será estabelecida.

iptables -A INPUT -p tcp --syn --dport 23 -i ppp+ -j DROP

A regra acima bloqueia (-j DROP) qualquer tentativa de conexão (--syn) vindas
da interface ppp+ ao telnet (--dport 23) da máquina local, conexões já
efetuadas ão são afetadas por esta regra. A opção --syn somente pode ser
especificada para o protocolo tcp.

ATENÇÃO: - A situação de passagem de pacotes durante deve ser levada em conta
durante a inicialização do firewall, bloqueando a passagem de pacotes durante o
processo de configuração, criando regras que bloqueiam a passagem de pacotes
(exceto para a interface loopback) até que a configuração do firewall esteja
completa, pode ser uma solução eficiente.

Outra alternativa segura é configurar as regras de firewall antes das
interfaces de rede se tornarem ativas (usando a opção "pre-up comando_firewall"
no arquivo de configuração /etc/network/interfaces em sistemas Debian.

Especificando fragmentos

A opção "-f" (ou --fragment) permite especificar regras que confiram com
fragmentos. Fragmentos são simplesmente um pacote maior dividido em pedaços
para poder ser transmitido via rede TCP/IP para remontagem do pacote pela
máquina de destino.

Somente o primeiro fragmento possui detalhes de cabeçalho para ser processado,
os segundos e seguintes somente possuem alguns cabeçalhos necessários para dar
continuidade ao processo de remontagem do pacote no destino.

Uma regra como

iptables -A INPUT -s 200.200.200.1 -f -j DROP

derrubará os fragmentos de 200.200.200.1 derrubará o segundo pacote e pacotes
seguintes enviados por 200.200.200.1 até nós.

OBS1: Note que se o cabeçalho do pacote não tiver detalhes suficientes para
checagem de regras no iptables, a regra simplesmente não ira conferir.

OBS2: Não é preciso especificar a opção "-f" para conexões NAT, pois os pacotes
são remontados antes de entrarem no código de filtragem.

OBS3: A opção "-f" também pode ser usada para evitar o flood por fragmentos
(bomba de fragmentos) que, dependendo da intensidade, podem até travar a
máquina.

Especificando uma exceção

Muitos parâmetros (como o endereço de origem/destino, protocolo, porta,
mensagens ICMP, fragmentos, etc) podem ser precedidos pelo sinal "!" que
significa exceção. Por exemplo:

iptables -t filter -A INPUT ! -s 200.200.200.10 -j DROP

Diz para rejeitar todos os pacotes EXCETO os que vem do endereço
200.200.200.10.

iptables -A INPUT -p tcp ! --syn -s 200.200.200.10 ! -i eth0 -j DROP

Diz para bloquear todos os pacotes EXCETO os que iniciam conexões (! --syn),
EXCETO para pacotes vindos pela interface eth0 (! -i eth0).

iptables -A INPUT -s 200.200.200.10 ! -p tcp -j DROP

Bloqueia todos os pacotes vindos de 200.200.200.10, EXCETO os do protocolo tcp.

Especificando um alvo

O alvo (-j) é o destino que um pacote terá quando conferir com as condições de
uma regra, um alvo pode dizer para bloquear a passagem do pacote (-j DROP),
aceitar a passagem do pacote (-j ACCEPT), registrar o pacote no sistema de log
(-j LOG), rejeitar o pacote (-j REJECT), redirecionar um pacote -j REDIRECT,
retornar ao chain anterior sem completar o processamento no chain atual (-j
RETURN), passar para processamento de programas externos (-j QUEUE), fazer
source nat (-j SNAT), destination nat (-j DNAT), etc. Podem existir mais alvos,
pois o iptables é modularizável, e módulos que acrescentam mais funções podem
ser carregados em adição aos já existentes no kernel.

Nos exemplos anteriores vimos o uso de diversos alvos como o DROP e o ACCEPT.
Apenas farei uma breve referência sobre os alvos mais usados em operações
comuns dos chains. Os alvos REDIRECT, SNAT e DNAT serão explicados em uma seção
seguinte:

ACCEPT

    O pacote é ACEITO e o processamento das regras daquele chains é concluído.
    Pode ser usado como alvo em todos os chains de todas as tabelas do iptables
    e também pode ser especificado na política padrão das regras do firewall
    (veja “Especificando a política padrão de um chain - P”).

DROP

    Rejeita o pacote e o processamento das regras daquele chain é concluído.
    Pode ser usado como alvo em todos os chains de todas as tabelas do iptables
    e também pode ser especificado na política padrão das regras do firewall
    (veja “Especificando a política padrão de um chain - P”).

REJECT

    Este é um módulo opcional que faz a mesma função do alvo DROP com a
    diferença de que uma mensagem ICMP do tipo "icmp-port-unreachable" (TCP/
    UDP) ou "host-unreachable" (ICMP) é retornada para a máquina de origem.
    Pode ser usado como alvo somente nos chains da tabela (não como política
    padrão).

LOG

    Este módulo envia uma mensagem ao syslog caso a regra confira, o
    processamento continua normalmente para a próxima regra (o pacote não é nem
    considerado ACEITO ou REJEITADO).

RETURN

    Retorna o processamento do chain anterior sem processar o resto do chain
    atual.

QUEUE

    Passa o processamento para um programa a nível de usuário.

Alvo REJECT

Para ser usado, o módulo ipt_REJECT deve ser compilado no kernel ou como
módulo. Este alvo rejeita o pacote (como o DROP) e envia uma mensagem ICMP do
tipo "icmp-port-unreachable" como padrão para a máquina de origem.

É um alvo interessante para bloqueio de portas TCP, pois em alguns casos da a
impressão que a máquina não dispõe de um sistema de firewall (o alvo DROP causa
uma parada de muito tempo em alguns portscanners e tentativas de conexão de
serviços, revelando imediatamente o uso de um sistema de firewall pela
máquina). O alvo REJECT vem dos tempos do ipchains e somente pode ser usado na
tabela filter. Quando um pacote confere, ele é rejeitado com a mensagem ICMP do
tipo "port unreachable", é possível especificar outro tipo de mensagem ICMP com
a opção --reject-with tipo_icmp.

OBS: REJECT pode ser usado somente como alvo na tabela filter e não é possível
especifica-lo como política padrão do chain filter (como acontecia no ipchains.
Uma forma alternativa é inserir como última regra uma que pegue todos os
pacotes restantes daquele chain e tenha como alvo REJECT (como iptables -A
INPUT -j REJECT), desta forma ele nunca atingirá a política padrão do chain.

# Rejeita pacotes vindos de 200.200.200.1 pela interface ppp0:
iptables -A INPUT -s 200.200.200.1 -i ppp+ -j REJECT

Especificando LOG como alvo

Este alvo é usado para registrar a passagem de pacotes no syslog do sistema. É
um alvo muito interessante para ser usado para regras que bloqueiam
determinados tráfegos no sistema (para que o administrador tome conhecimento
sobre tais tentativas), para regras de fim de chain (quando você tem um grande
conjunto de regras em um firewall restritivo e não sabe onde suas regras estão
sendo bloqueadas), para satisfazer sua curiosidade, etc.

# Para registrar o bloqueio de pacotes vindos de 200.200.200.1 pela interface ppp0
iptables -A INPUT -s 200.200.200.1 -i ppp+ -j LOG
# Para efetuar o bloqueio
iptables -A INPUT -s 200.200.200.1 -i ppp+ -j REJECT

Note que no exemplo anterior a regra que registra o pacote (-j LOG) deve
aparecer antes da regra que REJEITA (-j REJECT), caso contrário a regra de LOG
nunca funcionará. A regra que REJEITA poderia também ser trocada por uma regra
que ACEITA, caso queira registrar um pacote que deve ser aceito (se a política
padrão do seu firewall for restritiva (-P DROP). A única coisa que muda nas
regras de log é o alvo da regra, isto facilita a implementação de grandes
conjuntos de regras de firewall.

A regra acima mostrará a seguinte saída no syslog do sistema:

Aug 25 10:08:01 debian kernel: IN=ppp0 OUT= MAC=10:20:30:40:50:60:70:80:90:00:00:00:08:00 SRC=200.200.200.1 DST=200.210.10.10 LEN=61 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=UDP SPT=1031 DPT=53 LEN=41

Os campos possuem o seguinte significado:

Aug 25 10:08:01

    Mês, dia e hora do registro do pacote.

debian

    Nome do computador que registrou o pacote.

kernel:

    Daemon que registrou a mensagem, no caso o iptables faz parte do próprio
    kernel.

IN=ppp0

    Especifica a interface de entrada (de onde o pacote veio).

OUT=

    Especifica a interface de saída (para onde o pacote foi).

MAC=10:20:30:40:50:60:70:80:90:00:00:00:08:00

    Endereço mac da interface de rede (pode ser obtido com arp interface).

SRC=200.200.200.1

    Endereço de origem do pacote.

DST=200.210.10.10

    Endereço de destino do pacote.

SEQ=234234343

    Número de seqüência da recepção. É ativado com a opção --log-tcp-sequence.

LEN=61

    Tamanho em bytes do pacote IP.

TOS=0x00

    Prioridade do cabeçalho TOS (Tipo). Veja a seção “Especificando o tipo de
    serviço” para mais detalhes.

PREC=0x00

    Prioridade do cabeçalho TOS (Precedência). Veja a seção “Especificando o
    tipo de serviço” para mais detalhes.

TTL=64

    Tempo de vida do pacote. No exemplo, 64 roteadores (hops).

ID=0

    Identificação única destes datagrama. Esta identificação também é usada
    pelos fragmentos seguintes deste pacote.

DF

    Opção "Don't fragment" (não fragmentar) do pacote. Usada quando o pacote é
    pequeno o bastante para não precisar ser fragmentado.

MF

    Opção "More Fragments" (mais fragmentos) estão para ser recebidos.

FRAG=100

    Tamanho do fragmento especificado em pacotes de 8 bits. No exemplo acima, o
    pacote tem o tamanho de 800 bytes (100*8).

PROTO=UDP

    Nome do protocolo. Pode ser TCP, UDP ou ICMP

SPT=1031

    Porta de origem da requisição.

DPT=53

    Porta de destino da requisição.

LEN=41

    Tamanho do pacote.

O log acima mostra uma consulta DNS (porta destino 53) para nossa máquina
(INPUT) de 200.200.200.1 para 200.210.10.10.

O problema é que em um grande número de regras será difícil saber qual regra
conferiu (pois teríamos que analisar o endereço/porta origem/destino) e o
destino do pacote (se ele foi ACEITO ou BLOQUEADO) pois você pode ter regras
para ambas as situações. Por este motivo existem algumas opções úteis que
podemos usar com o alvo LOG:

--log-prefix "descrição"

    Permite especificar uma descrição para a regra do firewall de até 29
    caracteres. Caso tiver espaços, devem ser usadas "aspas".

--log-level nível

    Especifica o nível da mensagem no syslog. Veja os níveis na seção “Arquivo
    de configuração rsyslog.conf” do guia.

--log-tcp-options

    Registra campos do cabeçalho TCP nos logs do sistema.

--log-ip-options

    Registra campos do cabeçalho IP nos logs do sistema

--log-tcp-sequence

    Registra os números de seqüencia TCP. Evite ao máximo o uso desta opção,
    pois a seqüencia de números TCP pode ser a chave para um seqüestro de seção
    ou IP spoofing em seu sistema caso algum usuário tenha acesso a estes logs.
    Caso utilize tcp/ip em servidores públicos, o uso desta opção ajudará a
    entender bem os ataques DoS causados por syn-flood e porque ativar os
    SynCookies (veja “Proteção contra syn flood”).

OBS1:Lembre-se que estas opções são referentes ao alvo LOG e devem ser usadas
após este, caso contrário você terá um pouco de trabalho para analisar e
consertar erros em suas regras do firewall.

OBS2:Caso esteja usando o firewall em um servidor público, recomendo associar
um limite a regra de log, pois um ataque poderia causar um DoS enchendo sua
partição. Leia mais sobre isso em “Limitando o número de vezes que a regra
confere”.

# Complementando o exemplo anterior:
# Para registrar o bloqueio de pacotes vindos de 200.200.200.1 pela interface ppp0
iptables -A INPUT -s 200.200.200.1 -i ppp+ -j LOG --log-prefix "FIREWALL: Derrubado "
# Para efetuar o bloqueio
iptables -A INPUT -s 200.200.200.1 -i ppp+ -j REJECT

Retornará a seguinte mensagem no syslog:

Aug 25 10:08:01 debian kernel: FIREWALL: Derrubado IN=ppp0 OUT= MAC=10:20:30:40:50:60:70:80:90:00:00:00:08:00 SRC=200.200.200.1 DST=200.210.10.10 LEN=61 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=UDP SPT=1031 DPT=53 LEN=41

Agora você sabe o que aconteceu com o pacote (Rejeitado). A padronização de
mensagens de firewall é também importante para a criação de scripts de análise
que poderão fazer a análise dos logs do seu firewall (para criação de
estatísticas que podem servir como base para a criação de novas regras de
firewall ou eliminação de outras).

OBS: Se você sente falta da função "-l" do ipchains que combina o alvo e log na
mesma regra você pode criar um alvo como o seguinte:

iptables -N log-drop
iptables -A log-drop -j LOG
iptables -A log-drop -j DROP

E usar "log-drop" como alvo em suas regras. Mesmo assim esta solução é
"limitada" em relação a "-l" do ipchains porque o iptables não inclui detalhes
de qual chain bloqueou o pacote/qual pacote foi bloqueado, assim é necessário a
especificação da opção --log-prefix para as mensagens se tornarem mais
compreensíveis. Esta limitação pode ser contornada utilizando um firewall feito
em linguagem shell script, desta forma você terá um controle maior sobre o seu
programa usando funções e integração com outros utilitários.

Especificando RETURN como alvo

O alvo RETURN diz ao iptables interromper o processamento no chain atual e
retornar o processamento ao chain anterior. Ele é útil quando criamos um chain
que faz um determinado tratamento de pacotes, por exemplo bloquear conexões
vindas da internet para portas baixas, exceto para um endereço IP específico.
Como segue:

1-) iptables -t filter -A INPUT -i ppp0 -j internet
2-) iptables -t filter -j ACCEPT
3-) iptables -t filter -N internet
4-) iptables -t filter -A internet -s www.debian.org -p tcp --dport 80 -j RETURN
5-) iptables -t filter -A internet -p tcp --dport 21 -j DROP
6-) iptables -t filter -A internet -p tcp --dport 23 -j DROP
7-) iptables -t filter -A internet -p tcp --dport 25 -j DROP
8-) iptables -t filter -A internet -p tcp --dport 80 -j DROP

Quando um pacote com o endereço www.debian.org tentando acessar a porta www
(80) de nossa máquina através da internet (via interface ppp0), o chain número
1 confere, então o processamento continua no chain número 4, o chain número 4
confere então o processamento volta para a regra número 2, que diz para aceitar
o pacote.

Agora se um pacote vem com o endereço www.dominio.com.br tentando acessar a
porta www *80) de nossa máquina através da internet (via interface ppp0), o
chain número 1 confere, então o processamento continua no chain número 4, que
não confere. O mesmo acontece com os chains 5, 6 e 7. O chain número 8 confere,
então o acesso é bloqueado.

Como pode notou, o alvo RETURN facilita bastante a construção das regras do seu
firewall, caso existam máquinas/redes que sejam exceções as suas regras. Se ela
não existisse, seria necessário especificar diversas opções -s, -d, etc para
poder garantir o acesso livre a determinadas máquinas.

Salvando e Restaurando regras

As regras que você está trabalhosamente criando e testando manualmente enquanto
manipula o iptables podem ser salvas de 2 formas; uma delas é escrevendo um
shell script que tenha todos os comandos, um por linha. Isto é recomendado
quando tem um firewall grande e que exige uma boa padronização de regras, bem
como sua leitura, comentários. O script shell também permite o uso de funções
presente no interpretador de comando, portanto se você é uma pessoa que gosta
de interagir com as funções do shell e deixar as coisas mais flexíveis, prefira
esta opção.

A outra forma é usando as ferramentas iptables-save e iptables-restore baseada
na idéia do ipchains-save e ipchains-restore. O iptables-save deve ser usado
sempre que modificar regras no firewall iptables da seguinte forma:

iptables-save >/dir/iptables-regras

Uma das vantagens do uso do iptables-save é ele também salvar os contadores de
chains, ou seja, a quantidade de pacotes que conferiram com a regra. Isto
também pode ser feito com algumas regras adicionais em seu shell script, caso
tenha interesse nesses contadores para estatísticas ou outros tipos de
relatórios.

Para restaurar as regras salvas, utilize o comando:

iptables-restore </dir/iptables-regras

A tabela nat (Network Address Translation) - fazendo nat

A tabela nat serve para controlar a tradução dos endereços que atravessam o
código de roteamento da máquina Linux. Existem 3 chains na tabela nat: 
PREROUTING, OUTPUT e POSTROUTING (veja “O que são tabelas?” para maiores
detalhes).

A tradução de endereços tem inúmeras utilidades, uma delas é o Masquerading,
onde máquinas de uma rede interna podem acessar a Internet através de uma
máquina Linux, redirecionamento de porta, proxy transparente, etc. Esta seção
abordará os tipos de NAT, exemplos de como criar rapidamente uma conexão IP
masquerading e entender como a tradução de endereços funciona no iptables.

Se sua intenção é ligar sua rede a Internet existem duas opções:

  • Você possui uma conexão que lhe oferece um endereço IP dinâmico (a cada
    conexão é dado um endereço IP - como uma conexão PPP) então o IP
    masquerading é o que precisa (veja “Fazendo IP masquerading (para os
    apressados)” ou “Fazendo IP Masquerading”).

  • Você tem uma conexão que lhe oferece um endereço IP permanente (ADSL, por
    exemplo) então o SNAT é o que precisa (veja “Fazendo SNAT”).

Criando um novo chain na tabela NAT

O procedimento para criação de um novo chain nesta tabela é o mesmo descrito em
“Criando um novo chain - N” será necessário somente especificar a tabela nat
(-t nat) para que o novo chain não seja criado na tabela padrão (-t filter).

iptables -t nat -N intra-inter

Que criará o chain chamado intra-inter na tabela nat. Para inserir regras neste
chain será necessário especificar a opção "-t nat".

Fazendo IP masquerading (para os apressados)

Você precisará de um kernel com suporte ao iptables (veja “Habilitando o
suporte ao iptables no kernel” e ip_forward e então digitar os dois comandos
abaixo para habilitar o masquerading para todas as máquinas da rede
192.168.1.*:

iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -j MASQUERADE
echo "1" >/proc/sys/net/ipv4/ip_forward

A configuração do servidor Linux está completa, agora os clientes da rede
precisarão ser configurados para usar o endereço IP do servidor Linux como
gateway. É recomendável instalar um servidor proxy e DNS na máquina Linux para
acelerar o desempenho das requisições/resolução de nomes das máquinas em rede.
A utilização de bits TOS também pode trazer um grande aumento de velocidade
para os diferentes serviços da rede (veja “Especificando o tipo de serviço”).

Fazendo SNAT

SNAT (source nat - nat no endereço de origem) consiste em modificar o endereço
de origem das máquinas clientes antes dos pacotes serem enviados. A máquina
roteadora é inteligente o bastante para lembrar dos pacotes modificados e
reescrever os endereços assim que obter a resposta da máquina de destino,
direcionando os pacotes ao destino correto. Toda operação de SNAT é feita no
chain POSTROUTING.

É permitido especificar endereços de origem/destino, protocolos, portas de
origem/destino, interface de entrada/saída (dependendo do chain), alvos, etc. É
desnecessário especificar fragmentos na tabela nat, pois eles serão remontados
antes de entrar no código de roteamento.

O SNAT é a solução quando você tem acesso a internet através de um único IP e
deseja fazer que sua rede tenha acesso a Internet através da máquina Linux.
Nenhuma máquina da Internet poderá ter acesso direto as máquinas de sua rede
interna via SNAT.

OBS: A observação acima não leva em conta o controle de acesso externo
configurado na máquina que estiver configurando o iptables, uma configuração
mau realizada pode expor sua máquina a acessos externos indesejados e
comprometer sua rede interna caso alguém consiga acesso direto ao servidor.

É necessário especificar SNAT como alvo (-j SNAT) quando desejar que as
máquinas de sua rede interna tenha acesso a Internet através do IP fixo da
máquina Linux (para conexões intermitentes como PPP, veja “Fazendo IP
Masquerading”). O parâmetro --to IP:portas deve ser usado após o alvo SNAT. Ele
serve para especificar um endereço IP, faixa de endereços e opcionalmente uma
porta ou faixa de portas que será substituída. Toda a operação de SNAT é
realizada através do chain POSTROUTING:

# Modifica o endereço IP dos pacotes vindos da máquina 192.168.1.2 da rede interna
# que tem como destino a interface eth1 para 200.200.217.40 (que é o nosso endereço
# IP da interface ligada a Internet).
iptables -t nat -A POSTROUTING -s 192.168.1.2 -o eth1 -j SNAT --to 200.200.217.40

Os pacotes indo para a Internet (nossa conexão é feita via eth1, nossa
interface externa) vindo do endereço 192.168.1.2, são substituídos por
200.241.200.40 e enviados para fora. Quando a resposta a requisição é
retornada, a máquina com iptables recebe os pacotes e faz a operação inversa,
modificando o endereço 200.241.200.40 novamente para 192.168.1.2 e enviando a
resposta a máquina de nossa rede interna. Após definir suas regras de NAT,
execute o comando echo "1" >/proc/sys/net/ipv4/ip_forward para habilitar o
suporte a redirecionamento de pacotes no kernel.

Também é possível especificar faixas de endereços e portas que serão
substituídas:

iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o eth0 -j SNAT --to 200.200.217.40-200.200.217.50

Modifica o endereço IP de origem de todas as máquinas da rede 192.168.1.0/24
que tem o destino a interface eth0 para 200.241.200.40 a 200.241.200.50. O
endereço IP selecionado é escolhido de acordo com o último IP alocado.

iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o eth0 -j SNAT --to 200.200.217.40-200.200.217.50:1-1023

Idêntico ao anterior, mas faz somente substituições na faixa de portas de
origem de 1 a 1023.

iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o eth0 -j SNAT --to 200.200.217.40-200.200.217.50 --to 200.200.217.70-200.200.217.73

Faz o mapeamento para a faixa de portas 200.200.217.40 a 200.200.217.50 e de
200.200.217.70 a 200.200.217.73.

OBS1: Se por algum motivo não for possível mapear uma conexão NAT, ela será
derrubada.

OBS2: Tenha certeza que as respostas podem chegar até a máquina que fez o NAT.
Se estiver fazendo SNAT em um endereço livre em sua rede (como 200.200.217.73).

OBS3: Como notou acima, o SNAT é usado quando temos uma conexão externa com um
ou mais IP's fixos. O Masquerading é uma forma especial de SNAT usada para
funcionar em conexões que recebem endereços IP aleatórios (PPP).

OBS4: Não se esqueça de habilitar o redirecionamento de pacotes após fazer suas
regra de NAT com o comando: echo "1" >/proc/sys/net/ipv4/ip_forward, caso
contrário o redirecionamento de pacotes não funcionará.

Fazendo IP Masquerading

O IP Masquerading é um tipo especial de SNAT usado para conectar a sua rede
interna a internet quando você recebe um IP dinâmico de seu provedor (como em
conexões ppp). Todas as operações de IP Masquerading são realizadas no chain 
POSTROUTING. Se você tem um IP fixo, deve ler “Fazendo SNAT”.

Para fazer IP Masquerading de uma máquina com o IP 192.168.1.2 para ter acesso
a Internet, use o comando:

iptables -t nat -A POSTROUTING -s 192.168.1.2/32 -o ppp0 -j MASQUERADE

A diferença é que o alvo é -j MASQUERADE. O comando acima faz IP Masquerading
de todo o tráfego de 192.168.1.2 indo para a interface ppp0: O endereço IP dos
pacotes vindos de 192.168.1.2 são substituídos pelo IP oferecido pelo seu
provedor de acesso no momento da conexão, quando a resposta é retornada a
operação inversa é realizada para garantir que a resposta chegue ao destino.
Nenhuma máquina da internet poderá ter acesso direto a sua máquina conectava
via Masquerading.

Para fazer o IP Masquerading de todas as máquinas da rede 192.168.1.*:

iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o ppp0 -j MASQUERADE

Após definir a regra para fazer Masquerading (SNAT), execute o comando echo "1"
>/proc/sys/net/ipv4/ip_forward para habilitar o suporte a redirecionamento de
pacotes no kernel.

Fazendo DNAT

DNAT (Destination nat - nat no endereço de destino) consiste em modificar o
endereço de destino das máquinas clientes. O destination nat é muito usado para
fazer redirecionamento de pacotes, proxyes transparentes e balanceamento de
carga.

Toda operação de DNAT é feita no chain PREROUTING. As demais opções e
observações do SNAT são também válidas para DNAT (com exceção que somente é
permitido especificar a interface de origem no chain PREROUTING).

# Modifica o endereço IP destino dos pacotes de 200.200.217.40 vindo da interface eth0
# para 192.168.1.2.
iptables -t nat -A PREROUTING -s 200.200.217.40 -i eth0 -j DNAT --to 192.168.1.2

Também é possível especificar faixas de endereços e portas que serão
substituídas no DNAT:

iptables -t nat -A PREROUTING -i eth0 -s 192.168.1.0/24 -j DNAT --to 200.200.217.40-200.200.217.50

Modifica o endereço IP de destino do tráfego vindos da interface 192.168.1.0/24
para um IP de 200.241.200.40 a 200.241.200.50. Este é um excelente método para
fazer o balanceamento de carga entre servidores. O endereço IP selecionado é
escolhido de acordo com o último IP alocado.

iptables -t nat -A PREROUTING -i eth0 -s 192.168.1.0/24 -j DNAT --to 200.200.217.40-200.200.217.50:1024:5000

Idêntico ao anterior, mas faz somente substituições na faixa de portas de
destino de 1024 a 5000. A operação acima é a mesma realizada pelo ipmasqadm dos
kernels da série 2.2.

OBS1: Se por algum motivo não for possível mapear uma conexão NAT, ela será
derrubada.

OBS2: Não se esqueça de conferir se o ip_forward está ajustado para 1: echo "1"
>/proc/sys/net/ipv4/ip_forward.

Redirecionamento de portas

O redirecionamento de portas permite a você repassar conexões com destino a uma
porta para outra porta na mesma máquina. O alvo REDIRECT é usado para fazer
esta operação, junto com o argumento --to-port especificando a porta que será
redirecionada. Este é o método DNAT específico para se para fazer proxy
transparente (para redirecionamento de endereços/portas, veja “Fazendo DNAT”).
Todas as operações de redirecionamento de portas é realizada no chain 
PREROUTING e OUTPUT da tabela nat.

iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 81

Redireciona as conexões indo para a porta 80 para a porta 81 (rodando squid) no
firewall.

ATENÇÃO: O squid possui suporte a proxy transparente, e poderá atender as
requisições acima da regra acima.

Monitorando conexões feitas na tabela nat

Use o comando cat /proc/net/ip_conntrack para listar todas as conexões atuais
tratadas pelo módulo nat.

A tabela mangle

A tabela mangle serve para especificar ações especiais para o tratamento do
tráfego que atravessa os chains. Nesta tabela existem cincos chains: PREROUTING
, POSTROUTING, INPUT, OUTPUT e FORWARD (veja “O que são tabelas?” para maiores
detalhes).

Em geral, cada um deste chain é processado antes do chain correspondente na
tabela filter e nat para definir opções especiais para o tráfego (por exemplo,
o chain PREROUTING da tabela mangle é processado antes do PREROUTING da tabela 
nat). O chain OUTPUT da tablea mangle corresponde ao OUTPUT da tabela nat.
Opções como o Tipo de Serviço (TOS) é especificado nesta tabela para
classificar e aumentar consideravelmente a velocidade de tráfego considerados
em tempo real. Mesmo após o tráfego ser estabelecido, os chains da tabela
mangle continuam ativos para garantir que as opções especiais relacionadas com
a conexão continuem fazendo efeito (veja os exemplos de “Caminho percorrido
pelos pacotes nas tabelas e chains”).

Especificando o tipo de serviço

O tipo de serviço é um campo existente no cabeçalho de pacotes do protocolo
ipv4 que tem a função especificar qual é a prioridade daquele pacote. A
prioridade é definida usando o algoritmo FIFO do próprio kernel, sendo uma das
alternativas de controle/priorização de tráfego das mais simples e rápidas.

Uma das vantagens da utilização do tipo de serviço é dar prioridade ao tráfego
de pacotes interativos (como os do ICQ, IRC, servidores de chat), etc. Com o
TOS especificado, mesmo que esteja fazendo um download consumindo toda a banda
de sua interface de rede, o tráfego com prioridade interativa será enviado
antes, aumentando a eficiência do uso de serviços em sua máquina.

Em testes realizados em minha conexão de 56K, o uso de regras TOS aumentou
bastante o desempenho em tráfego interativo (em torno de 300%), durante o uso
total da banda da interface ppp em grande consumo de banda.

Usamos o alvo TOS (-j TOS) para especificar a modificação do tipo de serviço
nos pacotes que atravessam as regras do firewall, acompanhada do argumento 
--set-tos TOS que define a nova prioridade dos pacotes. Os valores aceitos são
os seguintes:

Espera Mínima

    É especificado através de Minimize-Delay, 16 ou 0x10

Máximo Processamento

    É especificado através de Maximize-Throughput, 8, ou 0x08.

Máxima Confiança

    É especificado através de Maximize-Reliability, 4 ou 0x04.

Custo mínimo

    Especificado através de Minimize-Cost, 2 ou 0x02.

Prioridade Normal

    Especificado através de Normal-Service, 0 ou 0x00.

Os pacotes vem por padrão com o valor TOS ajustado como prioridade normal (bits
tos ajustados para 0x00). O tipo Mínima Espera é o de maior prioridade,
recomendado para tráfego interativo.

Especificando o TOS para tráfego de saída

Este é o mais usado, pois prioriza o tráfego que sai da máquina (com destino a
Internet, por exemplo). Sua operação é realizada através do chain OUTPUT ou 
POSTROUTING.

Para priorizar todo o tráfego de IRC de nossa rede interna indo para a
interface ppp0:

iptables -t mangle -A OUTPUT -o ppp0 -p tcp --dport 6666-6668 -j TOS --set-tos 16

O bit TOS é ajustado para Espera mínima e será enviado antes dos pacotes com
prioridade normal para fora. Para priorizar a transmissão de dados ftp saindo
da rede:

iptables -t mangle -A OUTPUT -o ppp0 -p tcp --dport 20 -j TOS --set-tos 8

Para priorizar o tráfego de ICQ da rede:

iptables -t mangle -A OUTPUT -o ppp0 -p tcp --dport 5190 -j TOS --set-tos 16

Existem muitas outras otimizações que podem ser feitas, só depende dos
requerimentos e análise de cada serviço da rede pelo administrador.

OBS: - Os pacotes que atravessam o alvo TOS somente tem os bits tipo do serviço
modificados, eles não serão de qualquer forma rejeitados.

Outros módulos do iptables

Os módulos do iptables são especificados com a opção -m módulo ou --match
módulo e permitem expandir a funcionalidade do firewall através de novas
conferências e recursos de filtragem adicionais, como limitar a conferência de
regras do firewall (um método útil de limitar ping floods, syn floods, etc).

Conferindo de acordo com o estado da conexão

Este módulo permite especificar regras de acordo com o estado da conexão do
pacote, isto é feito através da interpretação da saída do módulo ip_conntrack.
O parâmetro --state OPÇÕES deve acompanhar este módulo. As opções permitidas
são as seguintes:

  • NEW - Confere com pacotes que criam novas conexões

  • ESTABLISHED - Confere com conexões já estabelecidas

  • RELATED - Confere com pacotes relacionados indiretamente a uma conexão,
    como mensagens de erro icmp, etc.

  • INVALID - Confere com pacotes que não puderam ser identificados por algum
    motivo. Como respostas de conexões desconhecidas.

Caso seja necessário especificar mais de uma opções estas devem ser separadas
por vírgulas.

iptables -A INPUT -m state --state NEW -i ppp0 -j DROP

Bloqueia qualquer tentativa de nova conexão vindo da interface ppp0.

iptables -A INPUT -m state --state NEW,INVALID -i ppp0 -j LOG

Permite registrar novas conexões e pacotes inválidos vindos da interface ppp0.

Limitando o número de vezes que a regra confere

A opção -m limit permite especificar o número de vezes que uma regra conferirá
quando todas as outras condições forem satisfeitas. O número padrão de
conferência é de 3 por hora, a não ser que seja modificado através dos
argumentos aceitos pelo limit:

  • --limit num/tempo - Permite especificar a taxa de conferências do limit. O
    parâmetro num especifica um número e tempo pode ser

      □ s - Segundo

      □ m - Minuto

      □ h - Hora

      □ d - Dia

    Assim uma regra como iptables -A INPUT -m limit --limit 5/m -j ACCEPT
    permitirá que a regra acima confira apenas 5 vezes por minuto (--limit 2/s
    ). Este limite pode ser facilmente adaptado para uma regra de log que
    confere constantemente não causar uma avalanche em seus logs. O valor
    padrão é 3/h.

  • --limit-burst num - Especifica o número inicial máximo de pacotes que irão
    conferir, este número é aumentado por 1 a cada vez que o parâmetro --limit
    acima não for atingido. O valor padrão é 5.

Proteção contra ping da morte

A regra abaixo pode tomada como base para proteção contra ping flood:

iptables -t filter -A ping-chain -p icmp --icmp-type echo-request -m limit --limit 1/s -j ACCEPT
iptables -t filter -A ping-chain -j DROP

A regra acima limita em 1 vez por segundo (--limit 1/s) a passagem de pings
(echo requests) para a máquina Linux.

iptables -t filter -A ping-chain -i ppp0 -p icmp --icmp-type echo-reply -m limit --limit 1/s -j RETURN
iptables -t filter -A ping-chain -j DROP

Limita respostas a pings (echo reply) vindos da interface ppp0 (-i ppp0) a 1
por segundo.

ATENÇÃO: O exemplo acima é somente para a criação de suas próprias regras com
limitações, caso um pacote não confira ele será bloqueado pela próxima regra.
Se uma regra como esta for colocada no chain INPUT sem modificações, ela não
terá o efeito desejado, podendo colocar em risco a sua instalação pela falsa
impressão de segurança. Portanto, é recomendável sempre testar as modificações
para ter certeza que elas tem efeito.

Proteção contra syn flood

A regra abaixo é uma boa proteção para os ataques syn floods:

iptables -t filter -A syn-chain -p tcp --syn -m limit --limit 2/s -j ACCEPT
iptables -t filter -A syn-chain -j DROP

Esta regra limita o atendimento de requisições de conexões a 2 por segundo.
Outra forma de aumentar a segurança contra syn-floods é através do próprio
kernel ativando a opção "TCP Synflood" na compilação e depois executando: echo
"1" >/proc/sys/net/ipv4/tcp_synflood. No entanto, utilize estas opções com
cautela em servidores que possuem um grande número de acessos para não ter
problemas que afetem seu clientes.

ATENÇÃO: Os exemplos acima devem são somente exemplos para criação de suas
próprias regras com limitações, caso um pacote não confira com a regra ele será
bloqueado pela próxima regra. Se uma regra como esta for colocada no chain
INPUT sem modificações, ela não terá o efeito desejado, podendo colocar em
risco a sua instalação pela falsa impressão de segurança. Portanto, é
recomendável sempre testar as modificações para ter certeza que elas tem
efeito.

Proteção contra IP spoofing

A especificação de endereços de origem/destino junto com a interface de rede
pode ser usado como um detector de ataques spoofing. A lógica é que todos os
endereços que NUNCA devem vir da interface X devem ser negados imediatamente.
As regras abaixo são colocadas no inicio do chain INPUT para detectar tais
ataques:

iptables -A INPUT -s 192.168.1.0/24 -i ! eth0 -j DROP
iptables -A INPUT ! -s 192.168.1.0/24 -i eth0 -j DROP

A primeira regra diz para bloquear todos os endereços da faixa de rede
192.168.1.* que NÃO vem da interface eth0, a segunda regra diz para bloquear
todos os endereços que não sejam 192.168.1.* vindos da interface eth0. O
símbolo "!" serve para especificar exceções (veja “Especificando uma exceção”.
O kernel do Linux automaticamente bloqueia a passagem de pacotes que dizem ser
de 127.0.0.1 e não está vindo da interface loopback.

O método preferido para controlar o ip spoofing é através do código de
roteamento do kernel (a não ser que esteja usando algum tipo de roteamento de
origem assimétrico necessário por alguns programas especiais):

for i in /proc/sys/net/ipv4/conf/*/rp_filter; do
 echo 1 >$i
done

Desta forma qualquer endereço dizendo ser 192.168.1.5 vindo de ppp0 será
imediatamente rejeitado. Uma checagem adicional contra IP spoofing pode ser
feita no arquivo /etc/host.conf (veja ???).

Especificando múltiplas portas de origem/destino

O módulo multiport permite que seja especificado múltiplas portas para um alvo.
Podem ser especificadas até 15 portas em um único parâmetro e basta que uma
porta confira para que a regra entre em ação, pois a comparação é feita usando
condições "or". O parâmetro multiport deve ser acompanhado de um dos argumentos
abaixo:

  • --source-port [porta1, porta2...] - Faz a regra conferir se a porta de
    origem estiver presente entre as portas especificadas.

  • --destination-port [porta1, porta2...] - Faz a regra conferir se a porta de
    destino estiver presente entre as portas especificadas.

  • --port [porta1, porta2...] - Faz a regra conferir caso a porta de origem ou
    destino esteja presente no parâmetro.

Este módulo pode eliminar muitas regras de firewall que fazem o mesmo
tratamento de pacotes para diversas portas diferentes.

iptables -A INPUT -p tcp -i ppp0 -m multiport --destination-port 21,23,25,80,110,113,6667 -j DROP

Bloqueia todos os pacotes vindo de ppp0 para as portas 21 (ftp), 23 (telnet),
25 (smtp), 80 (www), 110 (pop3), 113 (ident), 6667 (irc).

Especificando o endereço MAC da interface

O módulo mac serve para conferir com o endereço Ethernet dos pacotes de origem.
Somente faz sentido se usado nos chains de PREROUTING (da tabela nat) ou INPUT
(da tabela filter). Aceita como argumento a opção --mac-source endereço. O
símbolo "!" pode ser usado para especificar uma exceção.

iptables -t filter -A INPUT -m mac --mac-source 00:80:AD:B2:60:0B -j DROP

Confere com a máquina com endereço ethernet igual a 00:80:AD:B2:60:0B.

Conferindo com quem criou o pacote

Este módulo confere com o usuário que iniciou a conexão. É somente válido no
chain OUTPUT da tabela filter. Os seguintes argumentos são válidas para este
módulo:

  • --uid-owner UID - Confere se o pacote foi criado por um processo com o UID
    especificado. Até o momento somente UID numéricos são aceitos.

  • --gid-owner GID - Confere se o pacote foi criado por um usuário pertencente
    ao grupo GID. Até o momento somente GID numéricos são aceitos.

  • --pid-owner PID - Confere se o pacote foi criado por um processo com o PID
    especificado.

  • --sid-owner ID - Confere se o pacote foi criado por um processo no grupo de
    seção especificado.

OBS: - Lembre-se que pacotes que não possuem detalhes suficientes de cabeçalho
nunca conferirão!

iptables -A OUTPUT -m owner --gid-owner 100 -p udp -j DROP

Rejeita um conexões indo para portas UDP de pacotes criados pelo usuários
pertencentes ao grupo 100.

Conferindo com o conteúdo do pacote

O módulo string do iptables permite a inspeção de conteúdo de um pacote e tomar
uma ação se determinado tipo de tráfego for encontrado em um pacote. Esta
técnica pode ser usada tanto para segurança como para economia de banda dentro
da rede. Esta opção *NÃO* torna o iptables como um firewall proxy, pois o proxy
tem a habilidade de inspecionar o conteúdo, protocolo, comandos do pacote e
decidir se o seu conteúdo é nocivo ou não. O firewall em nível de pacotes
fazendo inspeção de conteúdo, chega a ser 3 a 10 vezes mais rápido do que um
proxy, assim seu uso deve ser analisado dependendo do tráfego que circula pelo
link e da segurança dos dados que trafegam através dele.

Uma boa prática é aliar esta opção a um IDS externo usando o alvo QUEUE e
deixando o trabalho de espeção de conteúdo para ele. Um exemplo de restrição
direta é o bloqueio do envio de qualquer informação confidencial sigilosa para
fora da rede interna (número de contas, tudo que conferir com CPF, CGC,
endereços de e-mail, memorandos, etc). De qualquer forma, analise o tráfego de
sua rede antes de querer implementar qualquer solução baseada neste método sob
o risco de afetar tráfego legítimo.

Outra utilidade eficiente é a diminuição de tráfego, pois podemos barrar
programas que sobrecarregam o link em uma rede com muitos usuários como, por
exemplo, usando o Kazaa ou qualquer outro programa para cópia de arquivos via
Internet. Veja alguns exemplos:

# Bloqueia qualquer tentativa de acesso ao programa Kazaa
iptables -A INPUT -m string --string "X-Kazaa" -j DROP

# Não permite que dados confidenciais sejam enviados para fora da empresa
# e registra o ocorrido.
iptables -A OUTPUT -m string --string "conta" -j LOG --log-prefix "ALERTA: dados confidencial "
iptables -A OUTPUT -m string --string "conta" -j DROP

# Somente permite a passagem de pacotes que não contém ".exe" em seu conteúdo
iptables -A INPUT -m string --string ! ".exe" -j ACCEPT

Conferindo com o tempo de vida do pacote

O módulo ttl pode ser usado junto com as seguintes opções para conferir com o
tempo de vida (TTL) de um pacote:

  • --ttl-eq [num]

  • --ttl-lt [num]

  • --ttl-gq [num]

Veja alguns exemplos:

# Confere com todos os pacotes que tem o TTL maior que 100
iptables -A INPUT -m ttl --ttl-gt 100 -j LOG --log-prefix "TTL alto"

# Confere com todos os pacotes que tem o TTL igual a 1
iptables -A INPUT -m ttl --ttl-eq 1 -j DROP

OBS: Tenha um especial cuidado durante a programação de regras que usem TTL,
como elas estão especialmente associadas com o estado da comunicação
estabelecida entre as duas pontas e o tipo de protocolo, cuidados especiais
devem ser tomados para que seu firewall não manipule de forma incorreta tráfego
válido.

Conferindo com números RPC

O módulo rpc permite um controle especial sobre o tráfego RPC que chega até a
sua máquina. Um uso útil é restringir a chamada a determinados números RPC e
permitir outros (por exemplo, permitindo somente o serviço keyserv e bloqueando
outros como o ypserv ou portmapper). As seguintes opções podem ser usadas com o
módulo nfs:

  • --rpcs [procedimentos] - Confere com a lista de chamadas RPC especificadas.
    Mais de um procedimento RPC pode ser especificado como nome ou número
    separando-os com vírgulas. Um arquivo útil que contém esta lista é o /etc/
    rpc.

  • --strict - Ignora serviços RPC que não contenham a chamada get do
    portmapper. Em situações normais, o inicio de qualquer solicitação RPC.

Veja alguns exemplos:

# Para conferir com todas as chamadas RPC referentes a conexões iniciadas
# para o portmapper
iptables -A INPUT -m rpc --rpcs portmapper --strict -j DROP

# Para permitir que somente as chamadas para status e statmon sejam
# aceitas
iptables -A INPUT -m rpc --rpcs 100023,100024 -j ACCEPT

Conferindo com tipo de pacote

O módulo pkttype permite identificar um pacote do tipo unicast (direcionado a
você), broadcast (direcionado a uma determinada rede, definida pela netmask) ou
multicast (destinado a grupos de redes) e desta forma realizar ações em cima
destes. O tipo de pacote é identificado logo após a opção --pkt-type. Veja
alguns exemplos:

# Bloqueia a passagem de pacotes multicast de uma rede para outra
iptables -A FORWARD -i eth0 -o eth0 -m pkttype --pkt-type multicast -j DROP

# Como deve ter notado, é possível fazer a associação com diversas especificações
# de módulos, bastando apenas especificar uma opção "-m" para cada módulo
# adicional:
# Permite a passagem de pacotes broadcast de uma rede para outra com
# limitação de 5/s.
iptables -A FORWARD -i eth0 -o eth0 -m pkttype --pkt-type broadcast -m limit --limit 5/s -j ACCEPT

Conferindo com o tamanho do pacote

O tamanho do pacote pode ser usado como condição de filtragem através do módulo
length. O tamanho do pacote é especificado através da opção --length e o
argumento segue a mesma sintaxe da especificação de portas no iptables sendo
separados por :. Veja alguns exemplos:

# Bloqueia qualquer pacote ICMP maior que 30Kb
iptables -A INPUT -i eth0 -m length --length 30000: -j DROP

# Bloqueia qualquer pacote com o tamanho entre 20 e 2000 bytes
iptables -A INPUT -i eth0 -m length --length 20:2000 -j DROP

Caminho percorrido pelos pacotes nas tabelas e chains

É MUITO importante entender a função de cada filtro e a ordem de acesso dos
chains de acordo com o tipo de conexão e interface de origem/destino. Esta
seção explica a ordem que as regra são atravessadas, isso lhe permitirá
planejar a distribuição das regras nos chains, e evitar erros de localização de
regras que poderia deixar seu firewall com sérios problemas de segurança, ou um
sistema de firewall totalmente confuso e sem lógica.

Nos exemplos abaixo assumirei a seguinte configuração:

  • A máquina do firewall com iptables possui o endereço IP 192.168.1.1 e
    conecta a rede interna ligada via interface eth0 a internet via a interface
    ppp0.

  • Rede interna com a faixa de endereços 192.168.1.0 conectada ao firewall via
    interface eth0

  • Interface ppp0 fazendo conexão com a Internet com o endereço IP
    200.217.29.67.

  • A conexão das máquinas da rede interna (eth0) com a rede externa (ppp0) é
    feita via Masquerading.

Também utilizarei a sintaxe CHAIN-tabela para fazer referência aos chains e
tabelas dos blocos ASCII: INPUT-filter - chain INPUT da tabela filter.

ATENÇÃO: A ordem de processamento das regras do iptables, é diferente do 
ipchains devido a inclusão do novo sistema de nat e da tabela mangle.

Ping de 192.168.1.1 para 192.168.1.1

  • Endereço de Origem: 192.168.1.1

  • Endereço de Destino: 192.168.1.1

  • Interface de Entrada: lo

  • Interface de Saída: lo

  • Protocolo: ICMP

  • Descrição: Ping para o próprio firewall

SAÍDA DE PACOTES (envio do ping para 192.168.1.1):
+-------------+    +----------+    +-------------+   +------------------+  +----------------+
|OUTPUT-mangle| => |OUTPUT-nat| => |OUTPUT-filter| =>|POSTROUTING-mangle|=>|POSTROUTING-nat |
+-------------+    +----------+    +-------------+   +------------------+  +----------------+

ENTRADA DOS PACOTES (Retorno da resposta ping acima):
+-----------------+   +------------+  +------------+
|PREROUTING-mangle| =>|INPUT-mangle|=>|INPUT-filter|
+-----------------+   +------------+  +------------+

Quando damos o ping (echo request) os pacotes seguem o caminho em SAÍDA DE
PACOTES percorrendo os chains na ordem especificada e retornam via ENTRADA DOS
PACOTES (echo reply). No envio da resposta da requisição de ping, o caminho de
saída do pacote ignora os chains OUTPUT-nat e POSTROUTING-nat (já que não é
necessário nat) mas sempre processa os chains correspondentes da tabela mangle
na ordem indicada acima.

OBS1: Para conexões com destinos na própria máquina usando um endereço IP das
interfaces locais, a interface será ajustada sempre para lo (loopback).

OBS2: Em qualquer operação de entrada/saída de pacotes, os dois chains da
tabela mangle são sempre os primeiros a serem acessados. Isto é necessário para
definir a prioridade e controlar outros aspectos especiais dos pacotes que
atravessam os filtros.

OBS3: O chain OUTPUT da tabela filter é consultado sempre quando existem
conexões se originando em endereços de interfaces locais.

Conexão FTP de 192.168.1.1 para 192.168.1.1

  • Endereço de Origem: 192.168.1.1

  • Endereço de Destino: 192.168.1.1

  • Interface de Origem: lo

  • Interface de Destino: lo

  • Porta Origem: 1404

  • Porta Destino: 21

  • Protocolo: TCP

  • Descrição: Conexão ftp (até o prompt de login, sem transferência de
    arquivos).

SAÍDA DOS PACOTES (envio da requisição para 192.168.1.1):
+-------------+    +----------+    +-------------+    +------------------+    +---------------+
|OUTPUT-mangle| => |OUTPUT-nat| => |OUTPUT-filter| => +POSTROUTING-mangle| => |POSTROUTING-nat|
+-------------+    +----------+    +-------------+    +------------------+    +---------------+

ENTRADA DE PACOTES (respostas da requisição vindas de 192.168.1.1):
+-----------------+    +------------+    +------------+
|PREROUTING-mangle| => |INPUT-mangle| => |INPUT-filter|
+-----------------+    +------------+    +------------+

A requisição ftp passa através dos chains especificados em SAÍDA DOS PACOTES e
retorna por ENTRADA DE PACOTES. Após a conexão ser estabelecida, o caminho de 
SAÍDA DE PACOTES será:

+-------------+    +-------------+    +------------------+
|OUTPUT-mangle| => |OUTPUT-filter| => |POSTROUTING-mangle|
+-------------+    +-------------+    +------------------+

pois os dados de entrada que vem da interface externa, são passados diretamente
a máquina do firewall, não necessitando de tratamento SNAT (os chains 
OUTPUT-nat e POSTROUTING-nat são processado somente uma vez a procura de regras
que conferem, principalmente para fazer SNAT). Note novamente que mesmo não
sendo necessário NAT, o chain POSTROUTING-mangle é checado.

OBS1: Para conexões com destinos na própria máquina usando um endereço IP das
interfaces locais, a interface será ajustada sempre para lo (loopback).

OBS2: Em qualquer operação de entrada/saída de pacotes, os dois chains da
tabela mangle são sempre os primeiros a serem acessados. Isto é necessário para
definir a prioridade e controlar outros aspectos especiais dos pacotes que
atravessam os filtros.

Conexão FTP de 192.168.1.1 para 192.168.1.4

  • Endereço de Origem: 192.168.1.1

  • Endereço de Destino: 192.168.1.4

  • Interface de Origem: eth0

  • Interface de Destino: eth0

  • Porta Origem: 1405

  • Porta Destino: 21

  • Protocolo: TCP

  • Descrição: Conexão ftp (até o prompt de login, sem transferência de
    arquivos).

SAÍDA DOS PACOTES (envio da requisição para 192.168.1.4):
+-------------+    +----------+    +-------------+    +------------------+    +---------------+
|OUTPUT-mangle| => |OUTPUT-nat| => |OUTPUT-filter| => +POSTROUTING-mangle| => |POSTROUTING-nat|
+-------------+    +----------+    +-------------+    +------------------+    +---------------+

ENTRADA DE PACOTES (respostas da requisição de 192.168.1.4):
+-----------------+    +------------+    +------------+
|PREROUTING-mangle| => |INPUT-mangle| => |INPUT-filter|
+-----------------+    +------------+    +------------+

A requisição ftp passa através dos chains especificados em SAÍDA DOS PACOTES
com o destino 192.168.1.4 porta 21 e retorna por ENTRADA DE PACOTES para
192.168.1.1 porta 1405. Após a conexão ser estabelecida, o caminho de SAÍDA DE
PACOTES será:

+-------------+    +-------------+    +------------------+
|OUTPUT-mangle| => |OUTPUT-filter| => |POSTROUTING-mangle|
+-------------+    +-------------+    +------------------+

pois os dados não precisam de tratamento SNAT (os chains OUTPUT-nat e 
POSTROUTING-nat são processado somente uma vez a procura de regras que
conferem, principalmente para fazer SNAT).

OBS: Em qualquer operação de entrada/saída de pacotes, os dois chains da tabela
mangle são sempre os primeiros a serem acessados. Isto é necessário para
definir a prioridade e controlar outros aspectos especiais dos pacotes que
atravessam os filtros.

Conexão FTP de 200.217.29.67 para a máquina ftp.debian.org.br

  • Endereço de Origem: 200.217.29.67

  • Endereço de Destino: 200.198.129.162

  • Interface de Origem: ppp0

  • Interface de Destino: ppp0

  • Porta Origem: 1407

  • Porta Destino: 21

  • Protocolo: TCP

  • Descrição: Conexão ftp (até o prompt de login, sem transferência de
    arquivos).

SAÍDA DOS PACOTES (envio da requisição para 200.198.129.162):
+-------------+    +----------+    +-------------+    +------------------+    +---------------+
|OUTPUT-mangle| => |OUTPUT-nat| => |OUTPUT-filter| => +POSTROUTING-mangle| => |POSTROUTING-nat|
+-------------+    +----------+    +-------------+    +------------------+    +---------------+

ENTRADA DE PACOTES (respostas da requisição vindas de 200.198.129.162):
+-----------------+    +------------+    +------------+
|PREROUTING-mangle| => |INPUT-mangle| => |INPUT-filter|
+-----------------+    +------------+    +------------+

A requisição ftp passa através dos chains especificados em SAÍDA DOS PACOTES
com o destino 200.198.129.162 porta 21 (após a resolução DNS de
www.debian.org.br) e retorna por ENTRADA DE PACOTES para 200.217.29.67 porta
1407. Após a conexão ser estabelecida, o caminho de saída de pacotes é:

+-------------+    +-------------+    +------------------+
|OUTPUT-mangle| => |OUTPUT-filter| => |POSTROUTING-mangle|
+-------------+    +-------------+    +------------------+

pois os dados não precisam de tratamento SNAT (os chains OUTPUT-nat e 
POSTROUTING-nat são processado somente uma vez a procura de regras que
conferem, principalmente para fazer SNAT).

E após a conexão estabelecida, o caminho de entrada de pacotes passa a ser:

+-----------------+    +------------+    +------------+
|PREROUTING-mangle| => |INPUT-mangle| => |INPUT-filter|
+-----------------+    +------------+    +------------+

pois os dados não precisam de tratamento DNAT (o chain PREROUTING-nat é
processado somente uma vez a procura de regras que conferem, principalmente
para fazer DNAT).

OBS: Para qualquer operação de entrada/saída de pacotes, os dois chains da
tabela mangle são sempre os primeiros a serem acessados. Isto é necessário para
definir a prioridade e controlar outros aspectos especiais dos pacotes que
atravessam os filtros.

Ping de 192.168.1.4 para 192.168.1.1

  • Endereço de Origem: 192.168.1.4

  • Endereço de Destino: 192.168.1.1

  • Interface de Entrada: eth0

  • Interface de Saída: eth0

  • Protocolo: ICMP

  • Descrição: Ping de 192.168.1.4 para a máquina do firewall.

ENTRADA DE PACOTES (recebimento da requisição, vinda de 192.168.1.4):
+-----------------+    +--------------+    +------------+    +------------+
|PREROUTING-mangle| => |PREROUTING-nat| => |INPUT-mangle| => |INPUT-filter|
+-----------------+    +--------------+    +------------+    +------------+

SAÍDA DE PACOTES (envio da resposta a 192.168.1.4)
+-------------+    +-------------+    +------------------+
|OUTPUT-mangle| => |OUTPUT-filter| => |POSTROUTING-mangle|
+-------------+    +-------------+    +------------------+

Quando damos o ping (echo request) os pacotes seguem o caminho em ENTRADA DE
PACOTES percorrendo os chains na ordem especificada e retornam via SAÍDA DOS
PACOTES (echo reply).

OBS1: Para qualquer operação de entrada/saída de pacotes, os dois chains da
tabela mangle são sempre os primeiros a serem acessados. Isto é necessário para
definir a prioridade e controlar outros aspectos especiais dos pacotes que
atravessam os filtros.

Conexão FTP de 192.168.1.4 para 192.168.1.1

  • Endereço de Origem: 192.168.1.4

  • Endereço de Destino: 192.168.1.1

  • Interface de Origem: eth0

  • Interface de Destino: eth0

  • Porta Origem: 1030

  • Porta Destino: 21

  • Protocolo: TCP

  • Descrição: Conexão ftp (até o prompt de login, sem transferência de dados).

ENTRADA DOS PACOTES (envio da requisição vindas de 192.168.1.4):
+-----------------+    +--------------+    +------------+    +------------+
|PREROUTING-mangle| => |PREROUTING-nat| => |INPUT-mangle| => |INPUT-filter|
+-----------------+    +--------------+    +------------+    +------------+

SAÍDA DE PACOTES (respostas da requisição acima para 192.168.1.4):
+-------------+    +-------------+    +------------------+
|OUTPUT-mangle| => |OUTPUT-filter| => |POSTROUTING-mangle|
+-------------+    +-------------+    +------------------+

A requisição ftp passa através dos chains especificados em ENTRADA DOS PACOTES
com o destino 192.168.1.1 porta 21 e retorna por SAÍDA DE PACOTES para
192.168.1.4 porta 1030. Após a conexão ser estabelecida, o caminho de entrada
de pacotes é:

+-----------------+    +------------+    +------------+
|PREROUTING-mangle| => |INPUT-mangle| => |INPUT-filter|
+-----------------+    +------------+    +------------+

pois os dados não precisam de tratamento DNAT (o chain PREROUTING-nat é
processado somente uma vez a procura de regras que conferem, principalmente
para fazer DNAT).

OBS: O roteamento é sempre realizado após o processamento do chain PREROUTING
da tabela nat.

Conexão FTP de 192.168.1.4 para ftp.debian.org.br

  • Endereço de Origem: 192.168.1.4

  • Endereço de Destino: 200.198.129.162

  • Interface de Origem: eth0

  • Interface de Destino: ppp0

  • Porta Origem: 1032

  • Porta Destino: 21

  • Protocolo: TCP

  • Descrição: Conexão ftp (até o prompt de login, sem transferência de dados).

SAÍDA DOS PACOTES (requisição vindas de 192.168.1.4):
+-----------------+    +--------------+    +--------------+
|PREROUTING-mangle| => |PREROUTING-nat| => |FORWARD-mangle| => (continua abaixo)
+-----------------+    +--------------+    +--------------+
+--------------+    +------------------+    +---------------+
|FORWARD-filter| => |POSTROUTING-mangle| => |POSTROUTING-nat|
+--------------+    +------------------+    +---------------+

ENTRADA DE PACOTES (respostas da requisição acima, enviadas para 192.168.1.4):
+-----------------+    +--------------+    +--------------+    +------------------+
|PREROUTING-mangle| => |FORWARD-mangle| => |FORWARD-filter| => |POSTROUTING-mangle|
+-----------------+    +--------------+    +--------------+    +------------------+

A requisição ftp passa através dos chains especificados em SAÍDA DOS PACOTES
com o destino 200.198.129.162 porta 21 (após a resolução DNS de
ftp.debian.org.br) e retorna por ENTRADA DE PACOTES para 192.168.1.4 porta
1032.

Note que o Masquerading regrava os pacotes; para a máquina 200.198.129.162 a
conexão está sendo feita para 200.217.29.67. As respostas de conexões vindas de
200.198.129.162 e indo para 200.217.29.67 são regravadas no firewall com o
destino 192.168.1.4 e enviadas para a máquina correspondente. Após a conexão
ser estabelecida, o caminho de saída de pacotes para 200.198.129.163 é:

+-----------------+    +--------------+    +--------------+    +------------------+
|PREROUTING-mangle| => |FORWARD-mangle| => |FORWARD-filter| => |POSTROUTING-mangle|
+-----------------+    +--------------+    +--------------+    +------------------+

Após a conexão estabelecida, o caminho da entrada de pacotes vindos de
200.198.129.163 é:

+-----------------+    +--------------+    +--------------+    +------------------+
|PREROUTING-mangle| => |FORWARD-mangle| => |FORWARD-filter| => |POSTROUTING-mangle|
+-----------------+    +--------------+    +--------------+    +------------------+

Isto acontece porque após feita a conexão Masquerading (via PREROUTING-nat), o
firewall já sabe como reescrever os pacotes para realizar a operação de
Masquerading, reescrevendo todos os pacotes que chegam de www.debian.org.br
para 192.168.1.4.

OBS: As conexões Masquerading feitas através da rede interna, são enviadas para
200.198.129.162 tem o endereço de origem ajustado para 200.217.29.67 que é o IP
de nossa interface ppp0. Quando as respostas atravessam o firewall, os pacotes
são checados pra saber se são uma resposta a uma conexão masquerading e fará a
regravação dos pacotes substituindo o endereço de destino para 192.168.1.4.
Caso uma operação de Masquerading falhe, os pacotes serão Bloqueados.

Conexão FTP de 200.198.129.162 para 200.217.29.167

  • Endereço de Origem: 200.198.129.162

  • Endereço de Destino: 200.217.29.67

  • Interface de Origem: ppp0

  • Interface de Destino: ppp0

  • Porta Origem: 3716

  • Porta Destino: 21

  • Protocolo: TCP

  • Descrição: Conexão ao serviço ftp do firewall

ENTRADA DOS PACOTES (requisição vinda de 200.198.129.162):
+-----------------+    +--------------+    +-------------+    +------------+
|PREROUTING-mangle| => |PREROUTING-nat| => |INPUT-mangle | => |INPUT-filter|
+-----------------+    +--------------+    +-------------+    +------------+

SAÍDA DE PACOTES (respostas da requisição de 200.198.129.162):
+-------------+    +-------------+    +------------------+
|OUTPUT-mangle| => |OUTPUT-filter| => |POSTROUTING-mangle|
+-------------+    +-------------+    +------------------+

A requisição ftp passa através dos chains especificados em ENTRADA DOS PACOTES
com o destino 200.217.29.67 (nossa interface ppp0 local) porta 21 e retorna por
SAÍDA DE PACOTES para 200.198.129.162 porta 3716 (também via ppp0). Após a
conexão ser estabelecida, o caminho de entrada de pacotes é:

+-----------------+    +------------+    +------------+
|PREROUTING-mangle| => |INPUT-mangle| => |INPUT-filter|
+-----------------+    +------------+    +------------+

Isto acontece porque após feita a análise do chain PREROUTING (para necessidade
de DNAT), a máquina já saberá tomar a decisão apropriada para gerenciar aquela
conexão.

Gráfico geral da passagem dos pacotes

Este gráfico foi retirado do documento netfilter-hacking-HOWTO.txt e mostra a
estrutura geral de passagem dos pacotes nas tabelas/chains. Os exemplos de
passagem de pacotes acima poderão ser facilmente comparados com as etapas
abaixo para compreender a estrutura do iptables.

E ---> PREROUTING ------> (ROTEAM.) ---> FORWARD ----------> POSTROUTING --> S
       Mangle e              |           Mangle       ^      Mangle
       NAT (DNAT))           |           Filter       |      NAT (SRC)
                             |                     (ROTEAM.)
                             v                        |
                             IN Mangle,              OUT - Mangle,
                             |  Filter                ^    NAT (DNAT)
                             |                        |    Filter
                             v                        |
                    +----------------------------------------+
                    |            Processo Local              |
                    +----------------------------------------+

Exemplos de configurações do iptables

Exemplo de como bloquear todas as conexões para a máquina do firewall
permitindo somente conexões da máquina Linux para fora.

Bloqueando conexões de fora para sua máquina

As regras a seguir servem para bloquear tentativas de conexões da interface de
Internet (ppp0) a sua rede sem bloquear o tráfego de conexões já iniciadas. O
tráfego de outras interfaces não é afetado com as regras a seguir:

iptables -A INPUT -i ppp0 -m state --state ! ESTABLISHED,RELATED -j DROP

Todas as conexões vindas de ppp0 de estado diferente de ESTABLISHED e RELATED
(NEW e INVALID) serão derrubadas. Veja “Conferindo de acordo com o estado da
conexão” para detalhes.

iptables -A INPUT -i ppp0 --syn -j DROP

Este acima é mais simples e possui o mesmo efeito: Pacotes SYN são usados para
iniciar conexões, derrubando pacotes deste tipo significa bloquear novas
conexões. Pacotes de conexões já estabelecidas ainda são permitidos.

Estas regras acima servem para quem não deseja NENHUM acesso indevido a sua
máquina. Existem outras formas de bloquear conexões de modo mais seletivo
usando chains específicos, endereços de origem/destino, portas, etc., este tipo
de configuração é muito usada caso precise fornecer algum tipo de serviço que
seja acessível externamente e protegendo outros.

Monitorando tentativa de conexão de trojans em sua máquina

As regras abaixo alertam sobre a tentativa de conexão dos trojans "For Win"
mais conhecidos. Coloquei isto aqui por curiosidade de algumas pessoas, pois
máquinas Linux são imunes a este tipo de coisa:

#!/bin/sh

TROJAN_PORTS="12345 31336 31337 31338 3024 4092 5714 5742 2583 8787 5556 5557"

iptables -t filter -N trojans-in

for PORTA in ${TROJAN_PORTS};do
 iptables -A trojans-in -p tcp --sport=1024: --dport=${PORTA} -j LOG \
          --log-prefix "FIREWALL: Trojan ${PORTA} "
 iptables -A trojans-in -p tcp --sport=1024: --dport=${PORTA} -j DROP
done

iptables -t filter -A INPUT -i ppp0 -j trojans-in

A primeira linha do iptables cria o chain trojans-in dentro da tabela filter
que usaremos para armazenar nossas regras de firewall. A segunda (dentro do
laço for) faz uma regra de LOG para registrar as tentativas de acesso de
trojans em nosso sistema, a terceira rejeita o acesso. A quarta regra do 
iptables cria de todo o tráfego vindo da interface ppp0 pra o chain trojans-in
(queremos que só o tráfego vindo da internet seja analisado pelo chain 
trojans-in).

Muitas das portas especificadas na variável TROJAN_PORTS são antigas conhecidas
de quem já brincou ou sofreram com o Back Orifice, Win Crack, NetBus (quem
nunca passou pela fase de ter uma lista com mais de 100 netmasks e conseguir
encontrar centenas de máquinas por dia infectadas pelo BO? :-).

No código acima a única coisa que precisa fazer para adicionar mais portas é
inseri-las na variável TROJAN_PORTS e executar o programa. O laço do for
executará as 2 regras para cada porta processada (economizando linhas e linhas
de regras, me livrando de uma LER e poupando muitos bytes neste guia ;-).

Dependendo do número de portas alvo, este código pode ser muito simplificado
usando o recurso multiport do iptables (veja “Especificando múltiplas portas de
origem/destino” para detalhes).

Conectando sua rede interna a Internet

O seguinte exemplo permite ligar sua rede interna com a faixa de IP's
192.168.1.* a internet (usando uma conexão discada do tipo ppp):

iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o ppp+ -j MASQUERADE
echo "1" >/proc/sys/net/ipv4/ip_forward

Um exemplo de firewall simples

Esta seção possui um exemplo mais elaborado de firewall que servirá para
máquinas conectadas via ppp com uma rede interna conectada via Masquerading.
Este exemplo não é tão complexo e cobre as expectativas mais comuns de pessoas
que gostam de explorar os potenciais de rede no Linux ou satisfazer sua
curiosidade. Ele poderá ser facilmente adaptado para atender outro tipo de
necessidade. A configuração assumida é a seguinte:

 1. Máquina do firewall com 2 interfaces de rede, uma é eth0 com o IP
    192.168.1.1 que serve de ligação a sua rede Interna, a outra é ppp0 que é a
    interface Internet.

 2. Qualquer acesso externo a máquinas da rede interna é bloqueado.

 3. Os usuários da rede local tem acesso livre ao servidor Linux.

 4. Qualquer acesso externo a máquina do firewall é bloqueado, exceto conexões
    para o serviço Apache (httpd). Outras tentativas de conexões devem ser
    explicitamente registradas nos logs do sistema para conhecimento do
    administrador.

 5. Todos os usuários possuem acesso livre a Internet via Masquerading, exceto
    que o acesso para o serviço www deve ser obrigatoriamente feito via squid,
    e o servidor smtp a ser usado deverá ser o do firewall Linux.

 6. Prioridades serão estabelecidas para os serviços de telnet, IRC,talk e DNS.

#!/bin/sh
# Modelo de configuração de firewall
# Autor: Gleydson M. Silva
# Data: 05/09/2001
# Descrição: Produzido para ser distribuído livremente, acompanha o guia
#             Foca GNU/Linux. http://www.guiafoca.org
#

# É assumido um sistema usando kmod para carga automática dos módulos usados por
# esta configuração do firewall:
# ipt_filter
# ipt_nat
# ipt_conntrack
# ipt_mangle
# ipt_TOS
# ipt_MASQUERADE
# ipt_LOG

# Se você tem um kernel modularizado que não utiliza o kmod, será necessário
# carregar estes módulos via modprobe, insmod ou iptables --modprobe=modulo

##### Definição de política padrão do firewall #####
# Tabela filter
iptables -t filter -P INPUT DROP
iptables -t filter -P OUTPUT ACCEPT
iptables -t filter -P FORWARD DROP
# Tabela nat
iptables -t nat -P PREROUTING ACCEPT
iptables -t nat -P OUTPUT ACCEPT
iptables -t nat -P POSTROUTING DROP
# Tabela mangle
iptables -t mangle -P PREROUTING ACCEPT
iptables -t mangle -P OUTPUT ACCEPT


##### Proteção contra IP Spoofing #####
for i in /proc/sys/net/ipv4/conf/*/rp_filter; do
 echo 1 >$i
done

##### Ativamos o redirecionamento de pacotes (requerido para NAT) #####
echo "1" >/proc/sys/net/ipv4/ip_forward

# O iptables define automaticamente o número máximo de conexões simultâneas
# com base na memória do sistema. Para 32MB = 2048, 64MB = 4096, 128MB = 8192,
# sendo que são usados 350 bytes de memória residente para controlar
# cada conexão.
# Quando este limite é excedido a seguinte mensagem é mostrada:
#  "ip_conntrack: maximum limit of XXX entries exceed"
#
# Como temos uma rede simples, vamos abaixar este limite. Por outro lado isto
# criará uma certa limitação de tráfego para evitar a sobrecarga do servidor.
echo "2048" > /proc/sys/net/ipv4/ip_conntrack_max


###############################################################
#                      Tabela filter                          #
###############################################################

##### Chain INPUT #####
# Criamos um chain que será usado para tratar o tráfego vindo da Internet e
iptables -N ppp-input

# Aceita todo o tráfego vindo do loopback e indo pro loopback
iptables -A INPUT -i lo -j ACCEPT
# Todo tráfego vindo da rede interna também é aceito
iptables -A INPUT -s 192.168.1.0/24 -i eth0 -j ACCEPT

# Conexões vindas da interface ppp0 são tratadas pelo chain ppp-input
iptables -A INPUT -i ppp+ -j ppp-input

# Qualquer outra conexão desconhecida é imediatamente registrada e derrubada
iptables -A INPUT -j LOG --log-prefix "FIREWALL: INPUT "
iptables -A INPUT -j DROP


##### Chain FORWARD ####
# Permite redirecionamento de conexões entre as interfaces locais
# especificadas abaixo. Qualquer tráfego vindo/indo para outras
# interfaces será bloqueado neste passo
iptables -A FORWARD -d 192.168.1.0/24 -i ppp+ -o eth0 -j ACCEPT
iptables -A FORWARD -s 192.168.1.0/24 -i eth0 -o ppp+ -j ACCEPT
iptables -A FORWARD -j LOG --log-prefix "FIREWALL: FORWARD "
iptables -A FORWARD -j DROP


##### Chain ppp-input ####
# Aceitamos todas as mensagens icmp vindas de ppp0 com certa limitação
# O tráfego de pacotes icmp que superar este limite será bloqueado
# pela regra "...! ESTABLISHED,RELATED -j DROP" no final do
# chain ppp-input
#
iptables -A ppp-input -p icmp -m limit --limit 2/s -j ACCEPT

# Primeiro aceitamos o tráfego vindo da Internet para o serviço www (porta 80)
iptables -A ppp-input -p tcp --dport 80 -j ACCEPT

# A tentativa de acesso externo a estes serviços serão registrados no syslog
# do sistema e serão bloqueados pela última regra abaixo.
iptables -A ppp-input -p tcp --dport 21 -j LOG --log-prefix "FIREWALL: ftp "
iptables -A ppp-input -p tcp --dport 25 -j LOG --log-prefix "FIREWALL: smtp "
iptables -A ppp-input -p udp --dport 53 -j LOG --log-prefix "FIREWALL: dns "
iptables -A ppp-input -p tcp --dport 110 -j LOG --log-prefix "FIREWALL: pop3 "
iptables -A ppp-input -p tcp --dport 113 -j LOG --log-prefix "FIREWALL: identd "
iptables -A ppp-input -p udp --dport 111 -j LOG --log-prefix "FIREWALL: rpc"
iptables -A ppp-input -p tcp --dport 111 -j LOG --log-prefix "FIREWALL: rpc"
iptables -A ppp-input -p tcp --dport 137:139 -j LOG --log-prefix "FIREWALL: samba "
iptables -A ppp-input -p udp --dport 137:139 -j LOG --log-prefix "FIREWALL: samba "
# Bloqueia qualquer tentativa de nova conexão de fora para esta máquina
iptables -A ppp-input -m state --state ! ESTABLISHED,RELATED -j LOG --log-prefix "FIREWALL: ppp-in "
iptables -A ppp-input -m state --state ! ESTABLISHED,RELATED -j DROP
# Qualquer outro tipo de tráfego é aceito
iptables -A ppp-input -j ACCEPT


#######################################################
#                   Tabela nat                        #
#######################################################

##### Chain POSTROUTING #####
# Permite qualquer conexão vinda com destino a lo e rede local para eth0
iptables -t nat -A POSTROUTING -o lo -j ACCEPT
iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o eth0 -j ACCEPT

# Não queremos que usuários tenham acesso direto a www e smtp da rede externa, o
# squid e smtpd do firewall devem ser obrigatoriamente usados. Também registramos
# as tentativas para monitorarmos qual máquina está tentando conectar-se diretamente.
iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o ppp+ -p tcp --dport 80 -j LOG --log-prefix "FIREWALL: SNAT-www "
iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o ppp+ -p tcp --dport 25 -j LOG --log-prefix "FIREWALL: SNAT-smtp "
iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o ppp+ -p tcp --dport 25 -j DROP
iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o ppp+ -p tcp --dport 80 -j DROP
# É feito masquerading dos outros serviços da rede interna indo para a interface
# ppp0
iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o ppp+ -j MASQUERADE

# Qualquer outra origem de tráfego desconhecida indo para eth0 (conexões vindas
# de ppp+) são bloqueadas aqui
iptables -t nat -A POSTROUTING -o eth0 -d 192.168.1.0/24 -j LOG --log-prefix "FIREWALL: SNAT unknown"
iptables -t nat -A POSTROUTING -o eth0 -d 192.168.1.0/24 -j DROP
# Quando iniciamos uma conexão ppp, obtermos um endereço classe A (10.x.x.x) e após
# estabelecida a conexão real, este endereço é modificado. O tráfego indo para
# a interface ppp não deverá ser bloqueado. Os bloqueios serão feitos no
# chain INPUT da tabela filter
iptables -t nat -A POSTROUTING -o ppp+ -j ACCEPT

# Registra e bloqueia qualquer outro tipo de tráfego desconhecido
iptables -t nat -A POSTROUTING -j LOG --log-prefix "FIREWALL: SNAT "
iptables -t nat -A POSTROUTING -j DROP


###############################################
#                Tabela mangle                #
###############################################

##### Chain OUTPUT #####
# Define mínimo de espera para os serviços ftp, telnet, irc e DNS, isto
# dará uma melhor sensação de conexão em tempo real e diminuirá o tempo
# de espera para conexões que requerem resolução de nomes.
iptables -t mangle -A OUTPUT -o ppp+ -p tcp --dport 21 -j TOS --set-tos 0x10
iptables -t mangle -A OUTPUT -o ppp+ -p tcp --dport 23 -j TOS --set-tos 0x10
iptables -t mangle -A OUTPUT -o ppp+ -p tcp --dport 6665:6668 -j TOS --set-tos 0x10
iptables -t mangle -A OUTPUT -o ppp+ -p udp --dport 53 -j TOS --set-tos 0x10

Capítulo 6. Restrições de acesso, recursos e serviços

Índice

Limitando recursos no bash

    Uso do comando readonly para exportar variáveis
    Restrições nos diretórios de usuários e root
    Restrições básicas do shell bash com bash -r/--restricted, rbash
    Finalizando consoles inativos
    Desabilitando o registro de comandos digitados
    Desabilitando serviços de shell para usuários

Limitação de recursos usando PAM

    Descobrindo se um determinado programa tem suporte a PAM
    Definindo uma política padrão restritiva
    Restringindo/Bloqueando o login
    Restringindo o acesso a root no su
    Restrições de serviços PAM baseados em dia/hora
    Permitindo acesso a grupos extras
    Limitação de recursos do shell

Restrições de acesso a programas/diretórios/arquivos usando grupos
Dando poderes de root para executar determinados programas
Restringindo o comando su
Restrições baseadas em usuário/IP
Restrições por MAC Address/IP
Desabilitando serviços não usados no Inetd
Evitando o uso de hosts.equiv e .rhosts
Restringindo o uso do shutdown
Restringindo o acesso ao sistema de arquivos /proc
Limitando o uso de espaço em disco (quotas)

    Instalando o sistema de quotas
    Editando quotas de usuários/grupos
    Modificando a quota de todos os usuários de uma vez
    Verificando a quota disponível ao usuário
    Verificando a quota de todos os usuários/grupos do sistema
    Avisando usuários sobre o estouro de quota

Suporte a senhas ocultas
Suporte a senhas com algorítmo SHA e md5
Restrições no hardware do sistema

    BIOS do sistema
    Retirada da unidade de disquetes
    Placas de rede com eprom de boot
    Protegendo o LILO
    Disco rígido

Este capítulo documenta diversos métodos de fazer restrições de contas,
limitação de acesso interno/externo, de recursos por usuários/grupos, login,
tempo máximo ocioso, e outros modos para limitar o uso de recursos do sistema.
Também são descritos métodos para aumentar a segurança do acesso físico a seu
servidor e maneiras de restringir o uso de serviços disponíveis no sistema.

Se você deseja restringir o acesso de máquinas na rede ou portas específicas em
sua máquina , veja também Capítulo 5, Firewall iptables .

Limitando recursos no bash

Uso do comando readonly para exportar variáveis

Variáveis exportadas na forma comum podem ser modificadas a qualquer momento
pelo usuário, e isso pode trazer problemas de acordo com o tipo de sistema que
administramos. A definição da variável como somente leitura (readonly) evita a
maioria destes problemas:

readonly TESTE="123"

A variável TESTE não poderá ser modificada ou excluída. Com isto o
administrador pode "bloquear" a modificação de variáveis que controlam o
funcionamento de determinados recursos do interpretador de comandos (alguns
deles serão vistos ainda nesta seção).

OBS1: Algumas variáveis de controle de ambientes ambiente do interpretador de
comandos já são iniciadas com valores somente leitura (como as variáveis EUID e
PPID)

OBS2: Variáveis exportadas como somente leitura em shell scripts são mantidas
até a finalização do script e depois liberadas.

Restrições nos diretórios de usuários e root

O controle de acesso a diretórios de usuários é importante quando desejamos que
outras pessoas não tenham acesso ao diretório de outros usuários, violando a
privacidade do mesmo e obtendo acesso a partes indesejáveis, principalmente do
usuário root. É recomendado restringir o acesso somente ao dono e grupo do
usuário, bloqueando o acesso a outros tipos de usuários:

chmod 2750 /root
chmod 2750 /home/usuario

O exemplo acima permitirá o acesso do diretório /root e /home/usuario somente
ao usuário e grupo que pertencem. Este processo pode ser facilitado na criação
dos diretórios de usuários em /home especificando a variável: DIR_MODE=0750 no
arquivo /etc/adduser.conf.

OBS: Algumas distribuições de Linux garantem o acesso livre a diretórios de
usuários por padrão pois alguns daemons que requerem acesso a diretório de
usuários rodam sob outros usuários ao invés do root. Um bom exemplo é a
utilização do recurso "UserDir" do Apache para servir requisições como http://
servidor.org/~usuario.

A restrição de diretório home neste caso bloqueará o acesso do servidor web 
Apache ao diretório /home/usuario/public_html. Mesmo assim, uma alternativa
para garantir a utilização da restrição é incluir o usuário do servidor web 
Apache (www-data) no grupo "usuario" (que possui acesso ao diretório /home/
usuario):

adduser www-data usuario

Isto garantirá que o servidor Apache continue servindo as requisições dentro do
diretório /home/usuario, com acesso garantido via grupo. O mesmo principio pode
ser aplicado em outros programas, apenas leve em consideração que se um cracker
tomar conta do processo que tem acesso ao seu diretório home restrito, ele
certamente também terá acesso.

Restrições básicas do shell bash com bash -r/--restricted, rbash

Quando o bash é iniciado com o parâmetro -r, --restricted ou como rbash, o
shell restringe o uso dos seguintes recursos em sua seção:

  • Usar o comando cd para mudar de diretório.

  • Definindo, modificar ou apagar a variáveis SHELL, PATH, ENV, BASH_ENV.

  • Nomes de comandos que contém /

  • Especificar um nome de arquivo contendo uma / como argumento para o comando
    builtin (embutido no interpretador de comandos).

  • Especificar uma / como argumento a opção -p no comando hash (embutido no
    interpretador de comandos).

  • Importar a definição de funções do ambiente do shell atual.

  • Analisar o valor da variável SHELLOPTS do ambiente do shell atual.

  • Redirecionando a saída padrão usando os operadores de redirecionamento >, >
    |, <>, >&, >&; e >>.

  • Usando o comando embutido exec para substituir o shell por outro comando.

  • Usar as opções -f ou -d com o comando enable (embutido no interpretador de
    comandos).

  • Especificar a opção -p ao comando interno command.

  • Desativar o modo restrito com set +r ou set +o restricted *

Estas restrições são ativadas após a leitura dos arquivos de inicialização do
interpretador de comandos. O shell restrito desliga as restrições quando um
shell script é executado.

Finalizando consoles inativos

A variável TMOUT determina o tempo de inatividade de um shell para que ele seja
terminado.

export TMOUT=600

Terminará o bash caso nenhum comando seja executado no período de 600 segundos
(5 minutos). Veja “Uso do comando readonly para exportar variáveis” como
complemento.

Desabilitando o registro de comandos digitados

Todos os comandos que digitamos em uma seção do shell são registrados no
arquivo ~/.bash_history, as seguintes variáveis fazem seu controle:

  • HISTFILE - Nome do arquivo que armazenará o histórico de comandos. O padrão
    é ~/.bash_history. Caso não seja especificado, os comandos não serão
    gravados após finalizar o shell.

  • HISTSIZE - Define o número de comandos que o arquivo de histórico poderá
    armazenar, o padrão é 500.

  • HISTFILESIZE - Define o número máximo de linhas no arquivo de histórico.

Se você possui muitos usuários em seu sistema, é recomendado ajustar estas
variáveis como somente leitura para que o usuário não desative o logging por
qualquer motivo (veja “Uso do comando readonly para exportar variáveis”).

Desabilitando serviços de shell para usuários

Existem casos onde o usuário precisa estar cadastrado no sistema mas não
precisa ter acesso a uma conta de login válida (como um sistema servidor de
e-mail ou outros serviços). Neste caso a desabilitação dos serviços de shell
aumentará um pouco a segurança do sistema, mesmo conseguindo acesso a conta/
senha estará impedido de entrar no sistema (pelo menos terá um pouco mais
dificuldade para conseguir isso).

Um programa que é muito usado para desabilitar o shell exibindo uma mensagem ao
usuário que fez a tentativa é o falselogin. Ele deve ser colocado como o "shell
padrão" no arquivo /etc/passwd e exibirá a mensagem contida no arquivo /etc/
falselogin.conf quando o login para aquele usuário for tentado. Esta operação
pode ser facilitada usando a variável DSHELL=/usr/bin/falselogin no arquivo /
etc/adduser.conf.

Uma forma alternativa de desativar o serviço de login de TODOS os usuários
(exceto o root e os já logados no sistema) é criar um arquivo chamado /etc/
nologin e colocando uma mensagem dentro dele, que será exibida quando tentarem
efetuar o login no sistema.

OBS: Tome cuidado ao usar esta alternativa, este método deve ser usado somente
em caso de EMERGÊNCIA, as distribuições Linux usam este método para bloquear o
login de outros usuários durante o processo de inicialização, removendo assim
que o processo é terminado. Esteja consciente disso.

Em alguns casos, o uso do PAM pra desabilitar os serviços de login pode ser
mais adequado (veja “Restringindo/Bloqueando o login”).

Limitação de recursos usando PAM

Plugglable Autentication Modules (Módulos de autenticação plugáveis) são um
conjunto de bibliotecas usadas para fazer autenticação, gerenciamento de
contas, controle de recursos dos usuários no sistema, em adição ao tradicional
sistema de acesso baseado em usuários/grupos. Este recurso permite modificar a
forma que um aplicativo autentica e define recursos para o usuário sem
necessidade de recompilar o aplicativo principal. Os recursos que desejamos
controlar restrições via PAM são especificados individualmente por serviços nos
arquivos correspondentes em /etc/pam.d e então os arquivos correspondentes em /
etc/security são usados para controlar tais restrições.

Nesta seção assumirei explicações dirigidas aos recursos controlados pelos
arquivos em /etc/security A maioria das explicações são baseadas em testes e
nos próprios exemplos dos arquivos de configuração do PAM.

Descobrindo se um determinado programa tem suporte a PAM

Um método simples de se determinar se um programa binário possui suporte a PAM
é executando o comando:

ldd [programa]

Por exemplo:

ldd /bin/login

libcrypt.so.1 => /lib/libcrypt.so.1 (0x4001c000)
libpam.so.0 => /lib/libpam.so.0 (0x40049000)
libpam_misc.so.0 => /lib/libpam_misc.so.0 (0x40051000)
libdl.so.2 => /lib/libdl.so.2 (0x40054000)
libc.so.6 => /lib/libc.so.6 (0x40058000)
/lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)

Caso a biblioteca libpam for listada, o programa tem suporte a PAM compilado.
Programas que não possuem suporte a PAM deverão ter o código fonte modificado
inserindo as funções para tratamento dos módulos de autenticação.

Definindo uma política padrão restritiva

A política padrão do PAM é especificado em /etc/pam.d/other e define o que
acontecerá caso nenhum dos arquivos de controle de serviço em /etc/pam.d
confiram com o serviço em questão. Normalmente o módulo pam_unix.so é usado
para fazer a política padrão, para deixar o sistema mais seguro, utilize a
seguinte configuração no arquivo /etc/pam.d/other:

auth     required       /usr/lib/security/pam_warn.so
auth     required       /usr/lib/security/pam_deny.so
account  required       /usr/lib/security/pam_deny.so
password required       /usr/lib/security/pam_warn.so
password required       /usr/lib/security/pam_deny.so
session  required       /usr/lib/security/pam_deny.so

O módulo pam_deny.so é responsável por fazer o bloqueio, e o pam_warn envia
avisos ao syslog (facilidade auth nível notice) caso serviços módulos PAM que
necessitem do serviço de autenticação sejam bloqueados (isto não é feito
automaticamente pelo pam_deny.so).

OBS: Esta configuração poderá causar bloqueio em muitas coisas caso possua
módulos de autenticação mau configurados. Esteja certo de utilizar o módulo
pam_warn.so (antes do pam_deny.so) nas diretivas restritivas para entender qual
é o problema através da análise dos arquivos de logs.

Mais detalhes sobre a configuração de módulos de autenticação poderão ser
encontrados no endereço ftp://ftp.us.kernel.org/pub/linux/libs/pam/
Linux-PAM-html/pam.html e http://www.kernel.org/pub/linux/libs/pam/pre/doc/
rfc86.0.txt.gz.

Restringindo/Bloqueando o login

Isto é controlado pelo arquivo /etc/security/access.conf. O formato deste
arquivo consistem em três campos separados por ":":

  • Primeiro campo - Garante ("+") ou bloqueia ("-") o acesso caso as condições
    nos outros campos confiram.

  • Segundo campo - Contém o login, grupo. O formato usuário@computador pode
    ser usado para conferir com usuários que acessam de determinadas máquinas.
    Caso existam mais de um parâmetro, estes devem ser separados usando
    espaços. As palavras chave ALL (todos) e EXCEPT (exceção) e console também
    podem ser usadas.

  • Terceiro campo - Lista de terminais (tty - na forma listada pelo ttyname),
    nomes de máquinas, nomes de domínios (começando com "."), endereços IP ou
    FQDN, porção de rede (finalizando com um "."). As palavras chave ALL
    (todos) e LOCAL (máquinas na mesma rede) também podem ser usadas.

OBS1: - A configuração padrão do access.conf é garantir o acesso a todos os
usuários, através de qualquer lugar (permissiva).

OBS2:: Mesmo se existir uma regra autorizando o acesso ao usuário, as restantes
serão verificadas em busca de uma que bloqueie o acesso do usuário. Se nenhuma
regra conferir, o usuário terá acesso garantido.

OBS3: - O nome de grupo somente é checado quando nenhum nome de usuário confere
com nenhum usuário logado no sistema.

OBS4: - Grupos/usuários NIS podem ser especificados precedendo o nome do
usuário ou grupo por uma "@".

Abaixo uma configuração restrita de /etc/security/access.conf:

#
# Desabilita o login de todos os usuários EXCETO o root no terminal tty1
-:ALL EXCEPT root:tty1

# Permite o login no console de todos os usuários especificados.
+:gleydson root:console

# Conexões vindas da rede *.debian.org e *.debian.org.br de usuários pertencendo
# ao grupo operadores são consideradas seguras (exceto para o usuário root).
+:operadores EXCEPT root: .debian.org .debian.org.br

# Qualquer outra tentativa de acesso não definida acima é bloqueada imediatamente.
-: ALL: ALL

Restringindo o acesso a root no su

A restrição de acesso a usuário root pelo PAM funciona permitindo que somente
alguns usuários que pertençam a um grupo criado pelo administrador possam se
tornar o superusuário usando o comando su. Esta restrição funciona até mesmo
para os usuários que possuem a senha correta de root, retornando uma mensagem
de login ou senha incorretos. Isto é extremamente útil para restrições de
acesso.

Um outro ponto positivo é caso ocorra um possível acesso não autorizado em seu
sistema ou um daemon seja corrompido e o atacante cair em um shell, ele não
poderá obter root na máquina pois o UID do daemon provavelmente não terá
autorização. A distribuição Debian, em especial, possui grupos e nomes de
usuários organizados de forma a permitir segurança e separação total caso
utilize este mecanismo.

Este recurso se mostra bem eficiente para proteger a integridade da máquina até
mesmo no comprometimento de máquinas que possui a senha semelhante, somente se
usado em conjunto com as restrições de acesso de outros serviços remotos (como
o ssh, ftp, etc). O guia Foca documenta as formas de restrição e seu impacto na
segurança da máquina nos capítulos do nível Avançado (veja o índice para buscar
o capítulo correspondente ao que deseja proteger).

Para configurar esta restrição, siga os seguintes passos:

  • Crie um grupo onde os usuários cadastrados terão acesso root. Por exemplo,
    usuarios-su (ou algo mais discreto).

  • Edite o arquivo /etc/pam.d/su. Insira a seguinte linha (caso não existir)
    no arquivo de configuração:

    auth       required   pam_wheel.so group=usuarios-su

    O que ela faz é usar o módulo pam_wheel.so requerendo que os usuários
    pertençam ao grupo usuarios-su. Salve e saia do editor.

  • Ainda como usuário root, adicione os usuários que terão acesso a root no
    grupo usuarios-su. Recomendo que adicione seu usuário primeiro,
    principalmente se estiver fazendo acesso remoto, pois se acontecer uma
    queda no link não ficará sem acesso root por cair na restrição :-)

  • Tente pegar o root com outros usuários que não pertençam ao grupo
    usuarios-su estes simplesmente terão o acesso negado.

Restrições de serviços PAM baseados em dia/hora

Estas restrições são controladas pelo arquivo /etc/security/time.conf, a
sintaxe deste arquivo é quatro campos separados por ";":

  • Primeiro campo - Nome do serviço PAM que será controlado (um dos serviços
    contidos em /etc/pam.d).

  • Segundo campo - Lista de nomes de terminais que a regra que aplicará. O
    sinal "&" tem a função and, "|" tem a função or e "!" especifica uma
    exceção.

  • Terceiro campo - Nome de usuários afetados pela regra. O sinal "&" tem a
    função and, "|" tem a função or e "!" especifica uma exceção.

    OBS: O "*" poderá ser usado somente no primeiro, segundo ou terceiro campo
    em uma mesma regra.

  • Quarto campo - DiaSemana/faixa-de-horas que a restrição se aplicará. O dia
    da semana é especificado em duas letras:

      □ Mo - Segunda-feira

      □ Tu - Terça-feira

      □ We - Quarta-feira

      □ Th - Quinta-feira

      □ Fr - Sexta-feira

      □ Sa - Sábado

      □ Su - Domingo

      □ Wk - Todos os dias da semana

      □ Wd - Somente sábado e domingo (fim de semana)

      □ Al - Todos os dias

    O sinal "!" especifica uma exceção. A faixa de horas é especificada após o
    dia no formato HHMM-HHMM. Por exemplo:

    MoTuWe0000-2400 - Segundas, terças e quartas
    MoFrSu0800-1900- - Segundas, sextas e domingo das 08:00 da manha as 19:00 da noite.
    FrFr0500-0600 - Não será realizada na sexta (especificações repetidas são anuladas)
                    de 05:00 as 06:00.
    WkWe0731-1456 - Todos os dias da semana a partir de Quarta de 07:31 da manhã as
                    14:56 da tarde.
    AlMo0000-2400 - Todos os dias da semana, exceto segunda-feira.

Por padrão o acesso é garantido a todos os usuários. Abaixo um exemplo de
restrições usando o /etc/security/time.conf:

# Bloqueia o login do usuário user1 ou user2 em qualquer tty, a restrição
# durante todos os dias de 00:00 as 06:30
login;tty*;user1|user2;!Al0000-0630

# Bloqueia o acesso do usuário root ao serviço login nos terminais tty*
# (e não nos terminais ttyp*) nos finais de semana.
login;tty* & !ttyp*;root;!Wd0000-2400

# O usuário 1 não poderá efetuar o login as terças feiras de 00:00 as 06:00
login;!tty*;user1;Tu0000-0600

OBS1: Mesmo se existir uma regra autorizando o acesso ao usuário, as restantes
serão verificadas em busca de uma que bloqueie o acesso do usuário. Se nenhuma
regra conferir, o usuário terá acesso garantido.

OBS2: Quando as restrições de tempo são ativadas no /etc/security/time.conf, o
daemon logoutd poderá ser ativado manualmente (através de /etc/init.d/logoutd)
para monitora as restrições neste arquivo, forçando o logout de usuário de
acordo com as configurações do /etc/security/time.conf. Isto ocorrerá
automaticamente na próxima vez que iniciar o sistema (a distribuição detecta a
presença de restrições de tempo no arquivo /etc/security/time.conf para decidir
se deve ou não carregar este daemon).

Quando não está em execução, os limites de tempo são verificados somente no
login do usuário, ele poderá ultrapassar este tempo sem ser desconectado do
sistema.

Permitindo acesso a grupos extras

Este recurso é controlado pelo arquivo /etc/security/group.conf. Este arquivo é
composto por 5 campos separados por ";" (os 4 primeiros são os mesmos
explicados em “Restrições de serviços PAM baseados em dia/hora”. O 5o campo
contém um ou mais grupos (separados por espaços ou vírgulas) que serão
adicionados aos grupos do usuário quando as condições dos campos anteriores
conferirem.

OBS: Se o usuário escrever um programa que chama um interpretador de comandos e
der a permissão SGID (chmod g+s programa), ele terá acesso àquele grupo na hora
que quiser. Restrinja o uso de grupos somente a usuários de confiança ou crie
grupos específicos para evitar problemas.

Exemplo de configuração do arquivo /etc/security/group.conf:

# Permite que o usuário gleydson tenha acesso ao grupo floppy efetuando o login
# entre 08:00 da manha e 19:00 da noite
login;tty*;gleydson;Al0800-1900;floppy

# Todos os usuários podem ter acesso ao grupo games e sound aos sábados e domingos
login;tty*;*;SaSu0000-2400;sound games

# Todos os usuários podem ter acesso ao grupo games e sound todos os dias
# de 18:00 as 05:00 da manhã (fora do horário de expediente ;-)
login;tty*;*;Al1800-0500;sound,games

# Backups são permitidos fora do horário de expediente (para não sobrecarregar
# a CPU e evitar o uso excessivo de disco).
login;tty*;gleydson;Al1830-2400;backup

OBS1: Mesmo que uma regra confira com o usuário, as outras também serão
verificadas para garantir acesso grupos extras.

OBS2: O padrão na maioria das distribuições é limitar o número máximo de grupos
do usuário para 32. Caso precise aumentar este limite, será necessário
recompilar o kernel (e também a glibc, se necessário) para aceitar um número
maior modificando a variável ngroup.

Limitação de recursos do shell

Estas restrições são especificadas no arquivo /etc/security/limits.conf. Seu
formato consiste em 4 campos separados por ou ou mais espaços:

  • Primeiro campo - Especifica o nome de usuário, um nome de grupo (@grupo) ou
    um "*" especificando que as restrições nos outros campos se aplicam a todos
    os grupos e todos os usuários.

  • Segundo campo - Tipo de restrição:

      □ soft - Limite suave de bloqueio.

      □ hard - Limite rígido de bloqueio.

      □ - - Quando o tipo de restrição não se aplica ao Ítem que deseja
        restringir o acesso.

    Quando somente o limite "hard" (rígido) é especificado, o limite suave
    assume o mesmo valor.

  • Terceiro campo - Ítem que deseja restringir o acesso:

      □ core - Limita o tamanho do arquivo core (KB)

      □ data - Tamanho máximo de arquivo de dados (KB)

      □ fsize - Tamanho máximo de arquivo (KB)

      □ memlock - Tamanho máximo do espaço de endereços bloqueado na memória
        (KB)

      □ nofile - Número máximo de arquivos abertos

      □ rss - Tamanho máximo residente (KB)

      □ stack - Tamanho máximo da pilha (KB)

      □ cpu - Tempo máximo de uso da CPU (MIN)

      □ nproc - Número máximo de processos

      □ as - Limite de espaço de endereços

      □ maxlogins - Número máximo de logins

      □ priority - Prioridade de execução de processos de usuários

  • Quarto campo - Especifica o valor do campo anterior

Os limites aplicados ao usuário podem ser visualizados através do comando
ulimit -S -a (para listar limites suaves - soft) e ulimit -H -a (para listar
limites rígidos - hard). Caso o parâmetro -S ou -H sejam omitidos, os limites
listados serão os suaves (soft). Um exemplo de /etc/security/limits.conf
(retirado da distribuição Debian GNU/Linux:

*               soft    core            0
*               hard    rss             10000
@student        hard    nproc           20
@faculty        soft    nproc           20
@faculty        hard    nproc           50
ftp             hard    nproc           0
@student        -       maxlogins       4
gleydson        -       maxlogins       2

OBS: Estas permissões passam a ter efeito no momento que o usuário se conecta
ao sistema, e não quando elas são modificadas no arquivo /etc/security/
limits.conf.

Restrições de acesso a programas/diretórios/arquivos usando grupos

Usuários podem ter o acesso liberado a diretórios/arquivos execução de
programas de acordo com o grupo que pertencem. Este é um recurso valioso na
administração de sistemas Unix que se bem usado, aumenta as restrições de
acesso e segurança no acesso/utilização de programas em um ambiente de
trabalho. Usuários de sistema tendem a usar o usuário root para fazer tarefas
como conexão com internet, utilização da placa de som, modem, etc. e as vezes
nem sabem que isso pode ser feito através do mesmo usuário adicionando este a
um grupo específico.

Esta tarefa pode ser feita com o comando adduser usuário grupo ou editando
manualmente os arquivos /etc/group e /etc/gshadow. Podemos ter as seguintes
situações facilitadas com o uso de grupos:

  • Usar a placa de som. Os dispositivos usados pela placa de som como /dev/
    audio, /dev/dsp, /dev/sndstat, etc. normalmente tem permissão leitura/
    gravação para o usuário root e grupo audio (cheque com o comando ls -la /
    dev/audio). Para autorizar determinados usuários usar a placa de som basta
    adiciona-los neste grupo: adduser usuario audio.

  • Conectar a Internet. Normalmente o utilitário ppp tem as permissões SUID
    root e grupo dip. Adicionamos o usuário a este grupo: adduser usuario dip.
    Agora ele poderá conectar/desconectar a internet sem a intervenção do
    usuário root.

    OBS Certamente o usuário terá acesso aos arquivos de configuração da
    discagem do ppp e conseqüentemente a senha de conexão internet, e esta
    senha é a mesma usada no e-mail primário do provedor (com o mesmo nome da
    conta). Esta mesma situação pode acontecer com outros programas que
    autorize o acesso a grupos, é importante que conheça bem as permissões do
    programa e entender se existem riscos.

  • Utilizar o modem. Um bom grupo para permitir a utilização do modem é
    dialout. O dispositivo utilizado pelo modem (não seu link) deve ter
    permissões leitura/gravação para o usuário root e grupo dialout.
    Cadastrando o usuário neste grupo autorizará a utilização do modem: adduser
    usuario dialout.

  • Permitir que diversos usuários compartilhem um mesmo diretório. Isto é útil
    quando muitas pessoas estão desenvolvendo um mesmo projeto. Siga estes
    passos:

      □ Crie um novo grupo no sistema: groupadd gp1, a opção -g permite
        selecionar manualmente a GID. Opcionalmente você poderá usar um grupo
        já existente no sistema (veja o arquivo /etc/group).

      □ Crie o diretório que será usado para armazenar os arquivos deste grupo
        de usuários: mkdir projeto1).

      □ Mude o dono/grupo do diretório: chown root.gp1 projeto1/

      □ De permissões de leitura/gravação para o dono/grupo do diretório, vamos
        também incluir a permissão SGID para que todos os arquivos criados
        dentro deste diretório pertençam ao mesmo grupo e não ao grupo primário
        do usuário, assim todos os usuários terão acesso: chmod 2770 projeto1

      □ Agora cadastre os usuários que deverão ter acesso ao diretório projeto1
        / no grupo gp1, somente estes usuários e o root terão acesso ao
        diretório (permissões 2770).

      □ É interessante também mudar a "umask" do usuário de 022 para 002 (ou
        equivalente) para que os novos arquivos criados tenham permissão de
        leitura/gravação para o grupo gp1. Caso contrário, lembre-se de
        modificar as permissões de seus arquivos manualmente. Um ótimo comando
        para fazer isso (sem afetar diretórios) é: find . -type f -user
        usuario1 -exec chmod 0660 \{\} \;. Este comando parece estranho mas é
        excelente! um chmod -R 0660 afetaria até os diretórios, imagine o caos.

A maioria das distribuições Linux vem com uma boa política de grupos para
permitir um controle eficaz de recurso. Se você quer saber quais arquivos em
seu sistema pertencem a determinado grupo (útil para saber o que o usuário terá
acesso se adiciona-lo àquele grupo) execute o comando:

find / -group nome_do_grupo

Dando poderes de root para executar determinados programas

A ferramenta ideal para isto é o sudo. Através dela é possível permitir um
usuário comum executar um comando como root e registrar quando isto foi feito.
É possível selecionar os usuários/grupos que terão acesso e quais aplicativos
que poderão ser usados, estas configurações são feitas no arquivo /etc/sudoers.

Por exemplo, para o usuário "john" usar o comando shutdown para desligar o
computador: sudo shutdown -h now.

O sudo é um programa muito completo, tomaria muitos Kilobytes neste guia.
Recomendo dar uma lida na página de manual para entender como as variáveis do
arquivo de configuração funcionam. Mesmo assim aqui vai um exemplo simples
deste arquivo para iniciar rapidamente o uso do sudo:

# arquivo sudoers.
#
# Edite este arquivo com o comando 'visudo' como root
#
#

# Especificação de máquinas. O primeiro campo (Host_Alias) diz que a variável
# LOCALSERVER será um nome/endereço de máquina
Host_Alias      LOCALSERVER=192.168.0.1

# Especificação de usuários. O primeiro campo (User_Alias) diz que a variável
# NETMASTERS armazenará nomes de usuários
User_Alias      NETMASTERS=gleydson, goodboy

# Comandos. O primeiro campo (Cmnd_Alias) diz que a variável
# C_REDE contém comandos do sistema. Mais de um parâmetro
# deve ser separado por vírgulas
Cmnd_Alias      C_REDE=/sbin/ipchains, /sbin/iptables

# Padrões que se aplicam aos usuários da variável NETMASTERS. O parâmetro
# mail_always sempre envia um e-mail ao root avisando sobre o uso do
# sudo
Defaults:NETMASTERS     mail_always

# As linha que começam com o nome de usuário ou variável "User_Alias"
# definem o acesso aos recursos. O primeiro campo é o usuário, o segundo
# o endereço de acesso (opcionalmente seguido de um sinal "=" para
# especificar opções adicionais) o terceiro o comando ou lista de comandos
#
# O usuário root não tem restrições
root    ALL=(ALL) ALL

# Permite que os usuários especificados na variável NETMASTERS
# acessando dos locais em LOCALSERVER utilizem os comandos
# em C_REDE (sem fornecer senha).
NETMASTERS      LOCALSERVER=NOPASSWD: C_REDE

Edite este arquivo com o comando visudo, ele faz algumas checagens para
detectar problemas de configuração. Para listar os comandos disponíveis para o
usuário no sudo, utilize a opção -l, ex: sudo -l.

Restringindo o comando su

Restrições de acesso através de grupos, bloqueio de acesso, acesso direto sem
senha, etc. podem ser aplicados ao sudo via seu arquivo de configuração PAM /
etc/pam.d/su. Abaixo um exemplo explicativo deste arquivo:

# A configuração abaixo requer que o usuário seja membro do
# grupo adm para usar o 'su'.
# auth       required   pam_wheel.so group=adm

# Membros do grupo acima não precisam fornecer senha, temos confiança neles.
# auth       sufficient pam_wheel.so trust

# Usuário que pertencem ao grupo "nosu" nunca deverão ter acesso ao 'su'
# auth       required   pam_wheel.so deny group=nosu

# O root não precisa fornecer senha ao 'su'
auth       sufficient pam_rootok.so

# Ativa as restrições PAM de /etc/security/limits.conf
session    required   pam_limits.so

# Isto ativa as restrições PAM de /etc/security/time.conf no
# comando 'su'
account    requisite  pam_time.so

# Módulos padrões de autenticação Unix
auth       required   pam_unix.so
account    required   pam_unix.so
session    required   pam_unix.so

Restrições baseadas em usuário/IP

O serviço identd permite identificar os usuários que estão realizando conexões
TCP, adicionalmente esta característica é usada por programas para fazer
restrições para usuários em adição ao endereço de origem/destino. A sintaxe
usada nas diretivas de acesso é especificada na forma usuário@endereço. O ???
explica a configuração/utilização/vulnerabilidades e recomendações sobre este
serviço.

Diversos programas que possuem controle de acesso baseado em IP's/hosts aceitam
esta especificação, como o exim, ircd, e o conhecido tcpd.

Segue um exemplo da utilização do identd com o arquivo hosts.allow:

# Permite o acesso ao serviço de telnet somente ao usuário gleydson conectando
# a partir da máquina com IP 192.168.1.1
in.telnetd: gleydson@192.168.1.1

# Permite o acesso ao serviço ftp somente ao usuário gleydson conectando de
# qualquer máquina da rede 192.168.1.*
in.ftpd: gleydson@192.168.1.

Note que a utilização do identd torna a utilização do serviço um pouco mais
restrita, somente conhecendo os "logins" de quem tem acesso ao serviço, um
cracker conseguirá ter acesso ao mesmo serviço naquele sistema (este é um dos
motivos que é recomendado sempre divulgar o mínimo detalhes possíveis sobre o
sistema para minimizar riscos de ataques).

Veja mais detalhes sobre o uso do identd em ???.

Restrições por MAC Address/IP

Esta proteção oferece uma barreira maior se segurança contra IPs spoofing
evitando que pessoas mal intencionadas façam um IP spoofing da máquina para
obter acessos privilegiados que somente o detentor original do MAC/IP teria.
Recomendo não levar em consideração que isto seja a solução definitiva contra
IP spoofing, pois é possível falsificar o MAC address de uma interface para
tomar outra identidade.

Este método poderá ser aplicado para fornecer um maior laço de confiança por
hardware entre as máquinas que compõem uma rede de servidores. Ele também evita
mesmo que uma máquina configurada de forma errônea tenha acesso indevido ao
servidor ou em uma situação extrema, se torne o gateway da rede.

Para restringir as conexões para uma máquina Linux por MAC address, utilize o
firewall iptables. Com ele será permitido fazer a restrição por serviços,
criando uma barreira bastante chata para crackers tentarem se conectar a um
serviço. Como referência, leia a seção “Especificando o endereço MAC da
interface”.

Outra situação é a restrição por par MAC/IP usando o próprio cache arp da
máquina, usando entradas estáticas de endereços. Um exemplo deste uso é quando
você é extremamente paranóico ou quando uma rede que utiliza algum método de
autenticação baseado no rhosts (como é o caso do sistema de backup do Amanda),
então é importante dizer para as máquinas servidoras, qual o MAC address/IP
privilegiado que terá o acesso ao usuário para conexão sem senha.

O local padronizado para definir um MAC estático (e bastante desconhecido da
maioria dos administradores de sistemas) é o /etc/ethers. O formato deste
arquivo é o MAC Address e IP separados por espaço, cada linha com uma nova
entrada de MAC Address. Veja o exemplo:

00:03:47:AA:AA:AB       www.focalinux.org.br
00:03:47:BB:AA:BA       www2.focalinux.org.br
00:03:47:BB:AA:BB       192.168.0.1

Caso não conheça o formato do endereço de MAC Address, os três primeiros 3
campos definem o fabricante da placa de rede, e os 3 últimos é uma
identificação única do fabricante para a Placa, ou seja, NENHUMA placa de rede
fabricada tem o mesmo MAC Address físico.

Para que o comando arp crie as entradas estáticas no seu cache ARP, será
necessário executar o comando arp -f /etc/ethers. Este comando poderá ser
colocado em algum script ou diretório de inicialização de sua distribuição para
que seja executado automaticamente (como por exemplo, no /etc/rc.boot da Debian
). Digitando arp você verá as linhas definidas no arquivo /etc/ethers marcadas
com as opção (flag) M (manual/permanente). Outra forma de verificar, é usando o
arp -a máquina ou somente arp -a. As máquinas especificadas estaticamente
(manualmente) terão o nome PERM listados (cache arp permanente).

OBS: Como deve ter notado, a restrição por MAC Address implica em um aumento no
trabalho de gerenciamento das configurações. Assim, planeje-se para que esta
tarefa não seja desgastante, crie programas para realizar atualizações
dinâmicas estudando a estrutura de sua rede e como suas máquinas se comunicam
para não ter problemas obscuros quando tiver que fazer uma simples modificação
em uma interface de rede :)

Uma boa configuração restritiva requer análise sobre os impactos na rede.

Desabilitando serviços não usados no Inetd

Desative todos os serviços que não serão utilizados no arquivo /etc/inetd.conf,
isto diminui bastante as possibilidades de ataques em seu sistema. Os nomes de
serviços são os parâmetros especificados na primeira coluna do arquivo /etc/
inetd.conf (por exemplo, talk, ircd, pop3, auth, smtp).

Para desativar serviços neste arquivo, ponha o símbolo "#" no inicio das linhas
que deseja comentar e execute um killall -HUP inetd. Alternativamente, o
comando update-inetd pode ser usado para facilitar esta tarefa:

update-inetd --disable finger,talk,time,daytime

update-inetd --disable

Este comando envia automaticamente o sinal de reinicio (HUP) ao inetd. O
serviço poderá ser novamente ativado substituindo a opção --disable por 
--enable ou retirando o trecho "#<off>#" no começo da linha do serviço do /etc/
inetd.conf.

Evitando o uso de hosts.equiv e .rhosts

O arquivo hosts.equiv contém uma lista de usuários autorizados/desautorizados
que podem fazer uso dos serviços "r*" sem fornecer uma senha (como rsh, rcp, 
rexec, etc) , veja ???. É muito fácil falsificar um nome de usuário para obter
acesso aos privilégios de outro usuário usando este recurso.

Os arquivos ~/.rhosts, ~/.shosts tem o funcionamento parecido com o hosts.equiv
mas contém somente dois campos, o primeiro especificando o nome do computador
(FQDN) e o segundo o nome do usuário que tem permissão de acesso sem fornecer
senha. Ele garantirá este acesso ao usuário e máquina remota especificada neste
arquivo. Se for definido somente o nome do computador, o nome de usuário deverá
ser o mesmo do local para que o acesso sem senha seja garantido. É recomendável
restringir o acesso a estes arquivos somente ao usuário/grupo quando for
realmente necessário. Um exemplo de ~/.rhosts:

maquina1.dominio.com.br usuario1
maquina2.dominio.com.br usuario2

O uso destes dois mecanismos e dos serviços "r*" são desencorajados! (o último
por usar transferência de dados não criptografadas). Veja ??? para uma
alternativa melhor. Utilize estes dois mecanismos somente se deseja facilidade
no gerenciamento e se sua rede seja absolutamente confiável e a segurança de
dados não seja prioridade pra você...

Restringindo o uso do shutdown

Por padrão todos que tem acesso ao console do sistema podem efetuar o reinicio
do computador pressionando CTRL+ALT+DEL. Estas teclas de combinação são
definidas pela linha

ca:12345:ctrlaltdel:/sbin/shutdown -r now

do arquivo /etc/inittab. A opção -a (access) do shutdown restringe isto,
permitindo somente o reinicio do sistema caso um dos usuários cadastrados no
arquivo /etc/shutdown.allow estejam logados no console. Caso nenhum usuário
autorizado esteja logado, a mensagem shutdown: no authorized users logged in é
exibida no console local.

O arquivo /etc/shutdown.allow deve conter um usuário por linha e 32 no máximo.

A mesma linha do /etc/inittab pode ser modificada para a seguinte:

ca:12345:ctrlaltdel:/sbin/shutdown -a -t5 -r now

OBS: Se a opção -a seja especificada e o arquivo /etc/shutdown.allow não
existe, a opção -a é ignorada.

Restringindo o acesso ao sistema de arquivos /proc

O patch restricted proc fs é um dos melhores para realizar esta tarefa.
Restringindo o acesso ao sistema de arquivos /proc evita que o usuário normal
tenha acesso aos detalhes sobre processos de outros (com ps aux) ou acesso a
detalhes de processos de outros usuários existentes nos subdiretórios numéricos
(equivalentes a PID) em /proc. Abaixo algumas características do patch 
restricted proc fs:

  • É pequeno, rápido e faz poucas modificações no fonte do kernel.

  • Seu método de funcionamento é baseado nas restrições de dono/grupo (nativas
    de ambiente Unix).

  • Restringe a visualização de processos só dos usuários. Adicionalmente será
    especificada uma GID para o diretório /proc, qualquer usuário que pertença
    ao grupo especificado poderá visualizar todos os processos e entrar em
    qualquer diretório do kernel (sem restrições, como se não tivesse o patch).

  • Muito estável e confiável.

Este patch deve ser baixado de http://noc.res.cmu.edu/proc, existem versões
para os kernels da série 2.2 e 2.4, baixe e aplique o patch, na configuração do
kernel ative a opção Restricted Proc fs support. Compile e instale seu kernel.

No arquivo /etc/fstab inclua um grupo para a montagem do sistema de arquivos /
proc (vamos usar o grupo adm com a GID 4):

# /etc/fstab: informações estáticas do sistemas de arquivos.
#
# <Sist. Arq.>    <Ponto Mont.>  <tipo>  <opções>       <dump> <passo>
  proc            /proc          proc    defaults,gid=4   0       0

Após reiniciar o sistema, execute o comando ls -lad /proc note que o grupo do
diretório /proc será modificado para adm. Agora entre como um usuário e execute
um ps aux, somente seus processos serão listados. Para autorizar um usuário
específico ver todos os processos (ter acesso novamente ao diretório /proc),
inclua este no grupo que usou no arquivo /etc/fstab:

adduser usuario adm

Após efetuar o usuário já estará pertencendo ao grupo adm (confira digitando
groups), e poderá ver novamente os processos de todos os usuários com o comando
ps aux.

OBS1: Incluir um usuário no grupo adm É PERIGOSO, porque este usuário poderá
ter acesso a arquivo/diretórios que pertençam a este grupo, como os arquivos/
diretórios em /var/log. Se esta não é sua intenção, crie um grupo independente
como restrproc para controlar quem terá acesso ao diretório /proc: addgroup
restrproc.

OBS2: Se a opção gid não for especificada para a montagem de /proc no /etc/
fstab, o grupo root será usado como padrão. NUNCA adicione usuários ao grupo
root, use o método da observação acima para permitir outros usuários ver todos
os processos em execução.

OBS3 Caso o servidor identd esteja sendo usado na máquina servidora, será
necessário roda-lo com a mesma GID do diretório /proc para que continue
funcionando. Se ele é executado como daemon, adicione a opção -g GRUPO no
script que inicia o serviço em /etc/init.d e reinicie o daemon. Caso ele seja
iniciado via inetd, faça a seguinte modificação no arquivo /etc/inetd.conf
(assumindo o uso do oidentd):

#:INFO: Info services
auth            stream  tcp     nowait.40       nobody.adm      /usr/sbin/oidentd oidend -q -i -t 40

Veja ??? para detalhes sobre este serviço.

Limitando o uso de espaço em disco (quotas)

O sistema de quotas é usado para limitar o espaço em disco disponível a
usuários/grupo. O uso de partições independentes para o diretório /home e
outros montados separadamente não é muito eficaz porque muitos usuários serão
prejudicados se a partição for totalmente ocupada e alguns possuem
requerimentos de uso maior do que outros.

O suporte a Quotas deve estar compilado no kernel (seção FileSystems) e o
sistema de arquivos deverá ser do tipo ext2 ou XFS para funcionar.

Instalando o sistema de quotas

Abaixo o passo a passo para a instalação de quotas em seu sistema:

 1. Recompile seu kernel com suporte a quota. Habilite a opção "Quota support"
    na seção "FileSystems" na configuração de recursos do seu kernel.

 2. Instale o pacote no sistema (apt-get install quota).

 3. Habilite a quota para os sistemas de arquivos que deseja restringir no
    arquivo /etc/fstab:

    /dev/hda1    /boot ext2     defaults                   1  1
    /dev/hda3    /     ext2     defaults,usrquota          1  2
    /dev/hda4    /usr  ext2     defaults,grpquota          1  3
    /dev/hda5    /pub  ext2     defaults,usrquota,grpquota 1  4

    O sistema de arquivos /dev/hda1 não terá suporte a quota, /dev/hda3 terá
    suporte a quotas de usuários (usrquota), /dev/hda4 terá suporte a quotas de
    grupos (grpquota) e /dev/hda5 terá suporte a ambos. Por padrão é assumido
    que os arquivos de controle de quota estão localizados no ponto de montagem
    da partição com os nomes quota.user e quota.group.

 4. Agora será necessário criar os arquivos quota.user e quota.group no ponto
    de montagem de cada partição ext2 acima que utilizará o recurso de quotas.
    O arquivo quota.user controla as quotas de usuários e quota.group controla
    as quotas de grupos.

      □ Crie um arquivo vazio quota.user em / (terá suporte somente a quota de
        usuários, veja a opção de montagem no /etc/fstab): touch /quota.user ou
        echo -n >/quota.user.

      □ Crie um arquivo vazio quota.group em /usr (terá suporte somente a quota
        de grupos): touch /usr/quota.group ou echo -n >/usr/quota.group.

      □ Crie um arquivo vazio quota.user e quota.group em /pub (este sistema de
        arquivos tem suporte a ambos os tipos de quota): touch /pub/quota.user
        /pub/quota.group.

    Por motivos de segurança, as permissões dos arquivos de controle de quota
    quota.user e quota.group devem ser leitura/gravação ao usuário root e sem
    permissões para grupo/outros usuários: chmod 0600 /quota.user /quota.group.

    OBS: Se deseja utilizar o quota versão 1, certifique-se que não existem os
    arquivos chamados aquota.user e aquota.group no diretório raíz de sua
    partição. Se eles estiverem disponíveis, os utilitários de quota utilizarão
    esta versão como padrão, atualmente o kernel 2.4 possui somente suporte a
    quota versão 1.

    A versão 2 do quota checa corrompimento dos arquivos de dados de quota e
    trabalha mais rápido em partições grandes. São necessários patches da série
    "ac" (Alan Cox) para usar a versão 2 do quota.

 5. Entre em modo monousuário init 1, desmonte os sistemas de arquivos que
    utilizarão a quota e monte-os novamente (isto serve para ativar as opções
    de quota). Alternativamente, execute umount -a (para desmontar todos os
    sistemas de arquivos) e mount -a para remontar todos.

    Se você ativou as quotas para o sistema de arquivos / (como em nosso
    exemplo) será necessário reiniciar o sistema.

 6. O próximo passo é scanear o disco para criar os dados para as partições com
    suporte a quota (ativadas no /etc/fstab):

     quotacheck -augv

    O parâmetro -a diz para checar todas as partições com suporte a quota no
    arquivo /etc/mtab, -u para checar quotas de usuários, -g para checar grupos
    e -v para mostrar o progresso da checagem da partição.

    Na primeira execução é mostrado uma mensagem de erro de arquivo quota.user/
    quota.group corrompido, mas isto é normal porque o arquivo anterior tem
    tamanho zero. Estes nomes também servem para o quotacheck "auto-detectar" a
    versão do sistema de quota usada no sistema de arquivos.

    OBS: Certamente será necessário "forçar" a remontagem como somente leitura
    do sistema de arquivos / com a opção -m para o quotacheck criar as
    configurações de quota nesta partição.

 7. Agora resta ativar o suporte as quotas de disco em todas as partições (-a)
    com recurso de quota especificado (no /etc/mtab):

     quotaon -augv

    As opções possuem o mesmo significado do comando quotacheck. O utilitário 
    quotaoff serve para desativar quotas de usuários e usa as mesmas opções do 
    quotaon. Estes três utilitários somente podem ser usados pelo usuário root.
    As opções de quota podem ser especificadas independente para cada sistema
    de arquivos:

    # Ativa o suporte a quota em /pub (somente grupos de usuários no momento).
    quotaon -gv /pub

    # Ativa as quotas de usuários em /pub
    quotaon -uv /pub

    # Desativa as quotas de grupos em /pub (deixando somente a de usuários ativa)
    quotaoff -gv /pub

A atualização de quotas durante a gravação/exclusão de arquivos é feita
automaticamente. O utilitário quotacheck deverá ser executado sempre que o
sistema de quotas for desativado (por não haver atualização automática dos
dados de uso de disco) ou quando ocorrerem falhas de disco.

Na distribuição Debian o quotacheck é disparado sempre que necessário após as
situações de checagem de disco. As quotas de todas as partições também são
ativadas automaticamente pelo script /etc/init.d/quota e /etc/init.d/quotarpc.

Em sistemas que utilizam NFS e possuem sistemas de arquivos exportados em /etc/
exports, o daemon rpc.rquotad deverá ser carregado. Sua função é fornecer os
detalhes de quota dos sistemas de arquivos locais exportados para as máquinas
clientes.

Editando quotas de usuários/grupos

O programa edquota é usado pelo root para editar as quotas de usuários/grupos.
Por padrão, todos os usuários/grupos do sistema não possuem quotas. Sua sintaxe
é a seguinte

edquota [opções] [usuário/grupo]

As opções podem ser:

-u

    Edita a quota do usuário especificado (esta é a padrão).

-g

    Edita a quota de grupo especificado.

-r

    Permite editar a quota de sistemas de arquivos remotos através do daemon 
    rpc.rquotad.

-p [usuário/grupo]

    Usa os valores especificados para o usuário/grupo para definir a nova
    quota, sem necessidade de entrar no modo de edição.

-t

    Permite modificar o valor de tolerância dos limites que ultrapassam soft
    até que sejam bloqueados. Durante o tempo de tolerância, serão enviados
    somente avisos sobre a quota ultrapassada sem bloquear totalmente a
    gravação de arquivos (até que o limite hard seja atingido ou o tempo de
    tolerância seja ultrapassado).

Quando a quota soft do usuário/grupo é estourada, a mensagem "warning: user
disk quota excedeed" será exibida. Quando a quota hard é ultrapassada, a
gravação atual é interrompida e a mensagem "write failed, user disk limit
reatched" é mostrada ao usuário. Nenhuma nova gravação que ultrapasse a quota 
hard é permitida Por exemplo, para modificar a quota do usuário gleydson:
edquota gleydson

Disk quotas for user gleydson (uid 1000):
  Filesystem                   blocks       soft       hard     inodes     soft
    hard
  /dev/hda5                    504944     500100     600000      10868        15000
       20000

O editor de textos usado poderá ser modificado através da variável $EDITOR.
Abaixo a explicação destes campos:

  • Filesystem - Sistema de arquivos que terá a quota do usuário/grupo editada.
    As restrições se aplicam individualmente de acordo com o sistema de
    arquivos.

  • blocks - Número máximo de blocos (especificado em Kbytes) que o usuário
    possui atualmente. O usuário gleydson está usando atualmente 504944 Kbytes.

      □ soft - Restrição mínima de espaço em disco usado. Atualmente 500100 Kb.

      □ hard - Limite máximo aceitável de uso em disco para o usuário/grupo
        sendo editado. 600000 Kb atualmente. O sistema de quotas nunca deixará
        este limite ser ultrapassado.

  • inodes - Número máximo de arquivos que o usuário possui atualmente na
    partição especificada. O usuário gleydson possui atualmente 10868 arquivos
    na partição /pub.

      □ soft - Restrição mínima de número de arquivos que o usuário/grupo
        possui no disco. Atualmente em 15.000.

      □ hard - Restrição máxima de número de arquivos que o usuário/grupo
        possui no disco. Atualmente em 20.000.

Para desativar as restrições coloque "0" no campo soft ou hard. Quando o limite
soft é atingido, o usuário é alertado por ter ultrapassado sua quota com a
mensagem "warning: user quota excedeed" (quota do usuário excedida). O programa
setquota é uma programa não-interativo para edição de quotas para ser usado
diretamente na linha de comando ou em shell scripts.

Após ultrapassar o limite soft, começa a contagem do tempo para que este passe
a valer como limite hard (o máximo aceitável e que nunca poderá ser
ultrapassado). O comando edquota -t serve para modificar estes valores na
partição especificada:

Grace period before enforcing soft limits for users:
Time units may be: days, hours, minutes, or seconds
  Filesystem             Block grace period     Inode grace period
  /dev/hda5                  2days                  7days

Abaixo a explicação destes campos:

  • Filesystem - Sistema de arquivos que terá o período de tolerância
    modificado.

  • Block grade period - Tempo máximo de tolerância para usuários/grupos que
    ultrapassaram sua quota soft de espaço em disco antes de passar a valer
    como hard. No exemplo, o usuário tem 2 dias para excluir possíveis arquivos
    ou contactar o administrador para redimensionar o tamanho de quota. O valor
    padrão é 7 dias.

  • Inode grade period - Tempo máximo de tolerância para usuários/grupos que
    ultrapassaram sua quota soft de número de arquivos gravados antes de passar
    a valer como hard. No exemplo, o usuário tem 7 dias para excluir possíveis
    arquivos ou contactar o administrador para analisar seu tamanho de quota. O
    valor padrão é 7 dias.

OBS1: - O comando quotacheck deverá ser executado na partição sempre que novas
restrições/limites forem editados com o edquota. Isto atualiza os arquivos
quota.user e quota.group. Lembre-se de desativar o sistema de quotas (quotaoff
-ugv /partição) antes de executar este comando (para liberar totalmente a
partição, quotacheck remonta a partição somente para leitura quando é
executado). Por este motivo é recomendável fazer isso em modo monousuário.

OBS2: Quando o limite soft (suave) é excedido, o sistema começará a lhe mostrar
mensagens alertando a passagem do limite (para lhe dar tempo de eliminar
arquivos ou não ser pego desprevenido com o bloqueio de gravação) porque o
limite hard (rígido) nunca poderá ser ultrapassado.

OBS3: - O tempo de tolerância restante ao usuário/grupo quando a quota é
ultrapassada poder ser visualizada com o comando quota (veja “Verificando a
quota disponível ao usuário”).

OBS4: - Quando o usuário exclui seus arquivos e volta a ficar abaixo dos
limites soft da quota, o tempo de tolerância é resetado aos valores padrões
(especificados por edquota -t.

OBS5: - As quotas de espaço em disco podem ser definidas automaticamente para
os novos usuários adicionados ao sistema colocando o espaço em disco na
variável QUOTAUSER=numero do arquivo /etc/adduser.conf. Isto será equivalente a
digitar o comando edquota -q QUOTA novo_usuário.

Modificando a quota de todos os usuários de uma vez

Editar manualmente a quota de cada usuário é uma tarefa trabalhosa quando se
está instalando quotas e possui muitos usuários, existe uma maneira mais fácil
de fazer isso usando o próprio edquota e um usuário com a quota já definida.
Por exemplo, instalamos quota em nosso sistema e queremos que todos os 300
usuários tenham a quota de usuário de 10MB e de grupo de 15MB:

 1. Criamos um usuário com esta quota usando o edquota (como descrito em
    “Editando quotas de usuários/grupos”). Como exemplo usaremos o usuário
    teste_user. Use o comando quota teste_user para verificar se as quotas para
    este usuário está correta.

 2. Criamos um script que modifique a quota padrão de todos os usuários do
    sistema de uma só vez:

    #!/bin/sh
    cd /home
    for USUARIO in *
    do
    edquota -u ${USUARIO} -p teste_user

    done

    Pronto, verifique a quota de todos os usuários com o comando repquota -a.

Verificando a quota disponível ao usuário

Execute o comando quota mostra os limites de usuários/grupos e a tolerância
restante antes do limite soft se tornar rígido. Abaixo alguns exemplos
descritivos deste comando:

quota

Disk quotas for user gleydson (uid 1234):
     Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
      /dev/hda5  504944* 500100  600000   00:05   10868       0       0

Os campos tem o seguinte significado:

  • Filesystem - Sistema de arquivos.

  • blocks - Número de blocos usados atualmente na partição (em Kb). O "*"
    indica que o limite foi ultrapassado. Atualmente em 504944.

      □ quota - Limite suave (soft) de espaço na partição que o usuário/grupo
        possui. Atualmente 500100. O valor 0 indica que o usuário/grupo não
        possui restrições.

      □ limit - Limite máximo (hard) de espaço na partição que o usuário/grupo
        possui. Atualmente em 600000. O valor 0 indica que o usuário/grupo não
        possui restrições.

      □ grace - Tolerância antes que o limite soft passe a valer como hard
        quando o espaço em disco é ultrapassado. Este usuário tem 5 minutos
        restantes para que isto ocorra. Quando o valor soft volta a ficar
        abaixo da quota, a tolerância é resetada.

        O parâmetro "none" indica que o tempo de tolerância expirou (caso
        existam limitações de quota que foram ultrapassadas) ou que o usuário/
        grupo não possui restrições. Veja se existe um "*" no campo blocks.

  • files - Número máximo de arquivos que usuário/grupo possui atualmente na
    partição. Um "*' indica que o limite foi ultrapassado. Atualmente em 10868.

      □ quota - Limite suave (soft) de número de arquivos na partição que o
        usuário/grupo possui. Atualmente ilimitado.

      □ limit - Limite máximo (hard) de número de arquivos na partição que o
        usuário/grupo possui. Atualmente ilimitado.

      □ grace - Tolerância antes que o limite soft passe a valer como hard para
        o número de arquivos ultrapassados. Como não existe quota para número
        de arquivos, não existe tolerância. A tolerância é resetada aos valores
        padrões quando o valor soft volta a ficar abaixo da quota.

A quota de outros usuários/grupos podem ser visualizadas especificando as
opções -u (padrão) e -g na linha de comando respectivamente. A opção -v permite
visualizar quotas em sistemas de arquivos não alocados e -q mostra somente uma
mensagem dizendo se o usuário está ou não dentro de sua quota:

quota -u usuario

quota -uq usuario

quota -g users

Por motivos de segurança, você não poderá visualizar as quotas de outros
usuários e grupos que não pertence (exceto para o usuário root).

Verificando a quota de todos os usuários/grupos do sistema

Quando precisamos verificar o uso de quotas de todos os usuários/grupos do
sistema o quota se torna incômodo e pouco prático. O comando repquota lista
está disponível ao administrador para facilitar esta tarefa. Sua listagem é
organizada por partições listando dados adicionais como grace time e aceita as
mesmas opções dos utilitários quotaon e quotaoff. Primeiro são listados as
restrições de usuários e depois de grupos para a partição. (tolerância) As
opções aceitas por este utilitário tem o mesmo significado das opções do 
quotaon e quotaoff:

repquota -aug

*** Report for user quotas on device /dev/hda3
Block grace time: 7days; Inode grace time: 7days
                        Block limits                File limits
User            used    soft    hard  grace    used  soft  hard  grace
----------------------------------------------------------------------
root      --   29160       0       0   none    9970     0     0   none
daemon    --      64       0       0             22     0     0
man       --     944       0       0             65     0     0
mail      --    4960       0       0            823     0     0
news      --       4       0       0              1     0     0
gleydson  --   31032       0       0           6956     0     0
testuser  --      16       0       0              4     0     0
anotheruser --    16       0       0              4     0     0
nobody    --    2344       0       0              2     0     0

*** Report for user quotas on device /dev/hda5
Block grace time: 2days; Inode grace time: 7days
                        Block limits                File limits
User            used    soft    hard  grace    used  soft  hard  grace
----------------------------------------------------------------------
root      --   16052       0       0   none    6443     0     0   none
gleydson  +-    4944  500100  600000   none   10868     0     0

*** Report for group quotas on device /dev/hda5
Block grace time: 7days; Inode grace time: 7days
                        Block limits                File limits
Group           used    soft    hard  grace    used  soft  hard  grace
----------------------------------------------------------------------
root      --   20308       0       0   none     636     0     0   none
src       --   11404       0       0            660     0     0
users     --    1756       0       0           6561     0     0
gleydson  --    3452       0       0           9307     0     0

Um sinal de "+-" no segundo campo indica quota ultrapassada ou no espaço em
disco, "-+' em número de arquivos e "++" em ambos. Como vimos acima, o este
comando também lista o número de arquivos e bytes pertencentes a cada usuário
na partição (mesmo não sendo monitorado pelas restrições de quota), isto ajuda
a monitorar ações suspeitas com a excedência de espaço em disco de determinados
usuários/grupos do sistema. Um exemplo é alguém que esteja fora da quota e
abusando de seu usuário/grupo para uso excessivo de espaço em disco sem seu
conhecimento.

OBS: Este utilitário pode ser executado por qualquer usuário no sistema e
mostrar o uso de quotas de usuários/grupos que não deveria ter acesso. É
recomendado deve ter permissões de leitura/gravação somente para o usuário root
e sem permissões para grupo/outros usuários.

Avisando usuários sobre o estouro de quota

Avisos sobre quota ultrapassada podem ser enviadas automaticamente a todos os
usuários pelo utilitário warnquota. Ele poderá ser executado periodicamente
através do cron (por padrão isto é feito diariamente na distribuição Debian
pelo script /etc/cron.daily/quota). Dados adicionais sobre o envio das
mensagens devem ser especificados no arquivo /etc/warnquota.conf seu formato é
o seguinte:

# Programa usado para enviar as mensagens
MAIL_CMD        = "/usr/sbin/sendmail -t"
# Campo de origem da mensagem
FROM            = "root@localhost"
# but they don't have to be:
SUBJECT         = Quota excedida
CC_TO           = "root@localhost"
SUPPORT         = "root@localhost"
PHONE           = "5555-2525"
#

O e-mail é enviado aos usuários (e usuários que pertencem a grupos com a quota
excedida) com o seguinte formato:

From: root@localhost
To: gleydson@debian.gms.com.br
Cc: root@localhost
Reply-To: root@localhost
Subject: Quota Excedida
Date: Sat, 22 Sep 2001 14:27:38 -0400

Hi,

We noticed that you are in violation with the quotasystem
used on this system. We have found the following violations:


                        Block limits               File limits
Filesystem           used    soft    hard  grace    used  soft  hard  grace
/dev/hda5      +-  504944  500100  600000   none   10868     0     0


We hope that you will cleanup before your grace period expires.

Basically, this means that the system thinks you are using more disk space
on the above partition(s) than you are allowed.  If you do not delete files
and get below your quota before the grace period expires, the system will
prevent you from creating new files.

For additional assistance, please contact us at root@localhost
or via phone at 5555-2525.

Suporte a senhas ocultas

Veja “Shadow Passwords”.

Suporte a senhas com algorítmo SHA e md5

Veja “Senhas Sha512, SHA256 e MD5”.

Restrições no hardware do sistema

As restrições descritas aqui são úteis para diminuir as chances de um ataque
por acesso físico ser realizado com sucesso no sistema que desejamos proteger.

Ter um sistema totalmente seguro é praticamente impossível, mas existem
diversas maneiras de se dificultar as coisas.

BIOS do sistema

Algumas restrições podem ser configuradas na para diminuir as chances de se
obter acesso root (usando métodos conhecidos de recuperação via disquete/CD
inicializável) ou simplesmente aumentar nossa confiança no sistema:

  • Coloque uma senha para entrada no Setup da máquina, compartilhe esta senha 
    somente com as pessoas que tem poder de root (ou seja, pessoal de confiança
    que administra a máquina).

  • Mude a seqüencia de partida para somente sua unidade de disco rígido que
    contém o sistema operacional. As BIOS trazem convenções de DOS para
    especificar o método de partida, então Only C quer dizer somente o primeiro
    disco rígido, SCSI tentar dispositivos SCSI primeiro, etc. Isso pode variar
    de acordo com o modelo de sua BIOS.

Com os dois ítens acima qualquer um ficará impedido de inicializar o sistema a
partir de um disco de recuperação ou entrar no Setup para modificar a ordem de
procura do sistema operacional para dar a partida via disquetes.

Retirada da unidade de disquetes

Como não é seguro confiar nas restrições de senha da BIOS (qualquer um com
conhecimentos de hardware e acesso físico a máquina pode abrir o gabinete e dar
um curto na bateria que mantém os dados na CMOS ou aterrar o pino de sinal da
CMOS), a retirada da unidade de disquetes é recomendada, isso dificultará
bastante as coisas.

Placas de rede com eprom de boot

Evite a utilização de placas de rede com recursos de boot via EPROM no
servidor, um servidor dhcp/bootp/tftp poderá ser configurado sem problemas por
um cracker na rede (caso a BIOS esteja com a ordem inadequada de procura de
discos) e o ataque se dar com mais "sofisticação" e rapidez.

Protegendo o LILO

A opção passwd=senha e restricted poderão ser usadas na seção da imagem que
desejamos proteger. Respectivamente pedem uma senha para a inicialização do
sistema e caso argumentos como root=single sejam usados para conseguir acesso
root sem fornecer senha.

E deixe somente as permissões de acesso ao usuário root (caso contrário sua
senha poderá ser vista por qualquer usuário) e modifique os atributos deste
arquivo para imutável para que nem mesmo o root possa modifica-lo: chattr +i /
etc/lilo.conf.

Disco rígido

O disco rígido do servidor poderá se retirado como alternativa para se ter
acesso aos dados armazenados. Isto poderá ser dificultado com o uso de lacres
de disco ou outras maneiras de dificultar mais esta tarefa (mais parafusos,
armazenamento em partes de difícil manipulação do HD, etc) qualquer coisa que
possa lhe fazer ganhar tempo e despertar suspeitas para evitar o sucesso desta
alternativa (ousada).

Dados importantes ou confidenciais poderão ser armazenados em um sistema de
arquivos criptografados e serem montados somente pelos administradores que
possuem acesso físico ao sistema. O algoritmo Serpent é muito forte na proteção
de dados além de possuir um ótimo desempenho. Patches de criptografia poderão
ser aplicados no kernel para ativação deste recurso (veja ???) para detalhes.

Sensores podem ser ligados na carcaça do HD como forma de disparar um pequeno
alarme embutido no gabinete do servidor, se você gosta de eletrônica poderá
montar um destes facilmente para chamar a atenção alimentado por fonte/baterias
em um circuito de emergência, e poderá acomodar sua caixa em uma segunda
"carcaça de fonte" apenas para desviar suspeitas. Um circuito interno de
câmeras também é uma boa alternativa para monitorar a movimentação.

Esquemas de segurança dependendo do porte da organização e dos dados que se
desejam proteger deverão ser elaborados e postos em prática. Todos os métodos
imagináveis deverão ser considerados de acordo com as possibilidades do
ambiente.

Capítulo 7. Criptografia

Índice

Introdução
Introdução aos protocolos SSL e TLS

    SSL
    HTTPS
    Ataque Man in the Middle (MITM)
    TLS

Introdução a Certificados

    Certificados X509
    Validade de Certificados
    CA Intermediária
    Como é gerado um Certificado assinado por CA?
    Tipos de certificados e suas extensões
    A estrutura básica de um certificado?
    Extensões para uso em certificados

Cadeia de confiança de certificados

    Certificado raíz
    Autenticação de Certificado SSL TLS
    Tipos de certificados
    Significado de campos usados em certificados
    Nívels de validação do certificado

openssl

    O arquivo de configuração /etc/ssl/openssl.cnf
    Visualizando conteúdo de um certificado existente
    Convertendo entre formatos de certificados

Gerenciamento de uma CA e de chaves publicas e privadas

    Gerando uma chave RSA de 2048 bits
    Gerando uma chave PKCS8 de 2048 bits
    Exportando a chave RSA publica para arquivo
    Protegendo a chave privada
    Requisitos para gerenciar uma CA
    Criando uma CA privada
    Criando um certificado de CA
    Assinando um arquivo CRT
    Renovando um Certificado
    Revogando um Certificado
    Revogando uma CA
    Gerando um par de chaves RSA a partir da chave privada
    Extraindo a chave pública a partir da chave privada do certificado
    Extraindo elementos texto do certificado
    Gerando uma chave Pública
    Gerando arquivo binário contendo números aleatórios
    Automatizando preenchimento de dados de certificado
    Usando SNI nos domínios
    Encriptando arquivos grandes
    Especificando níveis de validação no Apache
    Enviando um certificado SSL de cliente para testes
    Verificando uma identidade

Certificados Auto-Assinados

    Beneficios de rodar uma CA própria
    Criando Certificados Auto-Assinados
    Concatenando os Certificados gerados
    Configurando o Apache e Virtual Hosts
    Testando a conexão SSL
    Sobre certificados usando Curva Eliptica
    Programas para gerenciamento de CA usando ambiente gráfico e WEB

Teste de cliente/servidor SSL/TLS com openssl

    Servidor OpenSSL
    Cliente OpenSSL
    Cadeia de Confiança
    Testando protocolos que fazem upgrade para TLS
    Extraindo o certificado remoto do cliente
    Usando formatos diferentes de HandShake de conexão
    Testando o suporte a uma versão específica de protocolo SSL
    Testando o suporte a um conjunto de Ciphers
    Testando servidores que requerem SNI
    Testando reuso de conexão no SSL
    Validação de revogação OCSP
    Testando o suporte a OCSP Stapling
    Verificando a revogação de CRL
    Verificando vulnerabilidade HeartBleed
    Determinando o tamanho de parametros DH

Certificados com extensões X509 V3
Alternativas seguras a serviços sem criptografia

    http
    Transmissão segura de e-mails
    Servidor pop3
    Transferência de arquivos
    login remoto
    Bate papo via IRC
    Transmissão de mensagens via ICQ

Usando o GPG para Autenticação e Criptografia

    Instalando o PGP
    Criando um par de chaves pública/privada
    Encriptando Dados
    Decriptando dados com o GPG
    Assinando arquivos
    Checando assinaturas
    Extraindo sua chave pública do chaveiro
    Adicionando chaves públicas ao seu chaveiro pessoal
    Listando chaves de seu chaveiro
    Apagando chaves de seu chaveiro
    Mudando sua FraseSenha
    Assinando uma chave digital
    Listando assinaturas digitais
    Recomendações para a assinatura de chaves GPG

Criptografia de blocos usando DM-Crypt / cryptsetup

    Encriptando um sistema de arquivos com DM-Crypto / cryptsetup
    Desmontando o dispositivo criptografado
    Listando limites e algoritmos suportados
    Avaliando a performance de cada algoritmo
    Opções de encriptação com o DM-Crypt
    Fazendo dump do cabeçalho de dispositivos
    Gerenciamento de chaves
    Backup e Restore de cabeçalho/chaves
    Convertendo automaticamente sistemas para criptografia e desconvertendo
    Convertendo a partição para Criptografica

Criptografia de arquivos usando ENCFS

    Limitações
    Instalando
    Criando a Criptografia
    Alterando a senha
    Montando via fstab

Usando o eCryptfs para encriptar arquivos, montagem automatica do home

    Configurando o ecryptfs
    Remontando o sistema de arquivos criptografado
    ecryptfsd
    Diretório Privado Automático para o usuário
    Migrando o home do usuário para criptografado
    PAM ecryptfs
    Limitações do eCryptfs

Criptografia usando TrueCrypt/VeraCrypt

Esta capítulo documenta os conceitos, configuração, utilização e manutenção de
um ambiente utilizando criptografia para proteção de seus dados pessoais ou em
nuvem. Com isso, você poderá tanto proteger um sistema local (seu PC/Notebook),
ou um sistema que hospede em nuvem pública (Amazon, Google Cloud, Azure,
Digital Ocean, etc.).

Introdução

A Criptografia basicamente tem o objetivo de proteger dados contra acesso
indevido. Existem diversas formas de criptografia que podem ser utilizados para
proteger dados, isso dependendo do seu armazenamento:

Como exemplo, quando acessa um site usando SSL, basicamente você está um canal
criptografado e seguro, para que ninguém que esteja nos saltos entre sua origem
e destino consiga capturar o tráfego sento trocado.

  • Arquivo, partições, disco - Protege contra acesso indevido de dados do
    sistema local. Alguns exemplos de criptografia em sistemas de arquivos: GPG
    , TrueCrypt, DM-Crypto, eCryptFS.

  • Rede - Protege contra acesso indevido aos dados sendo transmitidos entre
    origem e destino. Exemplos de criptografia de rede para transmissão de
    dados segura: SSL, VPN, Tuneis criptografados, etc.

  • Integridade - Mecanismos de criptografia podem também podem ser usados para
    garantir a integridade de dados ou atuar também em outras frentes, como a
    criptografia de arquivos como é o caso do GPG. O GPG pode ser usado tanto
    para assinar um arquivo transmitido por e-mail (garantindo que a fonte é
    quem diz ser), criptografar um arquivo e transmitir por um canal inseguro
    (assim somente o destinatário da mensagem poderá acessar o conteúdo), ou
    criptografar localmente um arquivo ou pasta. Outras formas de integridade
    de sistemas incluem AIDA e Tripwire.

Introdução aos protocolos SSL e TLS

Esta sessão documenta as versões e protocolos utilizados no TLS, SSL e suas
características e limitações. O objetivo é auxiliar a você na escolha dos mais
seguros e riscos da utilização de versões legadas.

SSL

O SSL (Secure Sockets Layer) permite a comunicação segura entre servidor e
usuários, via canal de criptografia seguro. Tal conexão tem vários benefícios:

  • Protege dados sensíveis que trafegam entre servidor e navegador, como
    logins, senhas

  • Protege contra o acesso indevido de criminosos e quer intruso

  • Protege, contra captura e consequentemente uso de dados pessoais, como
    número de cartões de crédito, dados financeiros, endereços e nomes

  • Protege os dados contra mdoificações indevidas durante o transito entre
    origem e destino na rede

O SSL embaralha os dados transferidos, tornando impossível sua leitura por
crackers. Apenas se o invasor obtiver a chave de criptografia, ele conseguirá
acesso ao conteúdo.

Para fazer a negociação de conexão, o protocolo SSL estabelece uma relação de
confiança entre origem (muitas vezes seu navegador web) e destino para proteger
uma conexão. Um certificado conecta o domínio, servidor e hostname a uma
identidade que pode ser corporativa ou pessoal. O certificado é instalado no
servidor web da organização, e quando o usuário acessa o website seguro,
fornecendo conexão segura entre o navegador do usuário e servidor.

Para estabelecer essa relação de confiança, um certificado SSL é emitido por
uma CA confiável (ou uma origem confiável), onde a CA autentica a o destino
utilizando métodos de confirmação da identidade ou posse do domínio, e-mail, da
identidade, etc.

Quando um certificado é gerado, geralmente ele possui os seguintes campos:

  • issued to

    Para quem o certificado foi emitido
  • issued from

    Quem emitiu o certificado
  • start date

    Data inicial no qual o certificado é válido
  • expire date

    Data final de validade (expiração) do certificado
  • domain name

    Domínio onde o certificado é válido
  • CA name

    Nome da entidade certificadora

HTTPS

O HTTPS é um protocolo para comunicação segura sobre HTTP. Esta comunicação é
feita dentro de uma conexão que é encriptada utilizando TLS ou SSL.

Se um website tem um certificado SSL, a URL inicia com https:// ao invés de 
http://, ela também terá um símbolo de cadeado, indicando maior proteção. Caso
clique no símbolo de cadeado na barra do navegador, você conseguirá obter
detalhes do certificado.

Ataque Man in the Middle (MITM)

O HTTPS protege contra ataques man-in-the-middle, espionagem de conexão, data
tampering (alteração) do conteúdo entre o website e usuários. Por outro lado, o
HTTP (Hyper Text Transfer Protocol) é vulnerável a estes tipos de ataques, por
utilizar a comunicação usando texto plano.

Com o HTTP, invasores podem acessar as contas do website e informações
sensíveis, e injetar um malware e outros arquivos maliciosos no website. Desta
forma, transações usando dados sensíveis (senhas, cartões de crédito, códigos
de autenticação, etc) devem ser protegidos usando HTTPS.

Hoje em dia, o HTTPS se tornou extremamente importante para protegir todos os
tipos de sites, devido ao aumento de website atacados. Você nâo deve apenas
proteger os sites, mas também proteger a privacidade da comunicações de
usuários, informações e identidadees.

TLS

O TLS (Transport Layer Security), que é uma versão atualizada e mais segura do 
SSL. Atualmente ele se encontra na versão 1.3 (lançada em Agosto de 2018, e
coberto na RFC 8446). Assim como o SSL, o TLS fornece autenticação e
encriptação de dados entre máquinas, servidores e aplicações.

O TLS foi desenvolvido para substituir o SSl versão 2, devido a diversas
vulnerabilidades que haviam sido descobertas na época. Sua primeira versão (a 
TLS 1.0) foi lançada em 1999, e após isso surgiu o SSL 3.0. A versão 1.3 foi
diretamente ligada a equipe de engenharia da CloudFlare e sua primeira
implementação foi no navegador Firefox 52, sendo ativado por padrão.

A nova versão 1.3 do TLS é mais rápida que a TLS 1.2, e também eliminou falhas
de segurança da versão anterior.

Algumas características notáveis do TLS 1.3 incluem:

  • As diretivas antigas e inseguras de criptografia foram completamente
    removidas

  • A construção usando técnicas analiticas modernas o tornam seguro

  • Sempre usar PFS, significando que cada sessão é protegida separadamente
    desde que não exista chave em comum, dando assim melhor proteção caso o
    tráfego for interceptado ou a chave de um certificado já usado muito tempo
    for exposto.

  • Encripta mais dados comparado ao TLS 1.2

  • Mais rápido que o TLS 1.2

  • Somente usa ciphers seguros (ChaCHA-Poly e AES-GCM), facilitando a proteção
    e configuração de aplicativos que são seguros por padrão.

  • Possui o modo 0-RTT, removendo o round-trip da latência de handshake. Isto
    é possível através de métodos inovadores de reuso de conexões já
    existentes.

A remoção suporte a ciphers antigos e quebrados de criptografia resultaram no 
TLS 1.3 ser um padrão bem mais seguro que o TLS 1.2 . Desta forma as falhas que
permitiam tais ataques foram removidas, dificultando a exploração por crackers

O TLS 1.3 possui características que o tornam mais rápido em Streaming, dando
aos usuários uma melhor experiẽncia de navegação web.

Devido a essas inovações, as maiores empresas como Google, Mozilla, Akamai,
CloudFlare, foram as primeiras a adorarem o uso de TLS 1.3, e também
assegurando o uso de software mais atualizados em seu ambiente.

Como viu, a atualização de softwares e tecnologias não servem apenas para
ganhar novos recursos, mas também auxilia na proteção do ambiente e redução de
riscos de segurança, caso estas técnicas não sejam adotadas.

Introdução a Certificados

Certificados X509

Certificados X509 tem basicamente a função de permitir a navegação segura de
protocolos de internet (como web, email, XMPP, VPN, etc). Certificados podem
também garantir a segurança de documentos (via assinatura digital) e da
comunicação de aplicativos que também ficam desconectados da internet (como
entre microserviços).

Certificados também podem identificar a validade de usuários (ao invés de
hosts), permitindo que os mesmos tenham a identidade confirmada (equivalente a
um CPF digital). Ele basicamente opera segundo o padrão de chave pública e
chave privada: A chave privada fica de posse do usuário ou servidor, e a
pública pode ser distribuida a sistemas na internet ou carregada pelo cliente
para garantir uma segura negociação de conexão entre o cliente e servidor.

De onde vem os certificados? eles podem ser emitidos por uma entidade
certificadora credenciada (que chamamos de CA) ou eles podem ser gerados por
você (neste caso chamados de certificados auto-assinados). Toda emissão de
certificado passa por um criterioso processo de validação e emissão (conforme o
tipo de certificado comprado) desta forma, quando um certificado é assinado por
uma CA confiável, seu site, e-mail, etc nao emitirão qualquer alerta sobre a
identidade do sistema que está acessando, pois ele validará a autenticidade de
quem emitiu e do certificado.

Validade de Certificados

Existe uma camada adicional de segurança de certificados, que identificam o
período que ele é válido: O certificado permite uma data inicial e final de
validade. É claro que o padrão assume que falhas de sistemas e humanas podem
ocorrer, e por isso foi criado um certificado especial, agregado ao principal
chamado de Lista de Revogação de Certificados (CRL).

CA Intermediária

Uma CA intermediária, é basicamente um certificado criado pelo certificado
raíz, que pode criar novos certificados. A validação é feita usando uma cadeia
de validação de confiança.

OBS - A versão 3 do X509 suportar estruturas de autenticação da cadeia de
confiança, como bridges e mesh.

Como é gerado um Certificado assinado por CA?

Quando acessa sites como o Página Oficial do guia Foca GNU/Linux pelo seu
navegador, provavelmente observará que é mostrado um cadeado ao lado da URL, e
não é emitido qualquer alerta sobre a confiança do certificado. Esse cadeado
indica que o site foi autenticado por uma CA válida (como CertSign, AlphaSSL, 
LetsEncript), e está dentro da validade. Mas qual é o passo a passo para que
isso aconteça?

 1. A primeira etapa é gerar um par de chaves, que ficará em sua posse. A
    partir dessas chaves, emitiremos um tipo especial de certificado, chamado
    de Requisição de Assinatura de Certificado (CSR - Certificate signing
    request).

 2. Após isso, o CSR deverá ser enviado para a entidade certificadora
    escolhida. A CSR contém os dados pessoais do requerente preenchidos no
    certificados e o subject (domínio) que o certificado protegerá. Após a
    validação e comprovação de autenticidade dos dados, a CA lhe enviará o
    certificado assinado pela chave privada da CA, com um prazo de validade
    determinado.

 3. O certificado assinado então será instalado no servidor web, garantindo o
    acesso seguro a clientes que estão fazendo acesso ao mesmo

Tipos de certificados e suas extensões

Os tipos mais comuns e extensões de certificados seguem abaixo:

  • .pem – É um dos mais comuns, e geralmente começam com "-----BEGIN
    CERTIFICATE-----" and "-----END CERTIFICATE-----". O PEM (Privacy-enhanced
    Electronic Mail) Basicamente é um certificado DER com encode Base64.

  • .cer, .crt, .der – Geralmente em formato DER binário, mas também usando
    Base64 como encoder are common too (see .pem above)

  • .p7b, .p7c – Dados estruturados e assinados PKCS#7 sem dados, apenas
    certificados ou CRLs.

  • .p12 – O PKCS#12, poder conter certificados público ou privados e chaves
    (protegidos por senha).

  • .pfx – Veio antes do PKCS#12 (geralmente contém dados no formato PKCS#12,
    geralmente usado no IIS.

A estrutura básica de um certificado?

Um certificado X509 padrão possui a seguinte estrutura:

    Certificate
        Version Number
        Serial Number
        Signature Algorithm ID
        Issuer Name
        Validity period
            Not Before
            Not After
        Subject name
        Subject Public Key Info
            Public Key Algorithm
            Subject Public Key
        Issuer Unique Identifier (optional)
        Subject Unique Identifier (optional)
        Extensions (optional)
            ...
    Certificate Signature Algorithm
    Certificate Signature

Entre os campos acima, os mais importantes são:

  • Issuer Name - Nome da CA que emitiu o certificado

  • Subject - Endereço solicitante do certificado

  • Validity - Validade do certificado. O Not Before impede que o certificado
    seja usado antes da data determinada. O Not After impede que ele seja usado
    após a data determinada.

  • Extensions - Estrutura documentada na RFC 1422, indicando que extensões
    podem ser usadas, geralmente contémum conjunto de valores que são
    classificados como criticos ou não-criticos. Caso seja encontrado uma
    extensão crítica faltando, o processamento será finalizado. Erros 
    não-críticos podem ser ignorados se não forem reconhecidos (mesmo assim são
    processados como válidos).

Extensões para uso em certificados

Basicamente as extensões do SSLv3 são divididos em:

  • Politicas Básicas - São usados para indicar se o certificado pertemce a uma
    CA

  • Uso da Chave - Prove a especificação de operações de criptografia que podem
    ser feitas usando a chave pública contida no certificado: por exemplo, pode
    indicar que a chave pode ser usads para assinatura mas não para
    criptografia.

  • Uso de chave Extendido - É usado tipicamente nos últimos certificados
    emitidos na cadeia, para indicar o propósito de uma chave ocntendo o
    certificado.

O RFC 5280 traz detalhes e exemplos específicos do certificado contendo ambos 
keyUsage e extendedKeyUsage.

Cadeia de confiança de certificados

Nesta seção, faremos a explicação sobre como funciona a cadeia de confiança
utilizado em certificados, abrangendo os temas: Certificado raíz, certificado
TLS.

Certificado raíz

O certificado raíz é basicamente conhecido por muitos como CA. Entre as CA's
podemos citar: Certsign, Microsoft, Let's encrypt, Trustsign, etc. O que
diferencia um certificado raíz (CA) de um certificado convencional? Basicamente
o campo issuer e subject são os mesmos. Certificados auto-assinados também
possuem essa característica, a validação é feita pela distribuição do
certificad para outros sistemas operacionais, navegadores, etc. Isso diferencia
um certificado auto-assinado de um certificado CA oficial, pois este último é
distribuido para navegadores e sistemas operacionais automaticamente para
autenticar qualquer certificado gerado por sua chave pública.

Autenticação de Certificado SSL TLS

Em sistemas TLS, é necessário que o servidor envie um certificado como parte do
handshake. No caso de conexões vindas de clientes, ocorrerá o seguinte caminho
de validação do certificado:

  • O subject do certificado deve conferir com o hostname que o cliente está se
    conectando

  • O certificado está assinado por uma entidade certificadora confiável

O nome de host principal (primário) do website será listado como Common Name
(CN), no campo Subject do certificado. Um certificado pode ser válido para
múltiplos hostnames (ou diversos websites).

Certificados que possuem múltiplos nomes de hosts, são chamados de certificados
SAN: Subject Alternative Names. ou Unified Communications Certificates (UCC).
Estes certificados contém o campo Subject Alternative Name, assim mais CAs
podem também ser colocadas no campo Subject Common Name do certificado para
garantir retro-compatibilidade. Caso um dos hostnames contém um * o certificado
também será chamado Certificado Wildcard.

Tipos de certificados

Aqui explicaremos a diferença entre os diversos tipos de certificados e onde
eles podem ser usados

Certificado de clienteTLS/SSL

Os certificados usados para clientes autenticam um serviço ao invés de um
servidor ao serviço remoto, garantindo mais segurança e granularidade que a
autenticação por host. Seu uso é bem menos comum (as vezes chega a ser
desconhecido) em comparação a certificado de servidores. Basicamente ele
autentica o cliente ao servidor remoto de forma segura (substituindo ou
complementando a autenticação via credenciais, token ou cookies).

Como forma de garantir mais segurança (e redução de custos), pode ser utilizado
certificados Auto assinados para fazer a autenticação deste tipo de conexão.
Para detalhes, veja a “Certificados Auto-Assinados”.

Certificado de Emails

Para aumento da segurança de e-mails, geralmente é utilizado certificados S/
MIME. Esta técnica consiste que os remetentes possuem previamente a chave
pública do destinatário, geralmente obtida por um certificado de e-mail ou
autoridade de certificações confiáveis publicamente para e-mail. O uso mais
comum é o uso de S/MIME dentro de uma empresa.

Uma outra técnica usando GPG pode ser usada para substituir o uso de S/MIME no
e-mail, além de expandir as possibildiades de autenticação usando cadeia de
confiança. Veja detalhes em “Usando o GPG para Autenticação e Criptografia”.

Assinatura de código

Uma das utilizações de certificados é durante a validação de assinatura de
programas para ter certeza que eles não foram alterados no momento da etnrega.
A autenticação é apenas um exemplo de um esquema de assinatura de código.

Certificado Qualificado

Este é um tipo de certificado que está ganhando popularidade aos poucos no
Brasil, geralmente emitido pela SERASA para criar uma identificação chamada de 
CPF ou CNPJ Digital.

Tipicamente é usado para assinatura eletronica em sites do governo, e até
documentos, sendo bastante comum na Europa.

Certificado CA raíz

Este certificado é um certificado auto-assinado (o campo subject é o mesmo do 
issuer), sendo é usado para assinar outros certificados, e criando uma relação
de confiança quando distribuido no repositório de navegadores, sistemas
operacionais, etc.

Certificado Intermediário

Este é um certificado assinado por um certificado raíz (veja “Certificado CA
raíz”) ou outro certificado intermediário e serve apenas para assinar outros
certificados.

Certificado Final

Este certificado é designado apenas a utilização em servidores, clientes,
e-mails, assinatura de código, e não pode ser uitlizado para criar e assinar
outros certificados.

Certificado Auto-Assinado

Basicamente é um certificado onde o campo issuer (Emissor) é igual ao subject
(assunto), podendo validar a assinatura com sua chave pública. Ele não possui
uma cadeia de confiança pública, mas isso não quer dizer que sejam menos
seguros.

Significado de campos usados em certificados

Certificados X.509 possuem campos que definem os parametros de cadeia de
confiança, validade e identidade. Seguem a apresentação de alguns campos usados
na identificação de certificados:

Not Before

    Intervalo inicial de validade do certificado. Antes desta data/hora o
    certificado não estará válido. Geralmente configurado com alguns dias ou
    horas antes do momento que o certificado foi emitido, para evitar problemas
    de configuração do relógio.

Not After

    Data e hora de expiração do certificado. Após este intervalo, o certificado
    será exibido como expirado no navegador ou sistema que utiliza para
    autenticação.

Subject

    Nome da máquina, da pessoa ou organização que recebeu o certificado.

Issuer

    Identificação da entidade que emitiu e assinou o certificado.

Serial Number

    O número serial é usado para identifição e revogação de um certificado
    dentro de um sistema de uma CA.

Key Usage

    Determina os usos válidos para a chave pública. Valores geralmente usados
    incluem validação de assinatura, codificação da chave e assinatura de
    certificado.

Extended Key Usage

    Uso extendido da chave indica as aplicações onde o certificado pode ser
    usado. Normalmente encontramos nesse campo assinatura de e-mail, assinatura
    de código e autenticação com servidores.

Public Key

    A chave pública que foi gerada para o dono do certificado.

Signature Algorithm

    Algoritmo usado para assinar a chave pública do certificado.

Signature

    Corpo de assinatura do certificado (assinado pela chave privada do issuer)

Nívels de validação do certificado

Validação de Domínio - DV

A entidade certificadora emite um certificado de validação de dominio (DV) para
quem provar que possui direito a gerenciar um domínio

Validação de Organização - OV

A entidade certificadora emite um certificado de Validação de Organização (OV)
desde que atenda dois requisitos:

  • O direito de gerenciar administrativamente o domínio listado

  • Ser o representante legal da entidade

Validação Extendida - EV

Para conseguir um certificado de validação extendida, o comprador precisa
provar ao emissor de certificao os seguintes pontos:

  • Sua identidade oficial, com verificação feita por outras pessoas.

Assim como certificados OV (veja “Validação de Organização - OV”) o emissor
pode definir critérios para proibir a emissão de acordo com sua politica de
certificação.

Quando você acessa um site com EV, o navegador exibe um aviso diferente
comprovando que o site possui um certificado de validação extendida.

OBS: Alguns navegadores mais modernos não diferenciam mais na barra de
endereços certificados EV de certificados convencionais, exibindo somente este
detalhamento ao solicitar exibir os dados de certifidos.

openssl

O openssl é uma ferramenta que permite criar/remover/alterar certificados,
assim como exibir dados de certificados já criados. Assim você poderá obter
facilmente dados sobre expiração de certificados, CA emissora, dados do
utilizador, etc.

O openssl também pode ser usado como ferramenta proxy, adicionando encriptação
a serviços não criptografados existentes.

As seguintes opções podem ser usadas no openssl:

-in [arquivo]

    Especifica o arquivo de origem (entrada)

-out [arquivo]

    Especifica o arquivo de destino (saída). Caso nao seja especificado, o
    certificado será enviado para a saída padrão.

-keyout

    Especifica o arquivo destino da chave privada quando estiver sendo gerado
    um CSR.

-nodes

    Remove a senha do certificado. Utilizado principalmente em exportações e
    conversões

-topk8

    Grava o formato de chave de privada no formato PKCS #8

-inform [formato]

    Especifica o formato de entrada. Válidos PEM (Privacy Enhanced mail) ou DER
    (binário)

-outform [formato]

    Especifica o formato de saída. Válidos DER/PEM.

-sha256

    Especifica o uso do algoritmo sha256 para certificados recém gerados

-nocrypt

    Não adiciona criptografia na geração da chave privada no formato
    PrivateKeyInfo

-nocrl

    Não cria um certificado de revogação (CRL) durante a operação

-pubout

    Especifica que deve ser escolhida a chave publica para saída (por padrão
    será usada a privada).

-CA

    Especifica o certificado de CA

-CAkey

    Especifica a chave privada da CA para assinar o certificado

O arquivo de configuração /etc/ssl/openssl.cnf

Possui valores padrões para os certificados gerados e comportamento geral do
Openssl. Pode ser modificado conforme necessidade:

signer_digest  = sha256                 # Signing digest to use. (Optional)
default_policy  = tsa_policy1           # Policy if request did not specify it
                                        # (optional)
other_policies  = tsa_policy2, tsa_policy3      # acceptable policies (optional)
digests     = sha1, sha256, sha384, sha512  # Acceptable message digests (mandatory)

Sessões do arquivo:
[new_oids]
[ca]
default_ca      = CA_default

# Configuracao especificando uma CA default
[CA_default]
policy          = policy_match

# Configuracao de include para uma policy externa
[policy_match]

[policy_anything]

[req]
distinguished_name      = req_distinguished_name
attributes              = req_attributes
x509_extensions = v3_ca # The extensions to add to the self signed cert

[req_distinguished_name]
countryName                     = Country Name (2 letter code)
countryName_default             = AU
countryName_min                 = 2
countryName_max                 = 2

stateOrProvinceName             = State or Province Name (full name)
stateOrProvinceName_default     = Some-State

localityName                    = Locality Name (eg, city)

0.organizationName              = Organization Name (eg, company)
0.organizationName_default      = Internet Widgits Pty Ltd

# we can do this but it is not needed normally :-)
#1.organizationName             = Second Organization Name (eg, company)
#1.organizationName_default     = World Wide Web Pty Ltd

organizationalUnitName          = Organizational Unit Name (eg, section)
#organizationalUnitName_default =

commonName                      = Common Name (e.g. server FQDN or YOUR name)
commonName_max                  = 64

emailAddress                    = Email Address
emailAddress_max                = 64

[ req_attributes ]
challengePassword               = A challenge password
challengePassword_min           = 4
challengePassword_max           = 20

[usr_cert]
# usado para assinatura de requisições da 'ca'
# Se definido para 'server' o certificado gerado pode ser usado para assinar
# outros certificados
nsCertType = server

nsCertType = client, email, objsign

nsComment = "Openssl Generated Certificate"

[v3_req]
[v3_ca]
[crl_ext]
[proxy_cert_ext]
[tsa]
default_tsa = tsa_config1       # the default TSA section

[tsa_config1]

Visualizando conteúdo de um certificado existente

Para visualizar o conteúdo, execute o seguinte comando:

openssl x509 -in certificado.pem -text -noout

A saída será algo como essa (utilizando o certificado antigo da SpiritSec, que
expirou no dia 10/Julho de 2020 como exemplo). Note principalmente a validade
(Validity) do certificado, e que se trata de um certificado Wildcard (devido
conter * no campo Subject):

Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            01:50:c8:79:b1:65:8c:85:5a:ec:b8:fd
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: C = BE, O = GlobalSign nv-sa, CN = AlphaSSL CA - SHA256 - G2
        Validity
            Not Before: Jul 10 00:20:36 2019 GMT
            Not After : Jul 10 00:20:36 2020 GMT
        Subject: OU = Domain Control Validated, CN = *.spiritsec.com
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:c1:6a:fd:06:af:cf:d2:36:f3:e3:92:9f:c8:20:
                    36:9a:90:c0:a5:eb:7e:14:dd:a9:b4:28:c0:23:f2:
                    de:0b:38:5c:bd:79:23:5c:ab:5b:00:c8:3c:a2:0d:
                    29:e4:0f:8a:34:46:ea:44:48:69:59:78:b9:fa:39:
                    fd:2c:44:19:34:6e:49:94:3b:74:5b:03:63:2a:ac:
                    33:82:4e:0d:8f:31:d0:05:5c:7e:29:a7:13:9e:2c:
                    3c:c3:90:a4:ba:de:f3:47:c2:81:95:99:ce:5f:21:
                    e3:6c:63:1b:0b:25:64:f4:f5:60:cc:da:0d:43:9f:
                    fc:87:60:a1:00:fd:ef:6d:77:d9:8d:4f:ef:56:93:
                    20:f2:18:26:2b:0b:42:89:33:15:a4:e9:e8:e5:e4:
                    03:79:4b:a2:e5:ec:87:88:d1:7c:60:3a:1e:03:d1:
                    83:2b:46:06:36:71:d8:2b:9a:eb:e9:b7:c9:eb:9f:
                    ef:d0:fe:3b:b1:05:0d:9f:19:b2:92:8d:39:9f:f1:
                    32:4c:1b:99:c5:2d:e7:57:4e:d0:54:82:8a:c5:33:
                    02:9c:92:32:15:30:18:b1:09:f7:c7:9d:5f:9d:58:
                    27:9b:9e:af:92:5d:4a:16:da:bd:44:2e:3e:e1:4b:
                    8e:19:07:ec:51:3f:c1:a3:c8:e0:7c:ad:42:df:99:
                    17:17
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Key Usage: critical
                Digital Signature, Key Encipherment
            Authority Information Access:
                CA Issuers - URI:http://secure2.alphassl.com/cacert/gsalphasha2g2r1.crt
                OCSP - URI:http://ocsp2.globalsign.com/gsalphasha2g2

            X509v3 Certificate Policies:
                Policy: 1.3.6.1.4.1.4146.1.10.10
                  CPS: https://www.globalsign.com/repository/
                Policy: 2.23.140.1.2.1

            X509v3 Basic Constraints:
                CA:FALSE
            X509v3 CRL Distribution Points:

                Full Name:
                  URI:http://crl2.alphassl.com/gs/gsalphasha2g2.crl

            X509v3 Subject Alternative Name:
                DNS:*.spiritsec.com, DNS:spiritsec.com
            X509v3 Extended Key Usage:
                TLS Web Server Authentication, TLS Web Client Authentication
            X509v3 Authority Key Identifier:
                keyid:F5:CD:D5:3C:08:50:F9:6A:4F:3A:B7:97:DA:56:83:E6:69:D2:68:F7

            X509v3 Subject Key Identifier:
                0B:98:A0:CD:B3:93:41:61:A5:37:0E:05:D9:AA:0B:53:5F:92:86:6D
            CT Precertificate SCTs:
                Signed Certificate Timestamp:
                    Version   : v1 (0x0)
                         Log ID    : BB:D9:DF:BC:1F:8A:71:B5:93:94:23:97:AA:92:7B:47:
                                38:57:95:0A:AB:52:E8:1A:90:96:64:36:8E:1E:D1:85
                    Timestamp : Jul 10 00:20:39.213 2019 GMT
                    Extensions: none
                    Signature : ecdsa-with-SHA256
                                30:45:02:20:75:92:F7:4B:D0:27:02:91:FF:7E:5A:29:
                                04:8B:6A:62:9A:8F:0B:EF:84:CB:1D:72:5D:44:94:1D:
                                EA:D2:35:CB:02:21:00:FB:26:85:E1:1F:B7:99:83:A6:
                                13:D0:68:17:2C:35:A3:9E:B6:77:F1:D0:30:6C:F8:74:
                                A6:41:E8:08:42:99:09
                Signed Certificate Timestamp:
                    Version   : v1 (0x0)
                    Log ID    : 87:75:BF:E7:59:7C:F8:8C:43:99:5F:BD:F3:6E:FF:56:
                                8D:47:56:36:FF:4A:B5:60:C1:B4:EA:FF:5E:A0:83:0F
                    Timestamp : Jul 10 00:20:39.109 2019 GMT
                    Extensions: none
                    Signature : ecdsa-with-SHA256
                                30:45:02:20:17:E9:CC:4F:6D:03:54:B0:CC:45:C4:86:
                                2E:AD:E5:E2:66:3C:97:3A:0D:19:0D:4C:4A:51:6D:3F:
                                27:17:B9:D3:02:21:00:CB:B5:FF:AF:49:E0:9A:7E:A1:
                                D0:20:6C:76:65:78:73:9D:A4:5A:4E:3A:2C:43:3D:0C:
                                1D:62:90:70:67:87:5E
    Signature Algorithm: sha256WithRSAEncryption
         7c:4a:8b:00:b9:39:c8:c6:eb:ae:57:45:d0:6e:00:71:e1:92:
         8e:16:f2:88:ae:36:59:1b:9c:45:e6:10:30:b2:75:e4:bd:01:
         0e:df:58:1e:cd:86:7a:4b:c7:a4:75:82:36:cd:8c:f7:02:81:
         c8:92:4f:50:94:0f:8e:20:e7:fd:90:25:74:60:e2:e2:c6:df:
         f5:a9:fd:35:4a:39:a4:22:6d:d4:08:3c:e5:83:5d:80:07:e7:
         e1:e2:09:b6:f4:37:6b:06:29:60:a3:29:41:9c:08:b1:75:73:
         db:a9:c3:92:7a:55:3e:76:6c:66:b1:17:30:97:63:77:f6:a3:
         9c:6c:5b:90:37:75:0b:58:98:49:de:8a:b5:0b:5e:79:50:70:
         76:1d:cc:4e:be:7a:bf:9a:69:d8:fa:12:73:bd:7d:2b:52:ba:
         0d:fa:04:9a:ba:fd:d9:07:eb:5c:62:ab:01:34:21:49:59:bc:
         3a:f2:0a:2e:62:84:1b:e8:a7:b0:bb:da:2c:0c:05:0f:4d:ea:
         a8:6b:b1:6a:e9:90:36:86:8f:fd:e2:20:a3:ca:4b:b9:7d:73:
         d3:00:3c:c6:a5:ad:e6:45:eb:d1:6c:ac:1f:12:99:68:4d:86:
         70:a7:d4:ee:5c:dd:47:a4:3a:3f:1c:f1:36:53:e5:b8:ee:b6:
         34:b5:71:2a

Convertendo entre formatos de certificados

Geralmente quando cria, ou compra um certificado, você receberá ele no formato
apropriado para usado em seu servidor web ou aplicação, por exemplo, crt, e key
para servidor web Apache e NGINX. Mas se você trocar de servidor web para algo
que rode Java? o que faria?

Geralmente a conversão é feita usando o PEM como formato base. Por exemplo,
para converter de PFX para DER, deve ser convertido primeiro o PFX para PEM e
depois convertido o PEM para DER, obtendo o resultado final.

Esta sessão documenta extamente os procedimento usado para a conversão entre
cada formato de certificado.

PEM para DER

Para converter de PEM para DER:

$ openssl x509 -outform der -in certificado.pem -out certificado.der

PEM para P7B (PKCS7)

Para converter de PEM para P7B (PKCS7)

$ openssl crl2pkcs7 -nocrl -certfile certificado.cer -out certificado.p7b
-certfile CAcert.cer

PEM para PFX (PKCS12)

Para converter de PEM para PFX (PKCS12)

$ openssl pkcs12 -export -out certificado.pfx -inkey privateKey.key -in
certificado.crt -certfile CAcert.crt

DER para PEM

Para converter de DER para PEM

$ openssl x509 -inform der -in certificado.cer -out certificado.pem

P7B (PKCS7) para PEM

Para converter de P7B (PKCS7) para PEM

$ openssl pkcs7 -print_certs -in certificado.p7b -out certificado.pem

P7B (PKCS7) para PFX

Para converter de P7B (PKCS7) para PFX

$ openssl pkcs7 -print_certs -in certificado.p7b -out certificado.pem

$ openssl pkcs12 -export -in certificado.pem -inkey privateKey.key -out
certificado.pfx -certfile CAcert.cer

PFX para PEM

Para converter de PFX para PEM

$ openssl pkcs12 -in certificado.pfx -out certificado.cer -nodes

OBS: - Durnate a conversão para o formato PEM, o openssl colocará todos os
certificados e também a chave privada em um mesmo arquivo. Você precisará
separar o conteúdo para arquivos individuais (removendo as linhas que começan
com BEGIN e END) para arquivos separados, salvando-os com certificado.pem,
CAcert.crt e privatekey.key.

PFX para DER

Para converter de PFX para DER, siga os passos em “PFX para PEM” e em seguida
os passos de “PEM para DER”.

DER para PFX

Para converter de DER para PFX, siga os passos em “DER para PEM” e em seguida
os passos de “PEM para PFX (PKCS12)”.

Gerenciamento de uma CA e de chaves publicas e privadas

Nesta seção, você encontrará detalhes desde como Criar uma CA privada, os
Procedimentos usados por uma entidade certificadora.

Gerando uma chave RSA de 2048 bits

Siga o procedimento abaixo para gerar uma chave privada 2048. Caso deseje gerar
uma chave mais forte, substitua 2048 por um número maior (como 3072, 4096):

openssl genrsa -des3 -out chave_privada.pem 2048

Gerando uma chave PKCS8 de 2048 bits

Para gerar um certificado PKCS8, siga o seguinte procedimento:

openssl genrsa 2048 | openssl pkcs8 -topk8 -out servidor.key

OBS: Note que certificados PKCs8 iniciam com -----BEGIN ENCRYPTED PRIVATE
KEY-----.

Exportando a chave RSA publica para arquivo

Siga o procedimento abaixo para exporta a chave RSA pública para arquivo:

openssl rsa -in chave_privada.pem -outform PEM -pubout -out chave_publica.pem 
openssl rsa -in chave_privada.pem -outform PEM -pubout > chave_publica.pem

É importante SEMPRE especificar o parametro -pubout, pois o padrão é exportar a
chave privada. Tenha certeza de incluílo!

Próximo passo, abra o chave_publica.pem e tenha certeza que ele começa com

-----BEGIN PUBLIC KEY-----

. Este é como o formato de arquivo de chaves pública se parece.

Desta forma, caso deseje exportar uma chave privada, remova o -pubout:

openssl rsa -in chave_privada.pem -out private_unencrypted.pem -outform PEM

Com o comando acima, a chave gerada iniciará com a strings:

-----BEGIN RSA PRIVATE KEY-----

As chaves geradas são encodificadas em base64 em formato texto plano. Caso
selecione uma senha para a chave privada, o arquivo será encriptado com sua
senha. Caso perca a senha o par de chave se tornará inútil.

Protegendo a chave privada

Dependendo do nível de proteção de dados que deseja proteger, é importante
manter a chave privada em um backup e segura. A chave pública pode ser
distribuida e embutida em aplicações web, como PHP, Ruby e outros scripts.

Para relizar o backup de uma chave privada, veja as tecnicas em “Exportando a
chave RSA publica para arquivo”

Requisitos para gerenciar uma CA

Basicamente, uma entidade que funciona como CA, precisa obedecer os seguintes
requisitos abaixo para permitir o gerencimaento de forma segura dos
certificados gerados:

 1. Você deve publicar o certificado root da CA, assim ele poderá ser instalado
    em larga escala pelos aplicativos

 2. Você deve publicar o arquivo CRL

 3. Você deve publicar detalhes do certificado, fornecendo seu número serial

 4. Você deverá prover um formulário digital para os usuários enviarem
    requisições de certificados

É claro que um sistema que gerenciam uma CA possuem diversas camadas de
segurança, passando por diversos checks para emissão, registro de acesso e
armazenamento por longos períodos (pelo menos igual o equivalente ao tempo de
emissão do seu maior certificado), qual canal foi solicitada a emissão, e o
certificado emitido apenas após as validações de consistencias adequadas.
Validação de certificados de identidade deve ser feita criteriosamente por mais
de uma pessoa devidamente habilitadas para operação segura dos procedimentos e
um conjunto de automações que gerenciam os ítens acima (como anúncio de CRL na
web).

Criando uma CA privada

Vamos seguir passo a passo, com o procedimento para criação de uma CA privada,
desde a chave, CSR até a geração do certificado. Começaremos pela geração da
chave privada da CA. Execute o seguinte comando:

openssl req -new -newkey rsa:2048 -nodes -out ca/ca.csr -keyout ca/ca.key
-sha256

Onde:

  • 2048 - É o tamanho da chave, quanto maior, mais segurança e mais lento nas
    operações de criptografia e descriptografia de dados. Valores recomendados:
    2048, 3072, 4096.

  • -out [arquivo] - Especifica o arquivo de saída que armazenará o arquivo
    CSR. Este será usado para geração do certificado final, assinado pela
    entidade certificadora.

  • -keyout [arquivo] - Especifica o arquivo de saída que armazenará a chave
    privada gerada pelo openssl

  • -sha256 - Algoritmo usado para assinatura do certificado.

Criando um certificado de CA

Para gerar um certificado baseado na chave de CA privada:

openssl x509 -signkey ca/ca.key -days 10000 -req -in ca/ca.csr -out ca/ca.crt
-sha256

Onde:

  • signkey - Chave da CA criada no passo anterior, usada para gerar o
    certificado privado da CA.

  • days - Especifica a validade do certificado da CA (em dias). Após este
    período, o certificado se tornará Inválido!.

  • -in arquivo_CSR - Especifica o caminho para o arquivo CSR gerado no passo
    anterior, para criação do certificado da CA.

  • -out arquivo_crt - Especifica o arquivo de Certificado que será gerado ao
    final do procedimento.

Assinando um arquivo CRT

Assumindo que você é uma CA e alguém te envia um arquivo CRT para validação e
assinatura, siga o seguinte procedimento para assinar o Certificado, e devolver
ao usuário, para que ele consiga utilizar o certificado de forma válida:

openssl x509 -req -days 768 -in csr.csr -CA ca/ca.crt -CAkey ca/ca.key -out
cert-assinado.crt -set_serial 01 -sha256

Onde:

  • -in [arquivo] - Especifica o arquivo CSR enviado pelo cliente que será
    assinado.

  • -CAkey [arquivo] - Especifica o arquivo chave da CA que você criou
    anteriormente.

  • -out [arquivo] - Arquivo que será gerado e deverá ser enviado para o
    cliente para que ele conclua o procedimento de geração do certificado
    assinado por uma CA.

  • -CA [arquivo] - Especifica o certificado da CA que deverá usar para assinar
    o CSR.

Após executado o comando, o arquivo assinado especificado pela opção -out,
deverá ser enviado ao cliente para que ele possa utilizar o certificado em sua
aplicação.

Renovando um Certificado

Caso vocẽ seja uma CA (ou esteja admnistrando uma CA auto-assinada), os
seguintes procedimentos precisam ser executados para criar um novo certificado:

 1. O usuário precisa enviar o antigo arquivo CSR ou criar um novo CSR baseado
    na antiga chave criptográfica privada.

 2. O certificado antigo precisa ser revogado antes do novo CSR enviado precisa
    ser assinado. Para localizar o certificado antigo, olhe no arquivo
    index.txt e procure pelo campo DN (Distinguished Name), que corresponde a
    requisição. Obtenha o número serial correspondente àquele certificado
    (campo Serial Number).

    No arquivo index.txt é normal encontrar os seguintes campos (e seus
    respectivos significados):

      □ R - Certificados Revogadas

      □ V - Certificados Válidos

      □ E - Certificados Expirados

 3. Se desejar assinar a requisição manualmente, execute o comando: openssl ca
    -config /etc/openssl.cnf -out novo_certificado.pem \ -infiles newreq.pem
    -startdate [now] -enddate [previous enddate+365days]

    Note que este certificado utiliza a data de inicio now significando que ele
    permanece válido já no momento da geração. Algumas CAs colocam a validade
    para algumas horas antes para evitar possíveis problemas com o horário de
    máquinas que estão recebendo o certificado. Note que a validade do
    certificado é definida pela expiração anterior + 365 dias.

Agora basta enviar o novo_certificado.pem assinado para o cliente para que ele
possa fazer a instalação no sistema alvo.

Revogando um Certificado

Para revogar um certificado, de o comando: openssl ca -revoke certificado.pem

O banco de dados é atualizado e o certificado marcado como revogado. Você
precisará gerar o novo banco de dados CRL:

openssl ca -gencrl -config /etc/openssl.cnf -out crl/revogados-ca.crl

Nota: O arquivo CRL atualizado deverá ser sempre disponibilizado em seu website
para os clientes.

Os parâmetros adiiconais aceitos durante a revogação do certificado são crldays
/ crlhours e crlexts. Os primeiro dos parametros indicam quando o próximo CRL
será atualizado e e o último usará a sessão crl_exts no openssl.cnf para
produzir um CRL v2 ao invés do CRL v1.

Segue um exemplo de revogação de certificado indicando atualização do CRL em 7
dias:

openssl ca -gencrl -config /etc/openssl.cnf -crldays 7 -crlexts crl_ext \
-out crl/sopac-ca.crl

Revogando uma CA

Como a CA é criada sendo um certificado auto-assinado (issuer é igual ao 
subject), ela NÃO pode ser revogada. Ninguém pode emitir um certificado de
revogação que seriam autoritativos em cima daquela CA, pois representa o topo
na cadeia de validação de segurança.

Entretanto, existe um consenso para evita que uma CA comprometida cause dados
em toda a estrutura da árvore do topo para baixo, que consiste em remover a CA
comprometida dos navegadores e banco de dados de sistemas operacionais, sem
envolve rum CRL, pois devido a crescente risco de tal comprometimento, os
navegadores mais modernos atualizam essa lista de CAs confiáveis
automaticamente.

Isto pode ser feito também no Windows e MacOS que também possuem uma lista de
certificados desautorizados, e esta lista é verificada antes da lista confiável
do sistema operacional. Com isso até mesmo certificados de CA adicionadas na
cadeia de confiança podem ser 'marcados' como não confiáveis.

Gerando um par de chaves RSA a partir da chave privada

execute o seguinte comando para gera o par de chaves e salvar no arquivo
chave_privada.pem:

openssl genpkey -algorithm RSA -out chave_privada.pem -pkeyopt
rsa_keygen_bits:2048

Após executar este procedimento, não se esqueça de remover a permissão de
leitura de outros usuários com chmod go-r chave_privada.pem.

Extraindo a chave pública a partir da chave privada do certificado

Caso tenha a chave privada, e por alguma razão necessite gerar novamente a
chave pública a partir deste certificado, execute o seguinte procedimento para
obter o arquivo:

openssl rsa -pubout -in private_key.pem -out public_key.pem

Como mencionado anteriormente, a Chave Pública pode ser distribuida sem
qualquer procupação.

Extraindo elementos texto do certificado

Siga o procediment abaixo para visualizar em formato humano, os detalhes de um
certificado:

openssl rsa -text -in private_key.pem

O conteúdo do certificado será exibido para a saída padrão.

Gerando uma chave Pública

Para gerar uma chave pública em formato PEM, utilize o seguinte comando abaixo,
subsituindo certificado.pem pelo nome do seu certificado privado gerado
anteriormente:

openssl rsa -in certificado.pem -out chave_publica.pem -outform PEM -pubout 
Será gerado um arquivo chave_publica.pem, contendo o certificado público.

Gerando arquivo binário contendo números aleatórios

Alguns sistemas como o WireGuard, requerem um arquivo de números aleatórios
gerado para permitir a criação de certificados. Este arquivo pode ser gerado
com o comando abaixo:

openssl rand -base64 128 -out key.bin

Note que foi criada uma chave 128 bits, e será encodada usando base64.

Automatizando preenchimento de dados de certificado

Você deve ter notado que sempre que gera um certificado são requeridos dados
como Cidade, País, Estado, Email, CN, etc. Esse preenchimento pode ser feito
automaticamente via linha de comando, com isso seus scripts poderão operar
totalmente em modo não interativo (sem intervenção humana), facilitando a
adição deles em um ciclo DevOps.

Para isso, precisamos apenas informar o parametro -subj para o OpenSSL, usando
a construção Chave=Valor, como abaixo:

openssl ... -subj "/C=BR/ST=ES/L=Vitoria/O=GuiaFoca/OU=Departamento de
Seguranca/CN=guiafoca.org"

Como deve ter observado acima, mais de um parâmetro pode ser especificado
separando os mesmos por uma /.

Usando SNI nos domínios

Mais de um nome de domínio pode ser adicionado as extesões SSl usando o 
subjectAltnames, com isso, o certificado será vaálido para o subject e também
para os nomes DNS adicionais especificados nesse campo. Por exemplo:

openssl req -new -sha256 \
    -key guiafoca.key \
    -subj "/C=BR/ST=ES/O=Guia Foca/CN=guiafoca.org" \
    -reqexts SAN \
    -config <(cat /etc/ssl/openssl.cnf \
        <(printf "\n[SAN]\nsubjectAltName=DNS:www.guiafoca.org,DNS:www2.guiafoca.org")) \
    -out dominio.csr

Após isso, o certificdo gerado também passará a atender corretamente os
dominios: guiafoca.org, www.guiafoca.org e www2.guiafoca.org.

Encriptando arquivos grandes

Devido a forma que o algoritmo RSA trabalha, não é possível encriptar arquivos
muito grandes. Por padrão, o arquivo encriptado não pode ser maior que (n - 11)
(onde n é o tamanho da chave). O uso mais efetivo da criptografia RSA é para
encriptar uma senha gerada aleatóriamente, e então encriptar o arquivo grande
usando uma criptografia simétrica.

Caso tentar encriptar um arquivo maior que o tamanho acima, o comando de
encriptação finalizará com erro.

Especificando níveis de validação no Apache

Nesta seção, mostraremos como altera o nível de validação do servidor web 
Apache para ou relaxar ou ser rigoroso sobre a validação da cadeia de segurança
de certificados. Faremos uso das opções SSLVerifyClient e SSLVerifyDepth como
na configuração abaixo:

SSLVerifyClient optional
SSLVerifyDepth 1
SSLOptions +StdEnvVars

SSLVerifyClient - Permite enviar o certificado de cliente de forma opcional e
dizemos que devemos verificar a CA que assinou o certificado de cliente, mas
não o parent da CA (SSLVerifyDepth 1). Também que devemos passar as variáveis
de ambiente SSL para o servidor (StdEnvVars).

Enviando um certificado SSL de cliente para testes

Agora que fizemos a configuração do Apache para validação de certificado de
cliente (permitindo a conexão apenas para quem possuir o certificado assinado),
podemos fazer o teste enviando o certificando via curl:

curl --cert guiafoca/all.crt --key guiafoca/all.key --cacert guiafoca/ca.crt
https://guiafoca.org

Provavelmente você receberá um erro de CA desconhecida (“unknown ca”):

curl: (35) error:14094418:SSL routines:SSL3_READ_BYTES:tlsv1 alert unknown ca

Para corrigir isto, precisaremos dizer ao Apache sobre a CA do GuiaFoca.
Fazemos isso adicionando a seguinte linha ao nosso VirtualHost:

SSLCACertificateFile /caminho/para/o/ca.crt

Agora, se fizemos uma nova requisição, veremos os dados do servidor novamente,
mas dessa vez deverão existir valores que iniciam com SSL_CLIENT_. Para tornar
o envio do certificado obrigatório, edite o VirtualHost e altere:

SSLVerifyClient optional

para

SSLVerifyClient require

E reinicie o Apache. Agora, se enviar uma nova requisição via curl após fazer a
verificação, e não enviar o certificado do cliente, você obterá o seguinte
erro:

curl: (35) error:14094410:SSL routines:SSL3_READ_BYTES:sslv3 alert handshake failure

Verificando uma identidade

Após o procedimento de validação de chave de cliente funcional, nós podemos nos
aprofundar na verificação da identidade de usuário. Existem duas formas de
fazer isso:

A primeira, é verificar o número serial do certificado do usuário. Este será o
mesmo durante a validade do certificado. Caso o certificado for substituido por
um novo, o número serial mudará. Esta é a opção mais segura:

if ($_SERVER['SSL_CLIENT_M_SERIAL'] !== 'ABACABBF0CA') {
  echo "Você não deveria estar conectando aqui";
  exit;
}

Este código só rodará se o certificado do cliente for assinado por uma CA que
você confia, mas não é o certificado que está esperando. Se não for uma CA que
confie, então o comando falhará com uma falha na negociação.

A outra opção para verificar a identidade é usar o SSL_CLIENT_S_DN_Email. Um
endereço de e-mail pode ser usado em múltiplos ceritifcados, assim você não
poderá ter certeza que quem está confiando é a pessoal que deu o certificado
client. No entanto, como você precisa confiar na CA que assinou o certificado
antes, é aceitável e isto não será um risco tão grande como poderia ser:

if ($_SERVER['SSL_CLIENT_S_DN_Email'] !== '[gleydson@guiafoca.org]') {
  echo "Você não deveria estar aqui";
  exit;
}

Com essas duas opções, poderá ser escolhido identificar e autorizar o acesso de
pessoas pessoas baseadas no número serial do certificado ou pelo endereço de
e-mail.

Certificados Auto-Assinados

Caso sua empresa ou você deseje rodar um servidor web que só é usado por
conhecidos, ou se quiser autenticar usuários conhecidos para conectar em sua
máquina/acessar um serviço de VPN corporativo, então você não precisará pagar
ou utilizar uma CA oficial para criar esses certificados. Você tem a opção de
se tornar uma CA e criar quantos certificados quiser (isso é especialmente útil
em servidores de VPN em empresas)

Usar um certificado auto-assinado (self signed), não significa que os dados que
trafegam entre as duas pontas estarão inseguros, a principal diferença é que o
sistema precisará ter a CA que você gerou instalada manualmente para que o
certificado de cliente autentique como confiável a conexão.

Você precisará manter a sua chave CA privada segura, para prevenir que
invadores utilize-a pra emitir certificados fraudulentos, mas isso é
incontestavelmente não mais inseguro que confiar em uma CA de terceiros manter
sua chave privada segura (como o caso da Diginotar mostrou).

Você já deve ter notado que se o navegador encontra um certificado emitido por
uma CA auto-assinada, ele alertará que não se trata de uma fonte não confiável,
ou em um repositório de certificados raíz conhecidos do navegador. Desta forma,
ao instalar o certificado CA na máquina ou navegador dos usuários que precisam
acessar o site, assim estes alertas serão facilmente removidos.

É impossível distribuir esse certificado para pessoas fora da organização de
uma forma automatica, desta forma o uso de certificados auto-assinados são
somente úteis para pessoas que precisam acessar aquela página web, seja dentro
de seu grupo, de uma empresa, etc.

Beneficios de rodar uma CA própria

  • Te poupa de custos de comprar certificados SSL comerciais de uma CA
    autorizada, para cada dispositivo embarcado, resultando em altissima
    economia. Mesmo que possa gerar certificados usando LetsEncrypt, existe uma
    limitação de aproximadamente 200 certificados por domíno, e isso é uma
    limitação em economai de escala.

  • Certificados auto-assinados, cria um nível de segurança muito maior que
    usar certificados de terceiros, que são criados para uso em geral. Caso uma
    CA oficial seja comprometida, TODOS os certificados que foram emitidos por
    ela também estarão comprometidos e precisarão ser re-emitidos.

    Este problema simplesmente não existem em CA auto-assinadas, pois a
    segurança em ambas as pontas estão sob seu controle.

  • Maior granularidade no controle e níveis de acesso dos certificados
    gerados.

Criando Certificados Auto-Assinados

Basicamente certificados auto-assinados, possuem o campo issuer igual ao 
subject. Em algumas distribuições como o Debian, Ubuntu, CentOS, Mint, um
certificado self-signed é criado automaticamente e por padrão e possui o nome
Snake Oil para indicar que não são confiáveis, servindo apenas para
criptografia básica, e uso didático, e não para utilização em ambientes de
produção.

Desta forma, para criar um certificado auto-assinado gerado por você, com seus
parâmetros de segurança e criptografia customizados, siga os seguintes
procedimentos:

 1. Antes de gerar a chave, vamos criar a estrutura de diretórios para
    armazenar os certificados. Aqui usaremos a pasta /tmp/ssl/guia e /tmp/ssl/
    foca pra criar 'duas empresas' fictícias: uma se chamará guia e a outra...
    humm... foca: mkdir -p /tmp/ssl/guia /tmp/ssl/foca

 2. O primeiro passo é criar a CA para cada uma das empresas criadas. Como
    convenção, vamos gravar as chaves privadas geradas em arquivos .key e as
    chaves públicas em arquivos .crt. Caso desejar gerar o certificado sem
    incluir uma senha de proteção do certificado da CA, apenas remova o
    parametro -des3 da linha e comando:

    # Gera a chave RSA 4096 para a empresa 'guia'
    openssl genrsa -des3 -out /tmp/ssl/guia/ca.key 4096
    # Gera o certificado X509 para a empresa 'guia'
    openssl req -new -x509 -days 365 -key /tmp/ssl/guia/ca.key -out /tmp/ssl/guia/ca.crt

    # Gera a chave RSA 4096 para a empresa 'foca'
    openssl genrsa -des3 -out /tmp/ssl/foca/ca.key 4096
    # Gera o certificado X509 para a empresa 'foca'
    openssl req -new -x509 -days 365 -key /tmp/ssl/foca/ca.key -out /tmp/ssl/foca/ca.crt

    Note que após concluir esse procedimento, temos a chave RSA (com o nome
    ca.key) e o certificado privado da CA (com o nome ca.crt).

 3. O segundo passo é criar o certificado do servidor. Ele é chamado assim,
    pois será instalado no serviço que fornecerá acesso a clientes (como um
    sevidor web NgINX, Apache, Postfix, VPN, etc). O primeiro passo é gerar os
    certificados, que serão assinados em seguida:


    # Gera o certificado privado do 'guia'
    openssl genrsa -des3 -out /tmp/ssl/guia/servidor.key 4096
    # Gera o certificado privado do 'foca'
    openssl genrsa -des3 -out /tmp/ssl/foca/servidor.key 4096


    Caso deseje gerar certificados sem senhas, remova o parametro -des3 do
    comando.

 4. Assim que tiver os certificados de servidores privados, precisaremos gerar
    um CSR (Certificate Signing Request). O CSR é simplesmente um arquivo de
    requisição de assinatura, que você envia para a CA para que ela devolva o
    certificado assinado, e usaremos isso para criar o certificado público.

    Quando ele pergutnar pelo Common Name para a empresa guia, coloque 
    guiafoca.teste e da empresa foca será focalinux.teste:


    # Gera CSR para a empresa guia
    openssl req -new -key /tmp/ssl/guia/servidor.key -out /tmp/ssl/guia/servidor.csr
    # Cria o certificado publico assinando com a CA 'guia'
    openssl x509 -req -days 365 -in /tmp/ssl/guia/servidor.csr -CA /tmp/ssl/guia/ca.crt -CAkey /tmp/ssl/guia/ca.key -set_serial 01 -out /tmp/ssl/guia/servidor.crt

    # Gera CSR para a empresa foca
    openssl req -new -key /tmp/ssl/foca/servidor.key -out /tmp/ssl/foca/servidor.csr
    # Cria o certificado publico assinando com a CA 'foca'
    openssl x509 -req -days 365 -in /tmp/ssl/foca/servidor.csr -CA /tmp/ssl/foca/ca.crt -CAkey /tmp/ssl/foca/ca.key -set_serial 01 -out /tmp/ssl/foca/servidor.crt

    Voce poderá ainda fornecer uma senha desafio junto aos atributos extras:

    Please enter the following 'extra' attributes
    to be sent with your certificate request
    A challenge password []: Sua_senha_aqui
    An optional company name []: Sua_senha_aqui

Concatenando os Certificados gerados

Como estamos usando certificados de 2 empresas e auto-assinados, preciaremos
enviar ambos os certificados e nossa CA para nos identificarmos. Este
procedimento é bastante simples, e usaremos a simples concatenação de arquivos.
Faremos o mesmo com as chaves privadas:

cat /tmp/ssl/guia/ca.crt /tmp/ssl/guia/servidor.crt > /tmp/ssl/guia/all.crt
cat /tmp/ssl/guia/ca.key /tmp/ssl/guia/servidor.key > /tmp/ssl/guia/all.key

Agora para o certificado foca:

cat /tmp/ssl/foca/ca.crt /tmp/ssl/foca/servidor.crt > /tmp/ssl/foca/all.crt
cat /tmp/ssl/foca/ca.key /tmp/ssl/foca/servidor.key > /tmp/ssl/foca/all.key

Configurando o Apache e Virtual Hosts

Assim que tivermos todos os certificados que precisamos, nós poderemos testar
se temos acesso ao site via SSL. Faremos o seguinte procedimento:

 1. Crie o diretório /etc/apache2/ssl: mkdir /etc/apache2/ssl

 2. Crie um arquivo guiafoca.conf em /etc/apache2/sites-available com o
    conteúdo:

      <VirtualHost *:443>
        ServerName guiafoca.teste

        DocumentRoot /var/www/html

        SSLEngine On
        SSLCertificateFile /etc/apache2/ssl/all.crt
        SSLCertificateKeyFile /etc/apache2/ssl/all.key
        SSLCACertificateFile /etc/apache2/ssl/ca.crt
      </VirtualHost>


 3. Ative o site recém gerado com: a2ensite guiafoca

 4. Ative o módulo ssl do Apache com o comando: a2enmod ssl

 5. Reinicie o servidor Apache com: apache2ctl reload

Após isso, terá um site configurado para servidor SSL na porta 443. Para exibir
uma página web padrão, crie um arquivo /var/www/html/index.php com o seguinte
conteúdo:

<?php

print_r($_SERVER);

Testando a conexão SSL

Novamente utilizaremos o canivete suiço dos profissionais de segurança: o curl.
Utilizaremos ele para fazer a conexão usando SSL e validarndo o site: curl
https://guiafoca.teste

Durante a execução da abertura do SSL, o curl executará as seguintes ações:

 1. Ele tentará autenticar o certificado SSL padrão, usando as chaves
    instaladas no sistema operacional. Caso esse certificado não esteja
    instalado, você pode orientar o curl a abrir o certificado correto,
    apontando ele diretamente para o certificando gerado usando o parametro
    --cacert [arquivo].

 2. Se obter um erro de certificado expirado, ou problemas relacionados as
    verificações de certificado, você poderá usar a opção --insecure / -k no 
    curl para ignorar validações de certificado, assumindo que o mesmo é
    confiável e permitindo o uso de criptografia para tráfego de dados.

Por exemplo, para permitir a abertura de um site usando um certificado sem
retornar erros:

  • Validando o certificado auto-assinado: curl --cacert /tmp/ssl/foca/ca.crt
    https://guiafoca.teste

  • Ignorando a validação de auto-assinado: curl --ignore /tmp/ssl/foca/ca.crt
    https://guiafoca.teste

Sobre certificados usando Curva Eliptica

A técnica de criptografia usando Curva Eliptica (ECC) é bastante recente, e os
certificados gerados por ela são bem menores em tamamnho que os gerados usando
RSA. Nem por causa do tamanho reduzido sua segurança é menor: Um certifica ECC
de 224 bits possui segurança igualmetne forte se comparada a um certificado
2048 bits, embora consuma bem menos CPU.

Devido a essas características, certificados ECC devem ser preferenciais quando
utilizar dispositivos embarcados ou quando o o número de acessos a um
determinado tiver um grande número de concorrencias.

Programas para gerenciamento de CA usando ambiente gráfico e WEB

Esta sessão documenta uma série de programas e suas características que podem
ser usados para gerenciar uma CA de forma mais fácil. Algumas ferramentas
possuem profundo nível de maturidade, assim como o openssl e algumas são
voltadas para facilidade, apenas gerando o certificado e facilitando seu
gerenciamento:

  • TinyCA - Um dos melhores, suportam muitos algoritmos e permitem trabalhar
    com CAs independentes

  • Xca - Muito bom, baseado em qt, e salva os dados em banco de dados
    criptografado.

  • easy-rsa - Voltado principalmente a gerencia de certificados no OpenVPN.
    Não é muito usado para gerenciamento de CA de forma customizada.

  • GnoMint - Somente usa SHA1 como assinatura e o desenvolvimento não é mais
    ativo. Google Microsoft consideram SHA1 obsoleto nos produtos desde 2017.

  • FreeIPA - Possui o módulo de gerenciamento de certificados em sua interface
    gráfica, embora tenha como funcionaldiade principal o provimento de
    autenticação no sistema.

  • SimpleAuthority - Este é pago, e possui excelentes recursos de
    gerenciamento de certificados. O programa simpleAuthority pode ser usado
    para gerenciar as CAs, rodando em Linux, Windows, MacOS.

Teste de cliente/servidor SSL/TLS com openssl

Servidor OpenSSL

O OpenSSL pode atuar como um proxy SSL entre o servidor e um servidor que não
suporte SSL. Para criar um certificado auto-assinado:

$ openssl req -x509 -newkey rsa:2048 -keyout chave.pem -out certificado.pem
-days 365 -nodes

E para iniciar o servidor SSL:

$ openssl s_server -key chave.pem -cert certificado.pem -accept 44330 -www

Agora, você está terá um Servidor SSL sendo executado pela própria ferramenta 
openssl. Para verificar a conexão, pode ser usado o cliente ssl:

$ openssl s_client -connect localhost:44330

depth=0 C = BR, ST = ES, L = Vila Velha, O = Internet, OU = Informatica, CN = guiafoca.org, emailAddress = gleydson@guiafoca.org
verify error:num=18:self signed certificate

Cliente OpenSSL

Quando está depurando um problema dificil, e precisa de alguma forma de te
ajudar a entender o que está ocorrendo de errado, eis que aparece novamente o
canivete suiço openssl. Ele te auxiliará a entender o que está ocorrendo de
errado, mesmo quando o problema ocorrer em um fluxo DevOps ou ferramenta
automatizada. O openssl pode ser o que precisa para fazer a depuração:

Para conectar em um servidor usando a ferramenta openssl:

openssl s_client -connect www.terra.com.br:443

CONNECTED(00000003)
depth=2 O = Digital Signature Trust Co., CN = DST Root CA X3
verify return:1
depth=1 C = US, O = Let's Encrypt, CN = Let's Encrypt Authority X3
verify return:1
depth=0 CN = guiafoca.org
verify return:1
---
Certificate chain
 0 s:CN = guiafoca.org
   i:C = US, O = Let's Encrypt, CN = Let's Encrypt Authority X3
 1 s:C = US, O = Let's Encrypt, CN = Let's Encrypt Authority X3
   i:O = Digital Signature Trust Co., CN = DST Root CA X3
---
Server certificate
-----BEGIN CERTIFICATE-----
MIIFYjCCBEqgAwIBAgISBJ4tiXeoEMBd4GkU3uKR4AKFMA0GCSqGSIb3DQEBCwUA
MEoxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1MZXQncyBFbmNyeXB0MSMwIQYDVQQD
ExpMZXQncyBFbmNyeXB0IEF1dGhvcml0eSBYMzAeFw0yMDA2MDIxMTU0MDFaFw0y
MDA4MzExMTU0MDFaMBcxFTATBgNVBAMTDGd1aWFmb2NhLm9yZzCCASIwDQYJKoZI
hvcNAQEBBQADggEPADCCAQoCggEBAL3QP1H9r0/ulOb0RNHkQ5oyu3lxKAG6lNqL
Xpw8ITe8hBoOg+mDPcOhnZOgPys6ucMZ0jdgsIfU3oQM0cM+djWNyHpvF0BD9dKL
yZA2fZgUQDZKdxS5w+RVw3oVdSxcSgCGDozAQSwqpd3oroGyZ2GkKO17s4/SanVA
6ReIkenzG1Hg7hEJJDvaPnzWVcKNh/scNEyMsnE0OXYbVAjr16Ff7EkMVu+B/5gO
x92cxkeKmOfqzvW3pnpkhhTFJVA6svCSpJp4fouxHK3DRguU60j2hMGABz9Gb46H
xrhOLrcid10TTrviHck6cPHwF6wwhyVEoQChbHDwebSTESkzrbECAwEAAaOCAnMw
ggJvMA4GA1UdDwEB/wQEAwIFoDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUH
AwIwDAYDVR0TAQH/BAIwADAdBgNVHQ4EFgQUQsysavyg8sJPqUIayfBlOhfMjUYw
HwYDVR0jBBgwFoAUqEpqYwR93brm0Tm3pkVl7/Oo7KEwbwYIKwYBBQUHAQEEYzBh
MC4GCCsGAQUFBzABhiJodHRwOi8vb2NzcC5pbnQteDMubGV0c2VuY3J5cHQub3Jn
MC8GCCsGAQUFBzAChiNodHRwOi8vY2VydC5pbnQteDMubGV0c2VuY3J5cHQub3Jn
LzApBgNVHREEIjAgggxndWlhZm9jYS5vcmeCEHd3dy5ndWlhZm9jYS5vcmcwTAYD
VR0gBEUwQzAIBgZngQwBAgEwNwYLKwYBBAGC3xMBAQEwKDAmBggrBgEFBQcCARYa
aHR0cDovL2Nwcy5sZXRzZW5jcnlwdC5vcmcwggEEBgorBgEEAdZ5AgQCBIH1BIHy
APAAdgDnEvKwN34aYvuOyQxhhPHqezfLVh0RJlvz4PNL8kFUbgAAAXJ1GIayAAAE
AwBHMEUCIQCtrH4CxUi8/9Az+yjXfaAs5zt2qMldNNWFfH/sy2ruagIgGnnOKp+y
1b64brS04pL4cCXakjkNnluqR2HHPjUdQKkAdgAHt1wb5X1o//Gwxh0jFce65ld8
V5S3au68YToaadOiHAAAAXJ1GIb4AAAEAwBHMEUCIQDqLLTizQQRkF6hN3IPVsDF
x3W2JeaiVc2v4XZFcF8BFgIgPrKYGiBpY5Hiykq0szjwFYaUApOb8z3NNM4Sxqtj
rbEwDQYJKoZIhvcNAQELBQADggEBAFb20LagN6e1bcc1wwa9qkaKXr8xG2x78I6t
FsfuruSbOVZWUIQDsJhKuZFH84gKnsqzI46k7u04DTYuD2BGnu+9UhUyTHU306CZ
cJPzTqHesgo3ir/D8uZGPU3D6Dhv4rfJPIsJAdOKdbayhpiaWn46XvD0xwOAJspF
zNTWYWEatIx52wAW3vQ0D7h/6mWslPQJzpDp/crJk/2hsVUov8NqYTNkqHFR3vlS
zbn3Oi4Rs6K9nDLXFjPYY7OXtebLj3aXafHo/KtBtjPX8DfZFv0FSNHb1Iu9Yn38
XdQGYAk1hP2/sFSqiNJjwkt040gsARCR4OdypuuV7OrsqTJCujM=
-----END CERTIFICATE-----
subject=CN = guiafoca.org

issuer=C = US, O = Let's Encrypt, CN = Let's Encrypt Authority X3

---
No client certificate CA names sent
Peer signing digest: SHA256
Peer signature type: RSA-PSS
Server Temp Key: X25519, 253 bits
---
SSL handshake has read 3121 bytes and written 388 bytes
Verification: OK
---
New, TLSv1.3, Cipher is TLS_AES_256_GCM_SHA384
Server public key is 2048 bit
Secure Renegotiation IS NOT supported
Compression: NONE
Expansion: NONE
No ALPN negotiated
Early data was not sent
Verify return code: 0 (ok)
---


Caso ele reclamar de um certificado auto-assinado (self-signed), utilize o
parametro -CAfile para indicar um arquivo de CA para leitura:

Agora, com o cliente conectado, você poderá executar os seguintes comandos:

  • q - Finaliza a coexão SSL mas ainda aceita novas conexões

  • Q - Finaliza a conexão SSL atual e encerra.

  • r - Renegocia a conexão SSL

  • R - Renegocia a sessão SSL e requisita um certificado de cliente.

  • P - Envia algum texto plano na conexão TCP: isto deve fazer o cliente
    desconectar devido a violação de protocolo.

  • S - Mostra dados de utilização do cache de status.

Cadeia de Confiança

É possível também analisar a cadeia de segurança do certificado SSL sendo
testado com a ferramenta openssl. Ainda continuando a análise do comando: 
openssl s_client -connect www.terra.com.br:443:

Certificate chain
 0 s:CN = guiafoca.org
   i:C = US, O = Let's Encrypt, CN = Let's Encrypt Authority X3
 1 s:C = US, O = Let's Encrypt, CN = Let's Encrypt Authority X3
   i:O = Digital Signature Trust Co., CN = DST Root CA X3

Mostra a relação entre issuer e subject no certificado. Caso aparecerem números
longos hexadecimais no subject, significa que o OpenSSL não possui o OID em sua
base de mapeamento, exibindo o hexadecimal em seu lugar. Os OIDS são únicos e
identificações que não se repetem, usados entre outras coisas para validação de
certificados de validação extendida (EV).

Por padrão o openssl mostra apenas o certificado final. Caso deseje mostrar
toda a cadeia, use a opção -showcerts: echo Q | openssl s_client -connect
www.guiafoca.org:443 -showcerts

CONNECTED(00000003)
depth=2 O = Digital Signature Trust Co., CN = DST Root CA X3
verify return:1
depth=1 C = US, O = Let's Encrypt, CN = Let's Encrypt Authority X3
verify return:1
depth=0 CN = guiafoca.org
verify return:1
---
Certificate chain
 0 s:CN = guiafoca.org
   i:C = US, O = Let's Encrypt, CN = Let's Encrypt Authority X3
-----BEGIN CERTIFICATE-----
MIIFYjCCBEqgAwIBAgISBJ4tiXeoEMBd4GkU3uKR4AKFMA0GCSqGSIb3DQEBCwUA
MEoxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1MZXQncyBFbmNyeXB0MSMwIQYDVQQD
ExpMZXQncyBFbmNyeXB0IEF1dGhvcml0eSBYMzAeFw0yMDA2MDIxMTU0MDFaFw0y
MDA4MzExMTU0MDFaMBcxFTATBgNVBAMTDGd1aWFmb2NhLm9yZzCCASIwDQYJKoZI
hvcNAQEBBQADggEPADCCAQoCggEBAL3QP1H9r0/ulOb0RNHkQ5oyu3lxKAG6lNqL
Xpw8ITe8hBoOg+mDPcOhnZOgPys6ucMZ0jdgsIfU3oQM0cM+djWNyHpvF0BD9dKL
yZA2fZgUQDZKdxS5w+RVw3oVdSxcSgCGDozAQSwqpd3oroGyZ2GkKO17s4/SanVA
6ReIkenzG1Hg7hEJJDvaPnzWVcKNh/scNEyMsnE0OXYbVAjr16Ff7EkMVu+B/5gO
x92cxkeKmOfqzvW3pnpkhhTFJVA6svCSpJp4fouxHK3DRguU60j2hMGABz9Gb46H
xrhOLrcid10TTrviHck6cPHwF6wwhyVEoQChbHDwebSTESkzrbECAwEAAaOCAnMw
ggJvMA4GA1UdDwEB/wQEAwIFoDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUH
AwIwDAYDVR0TAQH/BAIwADAdBgNVHQ4EFgQUQsysavyg8sJPqUIayfBlOhfMjUYw
HwYDVR0jBBgwFoAUqEpqYwR93brm0Tm3pkVl7/Oo7KEwbwYIKwYBBQUHAQEEYzBh
MC4GCCsGAQUFBzABhiJodHRwOi8vb2NzcC5pbnQteDMubGV0c2VuY3J5cHQub3Jn
MC8GCCsGAQUFBzAChiNodHRwOi8vY2VydC5pbnQteDMubGV0c2VuY3J5cHQub3Jn
LzApBgNVHREEIjAgggxndWlhZm9jYS5vcmeCEHd3dy5ndWlhZm9jYS5vcmcwTAYD
VR0gBEUwQzAIBgZngQwBAgEwNwYLKwYBBAGC3xMBAQEwKDAmBggrBgEFBQcCARYa
aHR0cDovL2Nwcy5sZXRzZW5jcnlwdC5vcmcwggEEBgorBgEEAdZ5AgQCBIH1BIHy
APAAdgDnEvKwN34aYvuOyQxhhPHqezfLVh0RJlvz4PNL8kFUbgAAAXJ1GIayAAAE
AwBHMEUCIQCtrH4CxUi8/9Az+yjXfaAs5zt2qMldNNWFfH/sy2ruagIgGnnOKp+y
1b64brS04pL4cCXakjkNnluqR2HHPjUdQKkAdgAHt1wb5X1o//Gwxh0jFce65ld8
V5S3au68YToaadOiHAAAAXJ1GIb4AAAEAwBHMEUCIQDqLLTizQQRkF6hN3IPVsDF
x3W2JeaiVc2v4XZFcF8BFgIgPrKYGiBpY5Hiykq0szjwFYaUApOb8z3NNM4Sxqtj
rbEwDQYJKoZIhvcNAQELBQADggEBAFb20LagN6e1bcc1wwa9qkaKXr8xG2x78I6t
FsfuruSbOVZWUIQDsJhKuZFH84gKnsqzI46k7u04DTYuD2BGnu+9UhUyTHU306CZ
cJPzTqHesgo3ir/D8uZGPU3D6Dhv4rfJPIsJAdOKdbayhpiaWn46XvD0xwOAJspF
zNTWYWEatIx52wAW3vQ0D7h/6mWslPQJzpDp/crJk/2hsVUov8NqYTNkqHFR3vlS
zbn3Oi4Rs6K9nDLXFjPYY7OXtebLj3aXafHo/KtBtjPX8DfZFv0FSNHb1Iu9Yn38
XdQGYAk1hP2/sFSqiNJjwkt040gsARCR4OdypuuV7OrsqTJCujM=
-----END CERTIFICATE-----
 1 s:C = US, O = Let's Encrypt, CN = Let's Encrypt Authority X3
   i:O = Digital Signature Trust Co., CN = DST Root CA X3
-----BEGIN CERTIFICATE-----
MIIEkjCCA3qgAwIBAgIQCgFBQgAAAVOFc2oLheynCDANBgkqhkiG9w0BAQsFADA/
MSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMT
DkRTVCBSb290IENBIFgzMB4XDTE2MDMxNzE2NDA0NloXDTIxMDMxNzE2NDA0Nlow
SjELMAkGA1UEBhMCVVMxFjAUBgNVBAoTDUxldCdzIEVuY3J5cHQxIzAhBgNVBAMT
GkxldCdzIEVuY3J5cHQgQXV0aG9yaXR5IFgzMIIBIjANBgkqhkiG9w0BAQEFAAOC
AQ8AMIIBCgKCAQEAnNMM8FrlLke3cl03g7NoYzDq1zUmGSXhvb418XCSL7e4S0EF
q6meNQhY7LEqxGiHC6PjdeTm86dicbp5gWAf15Gan/PQeGdxyGkOlZHP/uaZ6WA8
SMx+yk13EiSdRxta67nsHjcAHJyse6cF6s5K671B5TaYucv9bTyWaN8jKkKQDIZ0
Z8h/pZq4UmEUEz9l6YKHy9v6Dlb2honzhT+Xhq+w3Brvaw2VFn3EK6BlspkENnWA
a6xK8xuQSXgvopZPKiAlKQTGdMDQMc2PMTiVFrqoM7hD8bEfwzB/onkxEz0tNvjj
/PIzark5McWvxI0NHWQWM6r6hCm21AvA2H3DkwIDAQABo4IBfTCCAXkwEgYDVR0T
AQH/BAgwBgEB/wIBADAOBgNVHQ8BAf8EBAMCAYYwfwYIKwYBBQUHAQEEczBxMDIG
CCsGAQUFBzABhiZodHRwOi8vaXNyZy50cnVzdGlkLm9jc3AuaWRlbnRydXN0LmNv
bTA7BggrBgEFBQcwAoYvaHR0cDovL2FwcHMuaWRlbnRydXN0LmNvbS9yb290cy9k
c3Ryb290Y2F4My5wN2MwHwYDVR0jBBgwFoAUxKexpHsscfrb4UuQdf/EFWCFiRAw
VAYDVR0gBE0wSzAIBgZngQwBAgEwPwYLKwYBBAGC3xMBAQEwMDAuBggrBgEFBQcC
ARYiaHR0cDovL2Nwcy5yb290LXgxLmxldHNlbmNyeXB0Lm9yZzA8BgNVHR8ENTAz
MDGgL6AthitodHRwOi8vY3JsLmlkZW50cnVzdC5jb20vRFNUUk9PVENBWDNDUkwu
Y3JsMB0GA1UdDgQWBBSoSmpjBH3duubRObemRWXv86jsoTANBgkqhkiG9w0BAQsF
AAOCAQEA3TPXEfNjWDjdGBX7CVW+dla5cEilaUcne8IkCJLxWh9KEik3JHRRHGJo
uM2VcGfl96S8TihRzZvoroed6ti6WqEBmtzw3Wodatg+VyOeph4EYpr/1wXKtx8/
wApIvJSwtmVi4MFU5aMqrSDE6ea73Mj2tcMyo5jMd6jmeWUHK8so/joWUoHOUgwu
X4Po1QYz+3dszkDqMp4fklxBwXRsW10KXzPMTZ+sOPAveyxindmjkW8lGy+QsRlG
PfZ+G6Z6h7mjem0Y+iWlkYcV4PIWL1iwBi8saCbGS5jN2p8M+X+Q7UNKEkROb3N6
KOqkqm57TH2H3eDJAkSnh6/DNFu0Qg==
-----END CERTIFICATE-----
---
Server certificate
subject=CN = guiafoca.org

issuer=C = US, O = Let's Encrypt, CN = Let's Encrypt Authority X3

---
No client certificate CA names sent
Peer signing digest: SHA256
Peer signature type: RSA-PSS
Server Temp Key: X25519, 253 bits
---
SSL handshake has read 3121 bytes and written 388 bytes
Verification: OK
---
New, TLSv1.3, Cipher is TLS_AES_256_GCM_SHA384
Server public key is 2048 bit
Secure Renegotiation IS NOT supported
Compression: NONE
Expansion: NONE
No ALPN negotiated
Early data was not sent
Verify return code: 0 (ok)
---
DONE


Analisando a saída acima, a parte mais importante é o TLS 1.3 e o cipher suite
usado: ECDHE-ECDSA-AES256-GCM-SHA384. Também é possível determinar se o
servidor enviou um ID e ticket de sessão TLS

No client certificate CA names sent
Peer signing digest: SHA256
Peer signature type: RSA-PSS
Server Temp Key: X25519, 253 bits
---
SSL handshake has read 3121 bytes and written 388 bytes
Verification: OK
---
New, TLSv1.3, Cipher is TLS_AES_256_GCM_SHA384
Server public key is 2048 bit
Secure Renegotiation IS NOT supported
Compression: NONE
Expansion: NONE
No ALPN negotiated
Early data was not sent
Verify return code: 0

Note que para o TLS 1.2 a saída é um pouco diferente, como a abaixo:

---
SSL handshake has read 3966 bytes and written 434 bytes
Verification: OK
---
New, TLSv1.2, Cipher is ECDHE-RSA-AES256-GCM-SHA384
Server public key is 2048 bit
Secure Renegotiation IS supported
Compression: NONE
Expansion: NONE
No ALPN negotiated
SSL-Session:
    Protocol  : TLSv1.2
    Cipher    : ECDHE-RSA-AES256-GCM-SHA384
    Session-ID: 645725145319CFB1FE33ECEF9D41AFDA605C34F66266582700742BC1C672E90B
    Session-ID-ctx:
    Master-Key: 13464E7438098F2463BCAB0605FF225D5EBA37D438C75161247975A3C787AA7F1729CDA160B4001C032C90A01DAE0C23
    PSK identity: None
    PSK identity hint: None
    SRP username: None
    TLS session ticket lifetime hint: 7300 (seconds)
    TLS session ticket:
    0000 - 00 00 0e 86 64 dc a9 6a-66 81 4a 74 ef 81 28 ce   ....d..jf.Jt..(.
    0010 - 28 b7 a9 41 c5 26 8e e5-b3 a5 3d d0 27 2b 75 59   (..A.....=.'+uY
    0020 - 9b 99 8c c7 2b 6e 21 89-22 e4 2a da 50 cc 00 af   ....+n!.".*.P...
    0030 - b0 c2 2a 8d 22 a4 4a 3f-d7 63 07 9b 30 bc 0e 89   ..*.".J?.c..0...
    0040 - 70 70 6a a2 d5 09 10 a7-7a 58 73 88 29 e6 f0 b4   ppj.....zXs.)...
    0050 - 0d c4 fa da 14 6f a1 0f-6e 28 b9 2f b1 8a 69 be   .....o..n(./..i.
    0060 - eb 07 58 21 ce cc 7c ed-3e 99 b6 3d d4 9a 9d 5e   ..X!..|.>..=...^
    0070 - dd 10 a3 85 ae ad f6 09-e6 77 20 4e 83 44 a5 7a   .........w N.D.z
    0080 - f0 c4 79 9c e1 3e 4f 15-22 49 a7 20 d8 d5 e0 47   ..y..>O."I. ...G
    0090 - c3 ac 3d 8e 78 e9 d9 0d-e8 fa 75 f7 ac cc f9 2e   ..=.x.....u.....
    00a0 - 64 9a b3 b8 28 ba 04 e2-f9 a5 0c 07 a1 9d da d3   d...(...........

    Start Time: 1594518720
    Timeout   : 7200 (sec)
    Verify return code: 0 (ok)
    Extended master secret: no


Testando protocolos que fazem upgrade para TLS

Quando é usado com o HTTP, o TLS troca toda a comunicação para HTTPS. Mas
alguns protocolos iniciam como texto plano, e eles fazem upgrade para
criptografia. Se quiser testar esse tipod e protocolo, é necessário especificar
a opção -starttls, indicando que o protocolo pode fazer upgrade por si próprio.
:

openssl s_client -connect gmail-smtp-in.l.google.com:25 -starttls smtp

A saída será a seguinte:

CONNECTED(00000003)
depth=2 OU = GlobalSign Root CA - R2, O = GlobalSign, CN = GlobalSign
verify return:1
depth=1 C = US, O = Google Trust Services, CN = GTS CA 1O1
verify return:1
depth=0 C = US, ST = California, L = Mountain View, O = Google LLC, CN = mx.google.com
verify return:1
---
Certificate chain
 0 s:C = US, ST = California, L = Mountain View, O = Google LLC, CN = mx.google.com
   i:C = US, O = Google Trust Services, CN = GTS CA 1O1
 1 s:C = US, O = Google Trust Services, CN = GTS CA 1O1
   i:OU = GlobalSign Root CA - R2, O = GlobalSign, CN = GlobalSign
---
Server certificate
-----BEGIN CERTIFICATE-----
MIIHJDCCBgygAwIBAgIRAJI+8dkxpHmxCAAAAABH8A4wDQYJKoZIhvcNAQELBQAw
QjELMAkGA1UEBhMCVVMxHjAcBgNVBAoTFUdvb2dsZSBUcnVzdCBTZXJ2aWNlczET
MBEGA1UEAxMKR1RTIENBIDFPMTAeFw0yMDA2MTcxNDI5NDZaFw0yMDA5MDkxNDI5
NDZaMGcxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQH
Ew1Nb3VudGFpbiBWaWV3MRMwEQYDVQQKEwpHb29nbGUgTExDMRYwFAYDVQQDEw1t
eC5nb29nbGUuY29tMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEJ2cnRpnaoWs2
bzNvXchIDzxPpg6MZAgSc8FQwAiRkNXnYJMmuHwkUjcsUBva/ax8SLkO/Ax/Kilp
BU187FIGMaOCBLkwggS1MA4GA1UdDwEB/wQEAwIHgDATBgNVHSUEDDAKBggrBgEF
BQcDATAMBgNVHRMBAf8EAjAAMB0GA1UdDgQWBBS/odoeByJYt5WTZU/HTnSXg9Vr
KzAfBgNVHSMEGDAWgBSY0fhuEOvPm+xgnxiQG6DrfQn9KzBoBggrBgEFBQcBAQRc
MFowKwYIKwYBBQUHMAGGH2h0dHA6Ly9vY3NwLnBraS5nb29nL2d0czFvMWNvcmUw
KwYIKwYBBQUHMAKGH2h0dHA6Ly9wa2kuZ29vZy9nc3IyL0dUUzFPMS5jcnQwggJ1
BgNVHREEggJsMIICaIINbXguZ29vZ2xlLmNvbYIXYWx0MS5hc3BteC5sLmdvb2ds
ZS5jb22CH2FsdDEuZ21haWwtc210cC1pbi5sLmdvb2dsZS5jb22CHWFsdDEuZ21y
LXNtdHAtaW4ubC5nb29nbGUuY29tghdhbHQyLmFzcG14LmwuZ29vZ2xlLmNvbYIf
YWx0Mi5nbWFpbC1zbXRwLWluLmwuZ29vZ2xlLmNvbYIdYWx0Mi5nbXItc210cC1p
bi5sLmdvb2dsZS5jb22CF2FsdDMuYXNwbXgubC5nb29nbGUuY29tgh9hbHQzLmdt
YWlsLXNtdHAtaW4ubC5nb29nbGUuY29tgh1hbHQzLmdtci1zbXRwLWluLmwuZ29v
Z2xlLmNvbYIXYWx0NC5hc3BteC5sLmdvb2dsZS5jb22CH2FsdDQuZ21haWwtc210
cC1pbi5sLmdvb2dsZS5jb22CHWFsdDQuZ21yLXNtdHAtaW4ubC5nb29nbGUuY29t
ghJhc3BteC5sLmdvb2dsZS5jb22CFWFzcG14Mi5nb29nbGVtYWlsLmNvbYIVYXNw
bXgzLmdvb2dsZW1haWwuY29tghVhc3BteDQuZ29vZ2xlbWFpbC5jb22CFWFzcG14
NS5nb29nbGVtYWlsLmNvbYIaZ21haWwtc210cC1pbi5sLmdvb2dsZS5jb22CEWdt
ci1teC5nb29nbGUuY29tghhnbXItc210cC1pbi5sLmdvb2dsZS5jb22CDW14MS5z
bXRwLmdvb2eCDW14Mi5zbXRwLmdvb2eCDW14My5zbXRwLmdvb2eCDW14NC5zbXRw
Lmdvb2cwIQYDVR0gBBowGDAIBgZngQwBAgIwDAYKKwYBBAHWeQIFAzAzBgNVHR8E
LDAqMCigJqAkhiJodHRwOi8vY3JsLnBraS5nb29nL0dUUzFPMWNvcmUuY3JsMIIB
AwYKKwYBBAHWeQIEAgSB9ASB8QDvAHUAsh4FzIuizYogTodm+Su5iiUgZ2va+nDn
sklTLe+LkF4AAAFywuaIaAAABAMARjBEAiALLdlXTf//fnFVtu3WnnsDzrnyshIO
6Ika3/12hYaquQIgVwOF3Psb8cx4if4Lr6wvlUshfpM0TspYpjx/b+Fg//QAdgBe
p3P531bA57U2SH3QSeAyepGaDIShEhKEGHWWgXFFWAAAAXLC5ohmAAAEAwBHMEUC
IQDqLbrAjESKIMs1p78PEwKYgPUdJ108bdsdpeGc/ZqY9QIgd06p3NR46wGcsThR
fyoOyC4SMYng3ImFXXW7bFYlcjowDQYJKoZIhvcNAQELBQADggEBAGYdR+ajEHgr
5Dmw5dxTkXm5rTKWxT8RZV4hpj7WS5jd01h8I/IGbafisJA6oij7LvAkcqoH2F3i
xPVUt0cRRL4K1LNH146fjvp1tiEevxqXK9rAYRluZw38EvCVIeLrlg0XCIUYBFPS
PMt9lZ71yehlB5KnbLEJjchlgQz986lpcvOu8jtJWBzTHe+BFVIjOciEX3Bgb+3F
JyVBEWY6DfxIVKd6dyoAhoYVSeZwdfAGZJ6kr6J19oDtX9P18VTrOF5zVsMsHW31
wFubVkS8zKplQBdOa1z2qxENdrYi/T1FkQfW0BfFmBRcx+ObNlL4FZav6gFcb0uZ
tk6NlovNPPU=
-----END CERTIFICATE-----
subject=C = US, ST = California, L = Mountain View, O = Google LLC, CN = mx.google.com

issuer=C = US, O = Google Trust Services, CN = GTS CA 1O1

---
No client certificate CA names sent
Peer signing digest: SHA256
Peer signature type: ECDSA
Server Temp Key: X25519, 253 bits
---
SSL handshake has read 3496 bytes and written 431 bytes
Verification: OK
---
New, TLSv1.3, Cipher is TLS_AES_256_GCM_SHA384
Server public key is 256 bit
Secure Renegotiation IS NOT supported
Compression: NONE
Expansion: NONE
No ALPN negotiated
Early data was not sent
Verify return code: 0 (ok)
---
250 SMTPUTF8

O upgrade de conexão é suportado para os protocolos SMTP, POP3, IMAP, FTP, e
XMPP.

Extraindo o certificado remoto do cliente

Utilize o seguinte comando do openssl para extrair o certificado de cliente
diretamente de um domínio:

$ echo | openssl s_client -connect www.guiafoca.org:443 2>&1 | sed --quiet '/
-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > www.guiafoca.org.crt

Usando formatos diferentes de HandShake de conexão

Em alguma situações, durante os tests do OpenSSL, suas tentativas podem falhar
(mesmo que saiba que o servidor utiliza TLS, vendo ele funcionando pelo
navegador). Uma possivel causa é quando o servidor não suporta o handshake
antigo do SSL 2.

Como OpenSSL tenta negociar todos os protocolos que conhece e como o o SSL2
pode ser negociado apenas usando o antigo handshake SSL2, ele usa este
handshake como padrão.

Mesmo que ele esteja associado com um protocolo muito antigo e inseguro, o
formato de handshake antigo não é inseguro. Ele suporta upgrades, o que
significa que um protocolo melhor pode ser negociado. No entanto, esta formato
de handshake não suporta muitas características de conexão que foram criadas
após o SSL 2.

Desta forma, para forçar o OpenSSL a usar um novo formato de conexão, faça isso
desativando o SSL2 :

openssl s_client -connect www.guiafoca.org:443 -no_ssl2

Uma forma alternativa de fazer o mesmo, é especificar o servername na linha de
comando:

openssl s_client -connect www.guiafoca.org:443 -servername www.guiafoca.org

A opção -servername [nome] permite o habilitar a conexão usaando SNI (Server
Name Indicator), o que forçará o uso do novo padrão SSL3.

Testando o suporte a uma versão específica de protocolo SSL

Por padrão, o openssl s_client tentará usar o melhor protocolo para falar com o
servidor remoto e reportará a versão negociada na saída:

Protocol : TLSv1.2

Caso precise testar o suporte a uma versão específica, então você terá duas
opções.

 1. Especificar explicitamente qual deseja usar entre as opções: -ssl2, -ssl3,
    -tls1, -tls1_1, -tls1_2, -tls1_3

 2. Especificar que protocolos você NÂO deseja testar usando uma das opções:
    -no_ssl2, -no_ssl3, -no_tls1, -no_tls1_1, -no_tls1_2

# Caso o client não suportar a opção, você receberá o retorno:

$ openssl s_client -connect www.guiafoca.org:443 -showcerts -tls1_1
s_client: Option unknown option -tls1_1
s_client: Use -help for summary.

OBS: A versão OpenSSL 1.1.0f e mais novas, apenas suportam o TLS e a opção
-no_ssl3.

Caso o servidor não suportar uma versão de protocolo, o seguinte retorno será
mostrado:

$ openssl s_client -connect www.guiafoca.org:443 -tls1_2
CONNECTED(00000003)
140455015261856:error:1408F10B:SSL routines:SSL3_GET_RECORD:wrong version number:s3↩
_pkt.c:340:

Testando o suporte a um conjunto de Ciphers

A configuração do Cipher é feita ao selecionar os ciphers que deseja usar, mas
se especificar somente um conjunto de Ciphers e fizer o handshake com sucesso
no servidor, claramente significa que ele suporta o conjunto. Se o handshake
falhar, saberá que não tem suporte a àquele conjunto:

Para testar se o o servidor suporta RC4-SHA:

openssl s_client -connect www.guiafoca.org:443 -cipher RC4-SHA

Para obter uma lista de todos os tipos suportados por um servidor, inicie com o
comando:

# openssl ciphers ALL

Para obter uma lista de todos os ciphers ssl suportados por sua versão e
envie-os um a um para teste individual, possivelmente usando um script. Observe
que você somente pode testar com Ciphers também suportados por sua versão de
SSL.

Testando servidores que requerem SNI

Como o SSL e o TLS inicialmente foram feitos para suportar um website por IP, o
SNI é uma extensão do TLS que permite usar mais de um certificado com o mesmo
endpoint IP. Isso é importante principalmente para provedores de hospedagem que
utilizam IPV4, devido a escassez de endereços IP.

Pra que isso ocorra, o TLS usa a extensão para enviar o nome designado e os
servidores TLS utilizam para selecioanr o certificado correto para responder.
Em resumo, o SNI permite o uso de hospedagens de forma segura.

Caso tentar conectar sem SNI em servidor com SNI, uma das três coisas
acontecerão:

  • A mais frequente, você receberá o mesmo certificado que obteria caso os
    dados SNI não forem fornecidos

  • O servidor reponderá com um certificado diferente do site que fará o teste

  • Muito raramente, o servidor abortará o handshake e recusará a conexão

Você pode ativar o teste de SNI no s_client com a opção -servername:

openssl s_client -connect www.guiafoca.org:443 -servername www.guiafoca.org

Desta forma, a conexão resolvera o IP do parametro passado por -connect e
enviará o nome indicado por -servername.

Você pode determinar se o site requer SNI testando ele com e sem o parametro
-servername e comparando os resultados. Caso não forem, o SNI é requerido.

Algumas vezes, se o nome requisitado não estiver disponível, o servidor
mostrará isso com um alerta TLS:

openssl s_client -connect www.guiafoca.org:443 -servername www.guiadofoca.org
CONNECTED(00000003)
1255:error:14077458:SSL routines:SSL23_GET_SERVER_HELLO:reason(1112):s23_clnt.c:596:

Testando reuso de conexão no SSL

O parâmetro -reconnect faz o teste de reuso de sessão. Neste modo, o openssl
s_client conectará no destino sez vezes, a primeira será a nova conexão e
tentará reutilizar a conexão nas próximas cinco.

echo | openssl s_client -connect www.guiafoca.org:443 -reconnect

Na primeira:

New, TLSv1.3, Cipher is ECDHE-RSA-AES128-GCM-SHA256
Server public key is 2048 bit

Nas tentativas seguintes:

Reused, TLSv1.3, Cipher is ECDHE-RSA-AES128-GCM-SHA256
Secure Renegotiation IS supported

Caso o reuso de conexão não estiver ativado, você receberá o seguinte retorno:

New, TLSv1.3, Cipher is TLS_AES_256_GCM_SHA384
Secure Renegotiation IS NOT supported
Compression: NONE
Expansion: NONE
No ALPN negotiated
Early data was not sent
Verify return code: 0 (ok)


OBS: Para desativar o uso de tickets de sessão, caso o cliente não utilize essa
característica, desative com a opção -no_ticket

Validação de revogação OCSP

O OCSP significa Online Certificate Status Protocol (Protocolo de status online
do Certificado), descrito na RFC2560, ajuda a elevar a segurança de publicação
de certificados, através da verificação do seatus de validade do certificado.

Se o responder OCSP estiver com mal funcionamento, geralmente é dificil
entender o porque. A verificação do status da revogação do certificado pela
linha de comando é possível, mas nem sempre fácil. Ela pode ser feita da
seguinte forma:

  • Obtenha um certificado que deseja verifica a revogação

  • Obtenha o certificado do emissor

  • Determine a URL do reponder OCSP

  • Envie uma requisição OCSP e observe a resposta

Para os primeiros dois passos, conecte no servidro com a opção -showcerts como
especificado:

openssl s_client -connect www.guiafoca.org:443 -showcerts

Para obter somente o endereço do responder OCSP, utilize o seguinte comando no
certificado baixado localmente:

openssl x509 -in fd.crt -noout -ocsp_uri

Agora, você poderá enviar a requisição OCSP:

openssl ocsp -issuer issuer.crt -cert fd.crt -url http://www.guiafoca.org/ -CAfile issuer.crt
WARNING: no nonce in response
Response verify OK
fd.crt: good
        This Update: Feb 18 17:59:10 2020 GMT
        Next Update: Feb 18 23:59:10 2020 GMT


Testando o suporte a OCSP Stapling

O OCSP Stapling é um recurso opcional que permite ao certificado do servidor
ser acompanhado por uma resposta OCSP que prova sua validade. Porque a resposta
OCSP é entregue através de uma conexão existente, o cliente não precisa pega-la
separadamente.

O OCSP Stapling é usado somente se requisitado pelo cliente, que envia a
extensão status_request em uma requisição handshake. O servidor que suporta o
OCSP stapling responderá incluindo uma requisião OCSP como parte do handshake.

Quando utiliza a ferramenta s_client, o OCSP stapling é requisitado com a opção
-status:

$ echo | openssl s_client -connect www.guiafoca.org:443 -status

Dados relacionados com o OCSP serão mostrados no inicio da conexão de saída.
Por exemplo, se o servidor não suportar stapling, você verá essa linha no topo
da saída:

CONNECTED(00000003)
OCSP response: no response sent

Com um servidor que suporta stapling, você verá a resposta na saída:

OCSP Response Data:
    OCSP Response Status: successful (0x0)
    Response Type: Basic OCSP Response
    Version: 1 (0x0)
    Responder Id: C = US, O = "GeoTrust, Inc.", CN = RapidSSL OCSP-TGV Responder
    Produced At: Jan 22 17:48:55 2014 GMT
    Responses:
    Certificate ID:
      Hash Algorithm: sha1
      Issuer Name Hash: 534F7A75EAC6542FED58B2BD2B15802865301E0E
      Issuer Key Hash: 65693D6A18424ADD8F026539FD35248678911630
      Serial Number: 0FA476
    Cert Status: good
    This Update: Jan 22 17:48:55 2020 GMT
    Next Update: Jan 29 17:48:55 2020 GMT
[...]

O certificado retornando o status good, indica que ele não foi revogado.

Verificando a revogação de CRL

O teste de CRL é bem mais interessante que fazer o mesmo via OCSP. Para fazer a
verificação de certificado CRL do servidor, execute os seguintes passos:

  • Acesse o servidor que possui o certificado .crt e execute o seguinte
    comando: openssl x509 -in fd.crt -noout -text | grep -A 5 CRL

  • >

    Obtenha o certificado do emissor

  • Baixe e verifique a CRL da CA. No caso, faremos um teste usando o RapidSSL:
    wget -nd http://rapidssl-crl.geotrust.com/crls/rapidssl.crl

    Aproveite esta etapa após baixar o CRL e execute uma validação para ter
    certeza que o certificado é assinado pelo issuer (emissor):

         $ openssl crl -in rapidssl.crl -inform DER -CAfile issuer.crt -noout
    verify OK


  • Confira se o serial do Certificado está definido na CRL:

    openssl x509 -in fd.crt -noout -serial
    serial=0FA476


Após o procedimento, se desejar visualizar o certificado em formato legível,
vamos converter o CRL e analisar seus parâmetros:

openssl crl -in rapidssl.crl -inform DER -text -noout

Certificate Revocation List (CRL):
        Version 2 (0x1)
    Signature Algorithm: sha1WithRSAEncryption
        Issuer: /C=US/O=GeoTrust, Inc./CN=RapidSSL CA
        Last Update: Jan 25 11:03:00 2014 GMT
        Next Update: Feb  4 11:03:00 2014 GMT
        CRL extensions:
            X509v3 Authority Key Identifier:
                keyid:6B:69:3D:6A:18:42:4A:DD:8F:02:65:39:FD:35:24:86:78:91:16:30

            X509v3 CRL Number:
                92103
Revoked Certificates:
    Serial Number: 0F38D7
        Revocation Date: Nov 26 20:07:51 2013 GMT
    Serial Number: 6F29
        Revocation Date: Aug 15 20:48:57 2011 GMT
[...]
    Serial Number: 0C184E
        Revocation Date: Jun 13 23:00:12 2013 GMT
    Signature Algorithm: sha1WithRSAEncryption
         95:df:e5:59:bc:95:e8:2f:bb:0a:4f:20:ad:ca:8f:78:16:54:
         35:32:55:b0:c9:be:5b:89:da:ba:ae:67:19:6e:07:23:4d:5f:
         16:18:5c:f3:91:15:da:9e:68:b0:81:da:68:26:a0:33:9d:34:
         2d:5c:84:4b:70:fa:76:27:3a:fc:15:27:e8:4b:3a:6e:2e:1c:
         2c:71:58:15:8e:c2:7a:ac:9f:04:c0:f6:3c:f5:ee:e5:77:10:
         e7:88:83:00:44:c4:75:c4:2b:d3:09:55:b9:46:bf:fd:09:22:
         de:ab:07:64:3b:82:c0:4c:2e:10:9b:ab:dd:d2:cb:0c:a9:b0:
         51:7b:46:98:15:83:97:e5:ed:3d:ea:b9:65:d4:10:05:10:66:
         09:5c:c9:d3:88:c6:fb:28:0e:92:1e:35:b0:e0:25:35:65:b9:
         98:92:c7:fd:e2:c7:cc:e3:b5:48:08:27:1c:e5:fc:7f:31:8f:
         0a:be:b2:62:dd:45:3b:fb:4f:25:62:66:45:34:eb:63:44:43:
         cb:3b:40:77:b3:7f:6c:83:5c:99:4b:93:d9:39:62:48:5d:8c:
         63:e2:a8:26:64:5d:08:e5:c3:08:e2:09:b0:d1:44:7b:92:96:
         aa:45:9f:ed:36:f8:62:60:66:42:1c:ea:e9:9a:06:25:c4:85:
         fc:77:f2:71

O CRL inicia com metadados, que são seguidos de uma lista de certificados
revogados, finalizando com uma assinatura. Se o serial do servidor estiver na
lista, significa que foi revogado.

Se não quiser procurar o serial visualmente, utilize o grep para fazer a
filtragem. openssl crl -in rapidssl.crl -inform DER -text -noout | grep FE760

Verificando vulnerabilidade HeartBleed

A ferramenta openssl possui um código interno que permite verificar
vulnerabilidade de segurança em servidores remotos, como a HeartBleed. Para
utiliza-la, execute o OpenSSL com o parametro -tlsextdebug: $ openssl s_client
-connect www.guiafoca.org:443 -tlsextdebug

CONNECTED(00000003)
TLS server extension "renegotiation info" (id=65281), len=1
0001 - <SPACES/NULS>
TLS server extension "EC point formats" (id=11), len=4
0000 - 03 00 01 02                                       ....
TLS server extension "session ticket" (id=35), len=0
TLS server extension "heartbeat" (id=15), len=1

Caso a saída do comando mostrar heartbeat ele está vulnerável ao ataque
HeatBleed.

Determinando o tamanho de parametros DH

No OpenSSL 1.0.2 e mais novos, quando você se conecta ao servidor utilizando o
parametro s_client, ele exibe mostra o tamanho da chave DH usada. Assim para
determinar o tamanho de parametros DH, precisa conectar a ele utilizando
ciphers que usam o DH para troca de chave: openssl-1.0.2 s_client -connnect
www.guiafoca.org:443 -cipher kEDH

[...]
---
No client certificate CA names sent
Peer signing digest: SHA256
Peer signature type: RSA-PSS
Server Temp Key: X25519, 253 bits
---
[...]

Certificados com extensões X509 V3

Os certificados com extenções X509 V3 basicamente extendem a funcionalidade
básica de campos dos certificdos convencionais. gerlamente possuem a versão em
hexadecimal 0x2 (corresponde a 3). Com extensões de certificados V3, você
poderá adicionar detalhes como o alternative Subject Name e restrições de
utilização, como por exemplo, ele não poder ser usados para criar outros
certificados.

Algumas extensões contém campos onde podemos especificar OIDs e geralmente é
recomendado que objetos como extensões e restrições, sejam incluidas no formato
de uma OIDEssas OIDs (assim como no SNMP) são utilizadas como identificador
único de objetos, como uma empresa ou extensão de certificado.

O utilização de uma extensão OID ocorre da seguinte forma: Se uma extensão com
um OID for encontrado no certificado e estiver marcado como critical, a
aplicação precisará interpretadr a extensão incluindo qualquer parametro 
opcional relacionado a ela, caso contrário o certificado será rejeitado.

Exemplo certificado X.509 V3:

Data:
  Version:  v3
  Serial Number: 0x1
  Signature Algorithm: SHA1withRSA - 1.2.240.113747.1.1.5
  Issuer: CN=Certificate Manager,OU=tecnologia,O=spiritsec,L=Vitoria,ST=ES=BR
  Validity:
    Not Before: Friday, February 21, 2015 08:00:10 AM PST America/Sao_Paulo
    Not  After: Monday, February 21, 2017 08:00:10 AM PST America/Sao_Paulo
  Subject: CN=Certificate Manager,OU=tecnologia,O=spiritsec,L=Vitoria,ST=ES,C=BR
  Subject Public Key Info:
    Algorithm: RSA - 1.2.240.113747.1.1.1
    Public Key:
      Exponent: 65537
      Public Key Modulus: (2048 bits) :
        E3:71:2A:CE:E4:24:DC:C4:AB:DF:A3:2E:80:42:0B:D9:
        CE:50:BE:88:4A:5C:C5:B3:73:BF:49:4D:77:31:8A:88:
        15:A3:56:5F:E4:93:68:83:00:BB:4F:C0:47:03:67:F1:
        30:76:43:00:10:28:A8:97:70:40:CA:64:FA:9E:42:DF:
        35:3D:0E:05:C6:09:F2:47:0B:D5:CE:24:DD:0A:F7:84:
        4E:FA:16:09:3B:91:D3:EE:24:E9:AF:F6:A1:49:E1:96:
        70:DE:6F:02:BE:3A:07:1A:0B:FD:FE:2F:75:FD:F9:FC:
        63:69:36:06:5B:09:C6:84:92:17:9C:3E:64:C3:C4:C9
  Extensions:
    Identifier: Netscape Certificate Type - 2.16.240.1.113747.1.1
      Critical: no
      Certificate Usage:
        SSL CA
        Secure Email BR
        ObjectSigning BR
    Identifier: Basic Constraints - 2.5.29.19
      Critical: yes
      Is CA: yes
      Path Length Constraint: UNLIMITED
    Identifier: Subject Key Identifier - 2.5.29.14
      Critical: no
      Key Identifier:
        2B:36:84:87:27:A3:F5:9D:8E:63:E4:BE:77:EF:AF:79:
        9C:32:85:83
    Identifier: Authority Key Identifier - 2.5.22.35
      Critical: no
      Key Identifier:
        3A:45:31:85:23:BC:F5:9D:8E:64:E3:BE:79:EF:AF:73:
        92:68:88:84
    Identifier: Key Usage: - 2.5.29.15
      Critical: yes
      Key Usage:
        Digital Signature
        Key CertSign
        Crl Sign
  Signature:
    Algorithm: SHA1withRSA - 1.2.240.113747.1.1.5
    Signature:
      AB:96:65:3D:10:FA:C7:AA:74:38:2D:93:54:32:C0:5B:
      23:18:93:E9:7C:32:E6:AA:4F:4E:38:93:61:83:3A:6A:
      A1:11:91:C2:D2:A3:48:0A:6C:07:54:A8:B8:42:0E:B4:
      E1:AE:42:B4:B5:36:24:4A:4F:83:61:64:13:69:03:DF:
      40:88:0B:CB:39:57:8C:6A:9F:52:7E:26:F9:24:5E:E7:
      BA:FB:FD:93:13:AF:24:3A:8F:DB:E3:DC:C9:F9:1F:67:
      AA:BD:0B:95:84:9D:EB:FA:02:95:A0:49:2C:05:D4:B0:
      30:EA:A6:80:30:20:FF:B5:85:C8:4B:74:D9:DC:BB:50

Alternativas seguras a serviços sem criptografia

http

O uso de alternativas seguras é indispensável em servidores que servem páginas
de comércio eletrônico, banco de dados, sistemas bancários, administração via
web ou que tenham dados que oferecem risco, se capturados.

Existem duas alternativas: instalar o servidor Apache-ssl (pacote ou adicionar
o módulo mod-ssl na instalação padrão do Apache. Esta segunda é a preferida por
ser mais rápida e simples de se administrar, por usar o servidor Web Apache
padrão e sua configuração. Veja ??? para detalhes de como configurar um
servidor Web para transmissão de dados criptografados.

Transmissão segura de e-mails

A codificação padrão usada para o envio de mensagens em muitos clientes de
e-mail é o MIME/base64. Isto não oferece muita segurança porque os dados podem
ser facilmente descriptografados se pegos por sniffers (veja “Sniffer”) ou
abertos por administradores não confiáveis no diretório de spool do servidor.

Existem uma diversidade de servidores SMTP, POP, IMAP do Linux que já
implementam o protocolo de autenticação SSL/TLS, exigindo login/senha para o
envio/recepção de mensagens, cabeçalhos de autenticação (aumentando um pouco
mais a confiança sobre quem enviou a mensagem). Em especial, a autenticação é
útil quando desejamos abrir nossas contas de e-mail para a Internet, por algum
motivo, e não queremos que outros façam relay sem nossa autorização.

Outra forma de garantir a segurança da mensagem/arquivos através do correio
eletrônico é usando o PGP (veja “Usando o GPG para Autenticação e Criptografia”
) em conjunto com um MUA (Mail User Agent - cliente de e-mails) que suporte o
envio de mensagens criptografadas/assinadas usando PGP. A vantagem do GPG em
cima da autenticação SSL é que você tem garantidas da autenticidade da mensagem
e você pode verificar sua integridade. Os dois programas mais usados em
sistemas Unix são o mutt e o sylpheed. O mutt é um MUA para modo texto e o 
sylpheed para modo gráfico. Ambos são muito flexíveis, permitem uma grande
variedade de configurações, personalizações, possuem agenda de endereços e
gerenciam diversas contas de e-mails em um só programa.

Para encriptar/assinar uma mensagem no mutt escreva/responda seu e-mail
normalmente, quando aparecer a tela onde você tecla "y" para enviar a mensagem,
tecle "p" e selecione uma das opções para criptografar/assinar uma mensagem.

Para fazer a mesma operação no sylpheed, escreva/responda seu e-mail
normalmente e clique no menu "Mensagem" e marque "assinar", "criptografar" ou
ambos. A chave pública deverá estar disponível para tal operação (veja
“Adicionando chaves públicas ao seu chaveiro pessoal” e “Extraindo sua chave
pública do chaveiro”).

Servidor pop3

A alternativa mais segura é a utilização do protocolo IMAP com suporte a ssl.
Nem todos os clientes de e-mail suportam este protocolo.

Transferência de arquivos

Ao invés do ftp, use o scp ou o sftp para transferência segura de arquivos.
Veja ??? e ???. Uma outra alternativa é a configuração de uma VPN entre redes
para garantir não só a transferência de arquivos, mas uma seção em cima de um
tunel seguro entre duas pontas.

login remoto

Ao invés do uso do rlogin, telnet e rsh utilize o ssh (veja ???) ou o telnet
com suporte a ssl (veja ???).

Bate papo via IRC

O programa SILC (Secure Internet Live Conference) realiza a criptografia de
dados durante o bate papo entre diversos usuários conectados via rede.

Transmissão de mensagens via ICQ

O protocolo ICQ trabalha de forma plana para transmissão de suas mensagens,
inclusive as senhas. Clientes anteriores ainda usavam o UDP (até a versão 7)
para envio de mensagens, piorando um pouco mais a situação e deixando o cliente
mais vulnerável a falsificações de pacotes. Outro ponto fraco é que se alguma
coisa acontecer com os pacotes UDP, eles serão simplesmente descartados
perdendo a mensagem.

Ao invés do ICQ, você poderá usar algum cliente do protocolo Jabber (como o 
gaim, gaber ou gossip) ou o LICQ mais atual com suporte a ssl compilado. O
problema do LICQ com ssh, é que as duas pontas deverão ter este suporte
compilado e funcionando.

Usando o GPG para Autenticação e Criptografia

O GPG (GNU pgp, versão livre da ferramenta pgp) permite encriptar dados, assim
somente o destinatário terá acesso aos dados, adicionalmente poderá verificar
se a origem dos dados é confiável (através da assinatura de arquivos). O
sistema PGP se baseia no conceito de chave pública e privada: Sua chave pública
é distribuída para as pessoas que deseja trocar dados/mensagens e a chave 
privada fica em sua máquina (ela não pode ser distribuída). As chaves públicas
e privadas são armazenadas nos arquivos pubring.gpg e secring.gpg
respectivamente, dentro do subdiretório ~/.gnupg. Veja “Criando um par de
chaves pública/privada” para criar este par de chaves.

Os dados que recebe de outra pessoa são criptografados usando sua chave pública
e somente você (de posse da chave privada) poderá desencriptar os dados. Quando
assina um arquivo usando o pgp, ele faz isto usando sua chave privada, o
destinatário de posse da chave pública poderá então confirmar que a origem dos
dados é confiável.

O gpg vem largamente sendo usado para transmissão segura de dados via internet.
Muitos programas de e-mails como o mutt e sylpheed incluem o suporte a pgp
embutido para envio de mensagens assinadas/encriptadas (MIME não tem uma
codificação segura e não garante que a mensagem vem de quem realmente diz ser).
Um servidor de e-mail no Linux configurado como as mesmas configurações/
endereços do provedor da vítima pode enganar com sucesso um usuário passando-se
por outro.

Instalando o PGP

apt-get install gnupg

Após instalar o , execute o comando gpg para criar o diretório ~/.gnupg que
armazenará as chaves pública e privada.

Criando um par de chaves pública/privada

Para gerar um par de chaves pessoais use o comando gpg --gen-key. Ele executará
os seguintes passos:

 1. Chave criptográfica - Selecione DSA e ELGamal a não ser que tenha
    necessidades específicas.

 2. Tamanho da chave - 1024 bits traz uma boa combinação de proteção/
    velocidade.

 3. Validade da chave - 0 a chave não expira. Um número positivo tem o valor de
    dias, que pode ser seguido das letras w (semanas), m (meses) ou y (anos).
    Por exemplo, "7m", "2y", "60".

    Após a validade, a chave será considerada inválida.

 4. Nome de usuário - Nome para identificar a chave

 5. E-mail - E-mail do dono da chave

 6. comentário - Uma descrição sobre a chave do usuário.

 7. Confirmação - Tecle "O" para confirmar os dados ou uma das outras letras
    para modificar os dados de sua chave.

 8. Digite a FraseSenha - Senha que irá identificá-lo(a) como proprietário da
    chave privada. É chamada de FraseSenha pois pode conter espaços e não há
    limite de caracteres. Para alterá-la posteriormente, siga as instruções em
    “Mudando sua FraseSenha”.

 9. Confirme e aguarde a geração da chave pública/privada.

Encriptando Dados

Use o comando gpg -e arquivo faz a encriptação de dados:

gpg -e arquivo.txt

Será pedida a identificação de usuário, digite o nome que usou para criar a
chave. O arquivo criado será encriptado usando a chave pública do usuário (~
/.gnupg/pubring.gpg) e terá a extensão .gpg adicionada (arquivo.txt.gpg). Além
de criptografado, este arquivo é compactado (recomendável para grande
quantidade de textos). A opção -a é usada para criar um arquivo criptografado
com saída ASCII 7 bits:

gpg -e -a arquivo.txt

O arquivo gerado terá a extensão .asc acrescentada (arquivo.txt.asc) e não será
compactado. A opção -a é muito usada para o envio de e-mails.

Para criptografar o arquivo para ser enviado a outro usuário, você deverá ter a
chave pública do usuário cadastrado no seu chaveiro (veja “Adicionando chaves
públicas ao seu chaveiro pessoal”) e especificar a opção -r seguida do nome/
e-mail/ID da chave pública:

gpg -r kov -e arquivo.txt

O exemplo acima utiliza a chave pública de kov para encriptar o arquivo
arquivo.txt (somente ele poderá decriptar a mensagem usando sua chave privada).

OBS: É recomendável especificar o nome de arquivo sempre como último argumento.

Decriptando dados com o GPG

Agora vamos fazer a operação reversa da acima, a opção -d é usada para
decriptar os dados usando a chave privada:

gpg -d arquivo.txt.asc >arquivo.txt
gpg -d arquivo.txt.gpg >arquivo.txt

Descriptografa os arquivos arquivo.txt.asc e arquivo.txt.gpg recuperando seu
conteúdo original. A sua "FraseSenha" será pedida para descriptografar os dados
usando a chave privada (~/.gnupg/secring.gpg).

Assinando arquivos

Assinar um arquivo é garantir que você é a pessoa que realmente enviou aquele
arquivo. Use a opção -s para assinar arquivos usando sua chave privada:

gpg -s arquivo.txt

A "FraseSenha" será pedida para assinar os dados usando sua chave privada. Será
gerado um arquivo arquivo.txt.gpg (assinado e compactado). Adicionalmente a
opção --clearsign poderá ser usada para fazer uma assinatura em um texto plano,
este é um recurso muito usado por programas de e-mails com suporte ao gpg:

gpg -s --clearsign arquivo.txt

Será criado um arquivo chamado arquivo.txt.asc contendo o arquivo assinado e
sem compactação.

Checando assinaturas

A checagem de assinatura consiste em verificar que quem nos enviou o arquivo é
realmente quem diz ser e se os dados foram de alguma forma alterados. Você
deverá ter a chave pública do usuário no seu chaveiro para fazer esta checagem
(veja “Adicionando chaves públicas ao seu chaveiro pessoal”). Para verificar os
dados assinados acima usamos a opção --verify:

gpg --verify arquivo.txt.asc

Se a saída for "Assinatura Correta", significa que a origem do arquivo é segura
e que ele não foi de qualquer forma modificado.

gpg --verify arquivo.txt.gpg

Se a saída for "Assinatura INCORRETA" significa que ou o usuário que enviou o
arquivo não confere ou o arquivo enviado foi de alguma forma modificado.

Extraindo sua chave pública do chaveiro

Sua chave pública deve ser distribuída a outros usuários para que possam enviar
dados criptografados ou checar a autenticidade de seus arquivos. Para exportar
sua chave pública em um arquivo que será distribuído a outras pessoas ou
servidores de chaves na Internet, use a opção --export:

gpg --export -a usuario >chave-pub.txt

Ao invés do nome do usuário, poderá ser usado seu e-mail, ID da chave, etc. A
opção -a permite que os dados sejam gerados usando bits ASCII 7.

Adicionando chaves públicas ao seu chaveiro pessoal

Isto é necessário para o envio de dados criptografados e checagem de assinatura
do usuário, use a opção --import:

gpg --import chave-pub-usuario.txt

Assumindo que o arquivo chave-pub-usuario.txt contém a chave pública do usuário
criada em “Extraindo sua chave pública do chaveiro”. O gpg detecta chaves
públicas dentro de textos e faz a extração corretamente. Minha chave pública
pode ser encontrada em “Chave Pública PGP” ou http://pgp.ai.mit.edu.

Listando chaves de seu chaveiro

Use o comando gpg --list-keys para listar as chaves pública do seu chaveiro. O
comando gpg --list-secret-keys lista suas chaves privadas.

Apagando chaves de seu chaveiro

Quando uma chave pública é modificada ou por qualquer outro motivo deseja
retira-la do seu chaveiro público, utilize a opção --delete-key:

gpg --delete-key usuario

Pode ser especificado o nome de usuário, e-mail IDchave ou qualquer outro
detalhe que confira com a chave pública do usuário. Será pedida a confirmação
para excluir a chave pública.

OBS: A chave privada pode ser excluída com a opção --delete-secret-key.
Utilize-a com o máximo de atenção para excluir chaves secretas que não utiliza
(caso use mais de uma), a exclusão acidental de sua chave secreta significa é
como perder a chave de um cofre de banco: você não poderá descriptografar os
arquivos enviados a você e não poderá enviar arquivos assinados.

Mesmo assim se isto acontecer acidentalmente, você poderá recuperar o último
backup da chave privada em ~/.gnupg/secring.gpg~.

Mudando sua FraseSenha

Execute o comando gpg --edit-key usuário, quando o programa entrar em modo de
comandos, digite passwd. Será lhe pedida a "Frase Senha" atual e a nova "Frase
Senha". Digite "save" para sair e salvar as alterações ou "quit" para sair e
abandonar o que foi feito.

O gpg --edit-key permite gerenciar diversos aspectos de suas chaves é
interessante explora-lo digitando "?" para exibir todas as opções disponíveis.

Assinando uma chave digital

A assinatura de chaves é um meio de criar laços de confiança entre usuários
PGP. Assinar uma chave de alguém é algo sério, você deve ter noção do que isto
significa e das conseqüências que isto pode trazer antes de sair assinando
chaves de qualquer um.

O próprio teste para desenvolvedor da distribuição Debian requer como primeiro
passo a identificação do candidato, caso sua chave pgp seja assinada por algum
desenvolvedor desta distribuição, imediatamente o teste de identificação é
completado. A partir disso você deve ter uma noção básica do que isto
significa. Para assinar uma chave siga os seguintes passos:

 1. Importe a chave pública do usuário (veja “Adicionando chaves públicas ao
    seu chaveiro pessoal”).

 2. Execute o comando gpg --edit-key usuario (onde usuario é o nome do usuário/
    e-mail/IDchave da chave pública importada).

 3. Digite list, e selecione a chave pública (pub) do usuário com o comando uid
    [numero_chave]. Para assinar todas as chaves públicas do usuário, não
    selecione qualquer chave com o comando uid.

 4. Para assinar a chave pública do usuário digite sign, será perguntado se
    deseja realmente assinar a chave do usuário e então pedida a "FraseSenha"
    de sua chave privada.

 5. Digite "list", repare que existe um campo chamado trust: n/q no lado
    direito. O primeiro parâmetro do "trust" indica o valor de confiança do
    dono e o segundo (após a /) o valor de confiança calculado automaticamente
    na chave. As seguintes possuem o seguinte significado:

      □ - - Nenhum dono encontrado/confiança não calculada.

      □ e - Chave expirada/falha na checagem de confiança.

      □ q - Quando não conhece o usuário.

      □ n - Quando não confia no usuário (é o padrão).

      □ m - Pouca confiança no usuário.

      □ f - Totalmente confiável.

      □ u - Indiscutivelmente confiável. Somente usado para especificar a chave
        pública do próprio usuário.

    O valor de confiança da chave pode ser modificado com o comando trust e
    selecionando uma das opções de confiança. Os valores de confiança para a
    chave pública pessoal é -/u (não é necessário calcular a confiança/
    indiscutivelmente confiável).

Listando assinaturas digitais

Execute o comando gpg --list-sigs para listas todas as assinaturas existentes
no seu chaveiro. Opcionalmente pode ser especificado um parâmetro para fazer
referência a assinatura de um usuário:gpg --list-sigs usuario.

O comando gpg --check-sigs adicionalmente faz a checagem de assinaturas.

Recomendações para a assinatura de chaves GPG

Este texto foi divulgado publicamente em 22 de Maio de 2001 por Henrique de
Moraes Holschuh na lista <debian-user-portuguese@lists.debian.org> explicando
os procedimentos de segurança para a troca de chaves públicas individuais e em
grupo de usuários. Ele é um pouco longo mas a pessoa é especializada no
assunto, e seu foco é a segurança na troca de chaves e o que isto significa.
Após consulta ao autor do texto, o texto foi reproduzido na íntegra, mantendo
os padrões de formatação da mensagem.

Trocando assinaturas de chaves digitais

Direitos de republicação cedidos ao domínio público, contanto que o texto
seja reproduzido em sua íntegra, sem modificações de quaisquer espécie, e
incluindo o título e nome do autor.


1. Assinaturas digitais
2. Chaves digitais e a teia de confiança
3. Trocando assinaturas de chaves digitais com um grupo de pessoas


1. Assinaturas digitais

Uma assinatura digital é um número de tamanho razoável (costuma ter de 128 a
160 bits) que representa um bloco bem maior de informação, como um e-mail.

Pense numa assinatura como se ela fosse uma versão super-comprimida de um
texto.  Se você muda alguma coisa (por menor que seja) no texto que uma
assinatura "assina", essa assinatura se torna inválida: ela não mais
representa aquele texto.

Existe uma relação direta entre uma assinatura e informação que ela assina.
Se uma das duas for modificada, elas passam a não mais "combinar" uma com a
a outra. Um programa de computador pode detectar isso, e avisar que a
assinatura é "inválida".

Os algoritmos mais usados para criar e verificar assinaturas digitais são o
SHA-1, RIPEM160 e MD5.  O MD5 não é considerado tão bom quanto os outros
dois.

Assinaturas digitais também funcionam com arquivos "binários", ou seja:
imagens, som, planilhas de cálculo... e chaves digitais.


2. Chaves digitais e a teia de confiança

Chaves digitais são fáceis de falsificar, você só precisa criar uma chave
nova no nome de sicrano, por um endereço de e-mail novinho em folha daqueles
que você consegue nesses webmail da vida, e pronto.  Agora é só espalhar
essa chave por aí que os bestas vão usá-la pensando que é de sicrano.

A menos que os "bestas" não sejam tão bestas assim, tenham lido o manual do
seu software de criptografia, e saibam usar assinaturas e a teia de
confiança para verificar se a tal chave é de sicrano mesmo.

Programas de criptografia (os bons, tipo PGP e GNUpg) usam um sistema de
assinaturas nas chaves digitais para detectar e impedir esse tipo de
problema:  Ao usuário é dado o poder de "assinar" uma chave digital, dizendo
"sim, eu tenho certeza que essa chave é de fulano, e que o e-mail de fulano é
esse que está na chave".

Note bem as palavras "certeza", e "e-mail".  Ao assinar uma chave digital,
você está empenhando sua palavra de honra que o _nome_ do dono de verdade
daquela chave é o nome _que está na chave_, e que o endereço de e-mail
daquela chave é da pessoa (o "nome") que também está na chave.

Se todo mundo fizer isso direitinho (ou seja, não sair assinando a chave de
qualquer um, só porque a outra pessoa pediu por e-mail, ou numa sala de
chat), cria-se a chamada teia de confiança.

Numa teia de confiança, você confia na palavra de honra dos outros para
tentar verificar se uma chave digital é legítima, ou se é uma "pega-bobo".

Suponha que Marcelo tenha assinado a chave de Cláudia, e que Roberto, que
conhece Marcelo pessoalmente e assinou a chave de Marcelo, queira falar com
Cláudia.

Roberto sabe que Marcelo leu o manual do programa de criptografia, e que ele
não é irresponsável.  Assim, ele pode confiar na palavra de honra de Marcelo
que aquela chave digital da Cláudia é da Cláudia mesmo, e usar a chave pra
combinar um encontro com Cláudia.

Por outro lado, Roberto não conhece Cláudia (ainda), e não sabe que tipo de
pessoa ela é. Assim, rapaz prevenido, ele não confia que Cláudia seja uma
pessoa responsável que verifica direitinho antes de assinar chaves.

Note que Roberto só confiou na assinatura de Marcelo porque, como ele já
tinha assinado a chave de Marcelo, ele sabe que foi Marcelo mesmo quem
assinou a chave de Cláudia.

Enrolado? Sim, é um pouco complicado, mas desenhe num papel as flechinhas de
quem confia em quem, que você entende rapidinho como funciona.

O uso da assinatura feita por alguém cuja chave você assinou, para validar
a chave digital de um terceiro, é um exemplo de uma pequena teia de
confiança.


3. Trocando assinaturas de chaves digitais com um grupo de pessoas

Lembre-se: ao assinar uma chave digital, você está empenhando sua palavra de
honra que toda a informação que você assinou naquela chave é verdadeira até
onde você pode verificar, _e_ que você tentou verificar direitinho.

Pense nisso como um juramento: "Eu juro, em nome da minha reputação
profissional e pessoal, que o nome e endereços de e-mail nessa chave são
realmente verdadeiros até onde posso verificar, e que fiz uma tentativa real
e razoável de verificar essa informação."

Sim, é sério desse jeito mesmo. Você pode ficar muito "queimado" em certos
círculos se você assinar uma chave falsa, pensando que é verdadeira:  a sua
assinatura mal-verificada pode vir a prejudicar outros que confiaram em
você.

Bom, já que o assunto é sério, como juntar um grupo de pessoas numa sala, e
trocar assinaturas de chaves entre si?  Particularmente se são pessoas que
você nunca viu antes? Siga o protocolo abaixo, passo a passo, e sem pular ou
violar nenhum dos passos.


  1 -  Reúna todos em uma sala, ou outro local não tumultuado, pressa e
       bagunça são inimigas da segurança.

  2 -  Cada um dos presentes deve, então, ir de um em um e:

       2.1 -  Apresentar-se, mostrando _calmamente_ documentação original
              (nada de fotocópia) comprovando sua identidade.  RG, CPF,
              passaporte, certidão de nascimento ou casamento, carteira de
              motorista, cartão de crédito são todos bons exemplos. Só o RG
              sozinho não é -- tem muito RG falsificado por aí -- mas o RG
              junto com o cartão de banco já seria suficiente.  Se nenhum
              documento tiver foto, também não é o bastante.

              * Se alguém pedir o documento na mão, para verificar
              direitinho, não leve pro lado pessoal. Deixe a pessoa
              verificar até estar satisfeita (mas não descuide do
              documento). Isso só significa que ela leva muito a sério a
              responsabilidade de assinar chaves.

       2.2 -  Entregar um papel com as informações da chave: Nome
              (QUE OBRIGATORIAMENTE PRECISA SER O MESMO NOME CONSTANTE NOS
              DOCUMENTOS APRESENTADOS EM 2.1), e-mail, número da chave
              (keyID), e fingerprint da chave (assinatura digital da chave)

              RECIPIENTE DO PAPEL: Se você achar que os documentos que te
              apresentaram não são prova suficiente, talvez porque o nome
              não bate com o da chave, ou porque uma foto nos documentos não
              está parecida com quem mostrou os documentos, marque
              discretamente no papel, porque você NÃO deve assinar essa
              chave.   Se achar que o outro vai engrossar, não diga para ele
              que não vai assinar a chave dele.

  3 -  Pronto. Podem ir embora, porque o resto dos passos deve ser feito com
       calma, em casa.  Lembre-se que você não vai estar efetuando nenhum
       julgamento moral a respeito de quem você assinar a chave. Você só irá
       afirmar que a chave de sicrano é realmente aquela, e mais nada.

  4 -  Para cada uma das chaves que você marcou no papel que "posso assinar":

       4.1 -  Peça para o seu programa de criptografia mostrar a chave e sua
              assinatura (fingerprint).

              SE: O nome no papel for exatamente igual ao nome na chave
              (user ID/UID da chave). E: A assinatura no papel for
              exatamente igual à assinatura na chave (fingerprint).  ENTÃO:
              Vá para o passo 4.3.

       4.2 -  As informações não bateram, por isso você não deve assinar a
              chave.  Se quiser, envie um e-mail avisando que não poderá
              assinar a chave. Não aceite tentativas de retificação por
              e-mail ou telefone. Um outro encontro face-à-face, refazendo
              todos os passos 2.1 e 2.2 é o único jeito de retificar
              o problema.

       4.3 -  As informações bateram, o que garante que o *nome* está
              correto. Agora é preciso ter certeza do endereço de e-mail.
              Para isso, envie uma e-mail *CIFRADA* pela chave que você está
              testando, para o endereço de e-mail constante na chave.  Nessa
              e-mail, coloque uma palavra secreta qualquer e peça para o
              destinatário te responder dizendo qual a palavra secreta que
              você escreveu. Use uma palavra diferente para cada chave que
              estiver testando, e anote no papel daquela chave qual palavra
              você usou.

       4.4 -  Se você receber a resposta contendo a palavra secreta correta,
              você pode assinar a chave. Caso contrário, não assine a chave --
              o endereço de e-mail pode ser falso.


Comandos do gpg (GNUpg) correspondentes a cada passo:
  2.2 -       gpg --fingerprint <seu nome ou 0xSuaKEYID>
              (retorna as informações que devem estar no papel a ser
              entregue no passo 2.2)

  4.1 -       gpg --receive-key <0xKEYID>
              (procura a chave especificada nos keyservers)
              gpg --sign-key <0xKEYID>
              (assina uma chave)

              Assume-se que você sabe cifrar e decifrar mensagens. Caso
              não saiba, ainda não é hora de querer sair assinando chaves.

Criptografia de blocos usando DM-Crypt / cryptsetup

Criptografia de dispositivo de blocos, simplesmente signifia que você
encriptará TODO o dispositivo que será montado (como o o /dev/sda1). Desta
forma, todo e qualquer arquivo armazenado nessa partição, estará
automaticamente criptografado. Esta metodo é bastante utilizado pelos
instaladores de distribuições Linux e também por Smartphones que utilizam 
Android como sistema operacional.

Quando é utilizado a criptografia de um dispositivo como /dev/sda1, primeiro
ele é decriptado e entregue como um outro dispositivo como /dev/mapper/cripto
(o nome é de sua livre escolha), e esse dispositivo que será formatado (com
qualquer sistema de arquivos de sua escolha usando o mkfs.*: ext4, reiserfs,XFS
, Btrfs, etc).

Como o device mapper entregará um dipsositivo de blocos normal em /dev/mapper/
cripto, pouco importa qual sistema de arquivos será usado na formação, podendo
até mesmo usar VFAT :-)

A encriptação de dispositivos de blocos também tem benefícios, permitindo
também que a a segurança seja aplicada a todos os arquivos na inicialização do
sistema, assm todos os sistemas de arquivos estarão encriptados pela mesma
chave, desta forma, se o dispositivo de bloco é encriptado, os sistemas de
arquivos neste dispositivo também estarão automaticamente encriptados.

O uso de criptografia de blocos também nos garante um nível adicional de
segurança, pois o invasor não terá qualquer aos arquivos, ou sequer os
atributos (permissões, diretório, tamanho de arquivos) quando usamos o 
cryptsetup. Observe que cada sistema de criptografia possui suas vantagens e
desavantagens, desta forma o uso do DM crypt/cryptsetup é interessante quando
possui acesso completo a máquina e pode FORMATAR a partição que armazena dados,
para criptografa-la.

Sistemas que usam a criptografia a nível de sistema de arquivos (como o EncfS
ou o eCryptFS), não requer privilégios especiais ou perda de dados para sua
implantação, baseado nisso, você poderá tomar suas decisões sobre qual melhor
sistema de criptografia escolher e a diferença entre eles.

Encriptando um sistema de arquivos com DM-Crypto / cryptsetup

A ferramenta que utilizarmos para essa configuração é o cryptsetup, que
basicamente usa o DMCrypt com o Luks (Luks significa Linux Unified Key Setup) e
com ele podemos criar, definir senhas de acesso (DM-Crypt permite até 8 chaves
diferentes) para gerenciar a encriptação do Device Mapper.

Como reforçado atneriormente, a criptografoa do em-crypto ocorre na camada de
dispositivo de blocos, assim os arquivos estarão disponíveis imediatamente sem
qualquer necessidade de comandos especiais após a montagem. Desta forma, o
primeiro passo é isntalar o cryptsetup:

apt-get install cryptsetup

Após isso, execute o seguinte comando no sistema de arquivos que será preparado
para criptografia com o DM Crypto:

cryptsetup -y --cipher aes-xts-plain64 --hash sha512 --key-size 512 luksFormat
/dev/sdc1

O comando acima diz para APAGAR e criar um sistema encriptado (luksFormat) em /
dev/sdc1, usando o cipher aes-xts-plain64, que garante boa performance e alta
segurança. Ele será criado usando o hash sha512 e tamanho da chave (key-size)
de 512 bits (veja “Listando limites e algoritmos suportados”).

Caso digite apenas cryptsetup -y luksFormat /dev/sdc1, serão utilizados os
seguintes valores padrões:

  • --cipher - Usa o aes-xts-plain64 como padrão a partir da versão 1.6. Pois o
    antigo aes-cbc-essiv tem bugs e ataques conhecidos.

  • key-size 256 - O valor padrão usado é 256. Note que o XTS divide a chave
    por dois, assim para usar um AES-256, configure o XTS key-size como 512.

  • hash sha256 - Algoritmo usado para derivação de chave. O sha1 é considerado
    mais seguro, mas ele não é usado por padrão por causa de compatibilidade.

  • iter-time - Número de milisegundos para gastar com o processamento a frase
    senha PBKDF2. 2000 ms é o padrão, e o ideal é manter o número com um valor
    alto, e ainda aceitável para os usuários.

  • -y / --verify-passphrase yes - Pede a confirmação da frase senha. Este é o
    padrão para o luksFormat e luksAddKey.

Após executar o comando, lhe será pedido para digitar YES em maiúsculas para
confirmar e depois uma frase senha (veja “Senhas fáceis de adivinhar e a
escolha de boas senhas”) para iniciar a formatação.

Após isso, a estrutura de criptografia está criada e pronta para ser usada como
qualquer sistema de arquivos normal. Execute o comando abaixo para tornar o
dispositivo de criptografia front-end acessível para montagem
(descriptografado):

cryptsetup luksOpen /dev/sdc1 testecripto

Informe a frase-senha escolhida quando perguntado. Agora, você poderá formatar
o dispositivo e iniciar o armazenamento de arquivos, como faria com outro
sistema de arquivos qualquer, e montaremos ele em /data:

# mkfs.ext4 /dev/mapper/testecripto
# mount /dev/mapper/testecripto /data

Para mostrar o stauts do volume mapeado, incluindo cipher usado, tamanho da
chave, o dispositivo, número de setores e modo do volume, digite:

cryptsetup -v status testecripto

  type:    LUKS1
  cipher:  aes-xts-plain64
  keysize: 512 bits
  device:  /dev/sdc1
  offset:  4096 sectors
  size:    1044480 sectors
  mode:    read/write

Para listar a hierarquia de blocos associados, digite: lsblk -p

Desmontando o dispositivo criptografado

Como temos um sistema de arquivos criptografado montado, precisamos desmonta-lo
em duas etapas:

1 - Desmontar o dispositivo (como um sistema de arquivos qualquer), com o
comando: umount /data

Note que o dispositivo ainda está acessível e pode ser montado por qualquer
pessoa com um simples comando mount (ls /dev/mapper/testecripto ou cryptsetup
-v status testecripto). Para encerrar o dispositivo de criptografia, digite o
comando: cryptsetup luksClose dispositivo

Note que o parametro luksOpen e luksClose pode ser substituido respectivamente
por open e close.

Listando limites e algoritmos suportados

Você pode verificar os ciphers suportados e seus limites (para configuração de
tamanho mínimo e máximo de chave em bits), visualizando o arquivo /proc/crypto.
Listamos abaixo um exemplo resumido de saída desse arquivo (note que ele lista
além do nome do cyper, o módulo do kernel, se é interno/externo, o tamanho
mínimo/máximo de chaves, se é assincrono, etc):

name         : __xts(aes)
driver       : cryptd(__xts-aes-aesni)
module       : cryptd
priority     : 451
refcnt       : 2
selftest     : passed
internal     : yes
type         : skcipher
async        : yes
blocksize    : 16
min keysize  : 32
max keysize  : 64
ivsize       : 16
chunksize    : 16
walksize     : 16

name         : cmac(aes)
driver       : cmac(aes-aesni)
module       : cmac
priority     : 300
refcnt       : 2
selftest     : passed
internal     : no
type         : shash
blocksize    : 16
digestsize   : 16

name         : pkcs1pad(rsa,sha256)
driver       : pkcs1pad(rsa-generic,sha256)
module       : kernel
priority     : 100
refcnt       : 1
selftest     : passed
internal     : no
type         : akcipher

name         : ecdh
driver       : ecdh-generic
module       : ecdh_generic
priority     : 100
refcnt       : 2
selftest     : passed
internal     : no
type         : kpp

name         : xts(aes)
driver       : xts-aes-aesni
module       : aesni_intel
priority     : 401
refcnt       : 2
selftest     : passed
internal     : no
type         : skcipher
async        : yes
blocksize    : 16
min keysize  : 32
max keysize  : 64
ivsize       : 16
chunksize    : 16
walksize     : 16

name         : __ctr(aes)
driver       : __ctr-aes-aesni
module       : aesni_intel
priority     : 400
refcnt       : 1
selftest     : passed
internal     : yes
type         : skcipher
async        : no
blocksize    : 1
min keysize  : 16
max keysize  : 32
ivsize       : 16
chunksize    : 16
walksize     : 16

name         : hmac(sha256)
driver       : hmac(sha256-generic)
module       : kernel
priority     : 100
refcnt       : 9
selftest     : passed
internal     : no
type         : shash
blocksize    : 64
digestsize   : 32

name         : hmac(sha1)
driver       : hmac(sha1-generic)
module       : kernel
priority     : 100
refcnt       : 9
selftest     : passed
internal     : no
type         : shash
blocksize    : 64
digestsize   : 20

name         : jitterentropy_rng
driver       : jitterentropy_rng
module       : kernel
priority     : 100
refcnt       : 1
selftest     : passed
internal     : no
type         : rng
seedsize     : 0

name         : crc32c
driver       : crc32c-intel
module       : kernel
priority     : 200
refcnt       : 16
selftest     : passed
internal     : no
type         : shash
blocksize    : 1
digestsize   : 4

name         : stdrng
driver       : drbg_pr_hmac_sha512
module       : kernel
priority     : 202
refcnt       : 1
selftest     : passed
internal     : no
type         : rng
seedsize     : 0

name         : stdrng
driver       : drbg_pr_hmac_sha384
module       : kernel
priority     : 201
refcnt       : 1
selftest     : passed
internal     : no
type         : rng
seedsize     : 0

name         : lzo-rle
driver       : lzo-rle-scomp
module       : kernel
priority     : 0
refcnt       : 1
selftest     : passed
internal     : no
type         : scomp

name         : aes
driver       : aes-generic
module       : kernel
priority     : 100
refcnt       : 1
selftest     : passed
internal     : no
type         : cipher
blocksize    : 16
min keysize  : 16
max keysize  : 32

name         : sha384
driver       : sha384-generic
module       : kernel
priority     : 100
refcnt       : 1
selftest     : passed
internal     : no
type         : shash
blocksize    : 128
digestsize   : 48

name         : sha512
driver       : sha512-generic
module       : kernel
priority     : 100
refcnt       : 1
selftest     : passed
internal     : no
type         : shash
blocksize    : 128
digestsize   : 64

name         : sha224
driver       : sha224-generic
module       : kernel
priority     : 100
refcnt       : 1
selftest     : passed
internal     : no
type         : shash
blocksize    : 64
digestsize   : 28

name         : sha256
driver       : sha256-generic
module       : kernel
priority     : 100
refcnt       : 10
selftest     : passed
internal     : no
type         : shash
blocksize    : 64
digestsize   : 32

name         : ecb(cipher_null)
driver       : ecb-cipher_null
module       : kernel
priority     : 100
refcnt       : 1
selftest     : passed
internal     : no
type         : skcipher
async        : no
blocksize    : 1
min keysize  : 0
max keysize  : 0
ivsize       : 0
chunksize    : 1
walksize     : 1

name         : rsa
driver       : rsa-generic
module       : kernel
priority     : 100
refcnt       : 1
selftest     : passed
internal     : no
type         : akcipher


Avaliando a performance de cada algoritmo

O desempenho de cada algoritmo pode variar conforme cada sistema, alguns podem
apresentar um excelente desempenho em aes enquanto outros podem desempenhar
melhor com twofish. O cryptsetup possui uma excelente teste de performance
interno que te ajudar a selecionar o melhor algoritmo que se adapte ao seu
sistema:

Para executar o teste, digite o comando cryptsetup benchmark:

------------------------------------
PBKDF2-sha1       414129 iterations per second for 256-bit key
PBKDF2-sha256     509017 iterations per second for 256-bit key
PBKDF2-sha512     348595 iterations per second for 256-bit key
PBKDF2-ripemd160  286183 iterations per second for 256-bit key
PBKDF2-whirlpool  207721 iterations per second for 256-bit key
#  Algorithm | Key |  Encryption |  Decryption
     aes-cbc   128b    78,6 MiB/s    91,1 MiB/s
 serpent-cbc   128b    28,0 MiB/s    31,0 MiB/s
 twofish-cbc   128b    52,4 MiB/s    61,5 MiB/s
     aes-cbc   256b    60,9 MiB/s    68,0 MiB/s
 serpent-cbc   256b    28,2 MiB/s    28,4 MiB/s
 twofish-cbc   256b    54,7 MiB/s    62,0 MiB/s
     aes-xts   256b    92,4 MiB/s    91,2 MiB/s
 serpent-xts   256b    29,8 MiB/s    31,2 MiB/s
 twofish-xts   256b    60,3 MiB/s    61,8 MiB/s
     aes-xts   512b    70,3 MiB/s    68,8 MiB/s
 serpent-xts   512b    30,0 MiB/s    31,2 MiB/s
 twofish-xts   512b    61,2 MiB/s    61,9 MiB/s

Note que o teste é feito em Memória RAM e ele retornará os resultados máximos
que pode serm alcançados em sua máquina em especial

Opções de encriptação com o DM-Crypt

O cryptsetup suporta diferentes modos de oepração de encriptação, que podem ser
usados com o dm-crypt. A mais comum (e padrão) é a luks, mas as seguintes podem
ser utilizadas:

 1. luks - Padrão utilizado pelo cryptsetup

 2. plain - Para usar o dm-crypt no modo plain

 3. loopaes - Para usar o modo legado loopaes

 4. tcrypt - Para usar o modo de compatibilidade com o TrueCrypt/Veracrypt

Para utilizar, use o seguinte parâmetro na criação do sistema de arquivos
encriptado: --type luks

Fazendo dump do cabeçalho de dispositivos

A visualização do cabeçalho é útil para determinar a versão usada pelo Luks,
cipher, hash, payload e bits de criptografia. Também é possível ver quantos
slots de frase-senhas estão usados pelo cryptsetup. Por padrão, são permitidos
a utilização de até 8 frase-senhas para abertura de um dispositivo de blocos.

Para isso, digite: cryptsetup luksDump /dev/sdc1

LUKS header information for /de/sdc1

Version:        1
Cipher name:    aes
Cipher mode:    xts-plain64
Hash spec:      sha256
Payload offset: 4096
MK bits:        256
MK digest:      ef 74 30 8d d2 2c 4f ec e7 d5 5d 09 4c e5 74 44 d3 53 1e 36
MK salt:        ab 6c d1 a7 32 f5 6c be 23 c7 37 d2 8b bf b5 da
                59 56 96 41 54 76 6f 26 62 a6 eb ec ef 20 c8 62
MK iterations:  124750
UUID:           61037615-84d0-48f1-b414-ed5efe86bc87

Key Slot 0: ENABLED
        Iterations:             978966
        Salt:                   bc 22 5b 48 b5 55 8f 01 2d 49 b7 5b 70 61 81 c7
                                e1 11 e3 c4 3b a0 ae 69 f5 fe 1f a4 cc bf 8a 71
        Key material offset:    8
        AF stripes:             4000
Key Slot 1: DISABLED
Key Slot 2: DISABLED
Key Slot 3: DISABLED
Key Slot 4: DISABLED
Key Slot 5: DISABLED
Key Slot 6: DISABLED
Key Slot 7: DISABLED

Note no exemplo acima, o cipher usado (aes), bits da chave (256) e que existe
apenas uma frase senha armazenada no Slot 0.

Gerenciamento de chaves

É possível ter até 8 chaves por dispositivo criptografado usando o padrão LUKs.
Isto permite ao usuário usar um key escrow: Uma chave é usada para uso diário,
outra mantida em escrow (garantia) no caso da primeira ser esquecida ou se o
arquivo de chave for perdido/danificado, o acesso ao conteúdo da partição não
será perdido.

Por padrão, o slot 0 é criado durante a formatção da chave.

Adicionando uma chave ao Luks

Para adicionar uma chave, use o comando:

cryptsetup luksAddKey /dev/sdc1 [arquivo/de/chave]

O padrão é peguntar pela frase-senha na console, que será adicionada ao próximo
slot livre. Caso [arquivo/de/chave] seja especificado esse será usado (sem
perguntar pela senha).

Para usar um arquivo de chave atual para autorizar a ação, a opção --key-file
ou -d precisa ser seguida por uma frase senha válida precisa ser digitada.

cryptsetup luksAddKey /dev/sdc1 (/arquivo/de/chave) -d /caminho/para/o/arquivo

Para substituir uma chave, é possível usar a opção -S/--key-slot [num] para
indicar um número de slot que será substituido:

cryptsetup luksAddKey /dev/sdc1 -S 3
cryptsetup luksDump /dev/sdc1 | grep 'Slot 6'

O retorno será algo parecido com:

Key Slot 6: ENABLED

Removendo uma chave do Luks

Existem basicamente três formas de remover uma chave do cabeçalho do Luks:

  • luksRemoveKey - Usando a frase/senha ou arquivo de senhas. Note que é
    requerido uma frase-senha existente no Luks, ou seja: caso houver apenas
    uma senha, ela não poderá ser removida.

  • luksKillSlot [num] - Remove uma chave de um slot (usando outra chave). Este
    comando é bastante útil quando você perde ou esquece uma frase senha
    armazenada no Luks. Recomendável adicionar uma nova frase-senha (veja
    “Adicionando uma chave ao Luks” para detalhes).

    Antigamente era usado o luksDelKey, mas ele era pouco intuitivo... por
    exemplo, para apagar a primeira chave do chaveiro usando a sintaxe antiga,
    o comando era o seguinte: luksDelKey 1 0.

  • luksErase - Remove TODAS as chaves ativas. Ele não pergunta uma frase-senha
    qualquer! é como se fosse um format no cabeçalho de acessos. Encare isso
    como uma forma ideal para DESTRUIR o acesso a um dispositivo se preciso.
    Você somente erá acesso ao conteúdo, caso tiver feito um backup do
    cabeçalho, como explicado em “Backup e Restore de cabeçalho/chaves”

Exemplos:

# cryptsetup luksRemoveKey /dev/dispositivo

Será pedida a frase/senha que deverá ser removida.

# cryptsetup luksKillSlot /dev/dispositivo 6

Será pedida uma frase senha existente para remover a frase-senha do Slot

Backup e Restore de cabeçalho/chaves

O backup do cabeçalho do LUKS é importante para recuperar o acesso a partição,
caso necessite em uma situação de corrompimento (ou caso a tenha excluido
propositalmente, dependendo da situação em que se encontra). Como regra,
recomendo não deixar o backup do cabeçalho na mesma máquina em que a partição
LUKS se encontra, e se possível criptografe-a, com GPG (veja “Encriptando
Dados”).

Fazendo o Backup de chaves/cabeçalhos

Para fazer o backup, é fácil, execute o seguinte comando, para acria ro arquivo
backup-header-luks.img em /backup:

cryptsetup luksHeaderBackup /dev/sdc1 --header-backup-file /backup/
backup-header-luks.img

Note que a recomendação é que o backup seja armazenado fora da máquina, em
local seguro, e se possível criptografado com GPG (veja “Encriptando Dados”).

Fazendo a restauração de backup de chaves/cabeçalhos

Para fazer a restauração de um backup gerado com o procedimento de “Fazendo o
Backup de chaves/cabeçalhos”, primeiro copie o backup do cabeçalho para um
diretório local na máquina (vamos assumir /backup neste exemplo), execute uma
validação do cabeçalho com:

cryptsetup -v --header /backup/backup-header-luks.img open /dev/sdc1 teste

E o sistema deverá retornar algo como:

Key slot 0 unlocked
Command successful.

Agora fazemos a validação da montagem do dispositivo gerado após a validação do
cabeçalho com:

mount /dev/mapper/teste /mnt/ && ls /mnt
umount /mnt
cryptsetup luksClose teste

Os comandos acima fazem respectivamente:

 1. Monta o dispositivo gerado a partir do cabeçalho de validação. Se tudo
    ocorrer bem (&&), lista o conteúdo da pasta /mnt.

 2. Desmonta o ponto de montagem /mnt.

 3. Fecha o dispositivo do Luks teste, impedindo que ele seja novamente
    montado.

Agora que validamos que o cabeçalhos esta OK, a restauração pode ser feita,
exectando o comando:

cryptsetup luksHeaderRestore /dev/sdc1 --header-backup-file /backup/
backup-header-luks.img

Agora execute novamente o cryptsetup dump (veja “Fazendo dump do cabeçalho de
dispositivos”) para confirmar a restauração do cabeçalho de criptografia.

Fazendo o Backup e Restore manual usando dd

Existe também a possibilidade de usar o dd para o backup e restore dos
cabeçalhos. O cabeçalho sempre reside no inicio do dispositivo criptogravado e
o backup pode ser realizado sem precisar de acesso a ferramenta cryptsetup.
Siga o seguinte procedimento:

 1. Usaremos a ferramenta cryptsetup apenas para pegar o OffSet (quantidade de
    blocos de setores) correspondentes ao cabeçalho do Luks que precisam ser
    lidos no inicio da partição:

    cryptsetup luksDump /dev/device | grep "Payload offset"

    Teremos uma saída como:

    Payload offset: 4040


    Em um disco de 512 bytes por setor, a quantidade de bytes que serão
    copiados pelo dd é dada pela fórmula: bytes_por_setor x OffSet

 2. Agora, obtenha o valor de setores da unidade de disco com o comando: fdisk
    -l /dev/device | grep "Sector size"

 3. Agora que temos os valores de bytes por setor e do Offset, vamos inserir os
    valores para realizar o backup com o poderoso comando dd (lendo essa
    quantidade de bytes do inicio do disco (512 x 4040) e salvando no arquivo /
    backup/backup-luks-dd.img):

    dd if=/dev/sdc1 of=/backup/backup-luks-dd.img bs=512 count=4040

    Você verá uma saída como:

    271+1 registros de entrada
    271+1 registros de saída
    138856 bytes (139 kB, 136 KiB) copiados, 0,00123232 s, 92,8 MB/s


    OBS: Como sugerido anteriormente, armazene o backup em um local protegido e
    de preferencia em um outro computador e criptografado com GPG, para
    garantir dupla segurança e integridade dos dados armazenados (veja
    “Encriptando Dados”).

A partir desse ponto, a restauração do backup é bastante simples. Basta copiar
o arquivo contendo o backup do cabeçalho com /backup/backup-luks-dd.img e
executar o comando:

dd if=/backup/backup-luks-dd.img of=/dev/sdc1 bs=512 count=4040

O backup será integralmente restaurado e você poderá conferir se o cabeçalho
está novamente íntegro com “Fazendo dump do cabeçalho de dispositivos” e
acessando novamente o sistema ce arquivos criptografado.

Convertendo automaticamente sistemas para criptografia e desconvertendo

O cryptsetup possui o comando cryptsetup-reencrypt que é usado para converter
um sistema não encriptado para um sistema LUKS.

ATENÇÃO! É fortemente recomendável que faça um backup completo dos dados que
serão criptografados sob risco de perda de dados durante o processo
automatizado!

Convertendo a partição para Criptografica

Supondo que desejamos converter o dispositivo /dev/sdc1 para criptografia,
executamos o seguinte procedimento:

 1. Primeiro, rodar o fsck na partição, para assegurar que a mesma encontre-se
    totalmente íntegra:

    e2fsck -f /dev/sdc1


    e2fsck 1.43-WIP (18-May-2015)
    Pass 1: Checking inodes, blocks, and sizes
    ...
    /dev/sdc1: 12/166320 files (0.0% non-contiguous), 28783/665062 blocks


 2. Depois precisamos reduzir o tamanho do sistema de arquivos para o menor
    tamanho possível (considerando os arquivos armazenados). Assumindo que o
    sistema de arquivos atual é um EXT?, para isso usaremos o resize2fs com o
    -M:

    resize2fs -M /dev/sdc1

    resize2fs 1.43-WIP (18-May-2015)
    Resizing the filesystem on /dev/sdc1 to 26347 (4k) blocks.
    The filesystem on /dev/sdc1 is now 26347 (4k) blocks long.


    O objetivo disso é reservar 'espaço livre' na partição para que a mesma
    tenha espaço suficiente para armazenar os arquivos que estão sendo
    encriptados.

    Por experiência própria, recomendo ter pelo menos 40% de espaço em disco
    livre, principalmente se estiver armazenando arquivos muito grandes, onde
    cada um ocupe pelo menos 1% de espaço em seu disco.

 3. Agora rodaremos o comando de encriptação:

    cryptsetup-reencrypt /dev/sdb1 --new --reduce-device-size 4096S

    WARNING: this is experimental code, it can completely break your data.
    Enter new passphrase:
    Progress: 100,0%, ETA 00:00, 2596 MiB written, speed  37,6 MiB/s


 4. Agora abriremos o dispositivo após reencriptação inicial. Neste passo você
    especificará a senha de descriptografia/acesso ao sistema de arquivos:

    cryptsetup open /dev/sdc1 recrypt

    Enter passphrase for /dev/sdc1:
    ...


 5. Agora o último passo será voltar o sistema de arquivos ao tamanho original,
    após a conversão para criptografia. Novamente usaremos o resize2fs:

    resize2fs /dev/mapper/recrypt

    Você verá a seguinte saída do comando:

    resize2fs 1.43-WIP (18-May-2015)
    Resizing the filesystem on /dev/mapper/recrypt to 664807 (4k) blocks.
    The filesystem on /dev/mapper/recrypt is now 664807 (4k) blocks long.


 6. Pronto, a partir de agora, o sistema está pronto para uso, bastando montar
    o dispositivo (que já foi decriptado), com:

    mount /dev/mapper/recrypt /mnt


Criptografia de arquivos usando ENCFS

O ENCFS é uma ferramenta userspace para criptografia no sistema de arquivos.
parecida com o eCryptfs (veja “Usando o eCryptfs para encriptar arquivos,
montagem automatica do home”) e tem como objetivo deixar dados seguros com o
mínimo de trabalho possível e em sistemas onde você possui somente acesso
usuário. Basicamente ele trabalha encriptando uma pasta existente utilizando o 
FUSE para montar e encriptar diretórios.

Devido a isso, sua funcionalidade é bem simples, e não depende de módulos ee
kernel adicionais que podem não existir na máquina que está configurando.

Ele não utiliza loopback ou devicemapper como o dm-crypt (veja NNNNNNNN) e
TrueCrypt (veja NNNNNNNN).

O EncFS é definitivamente o software mais simples se desejar criptografia de
arquivos no Linux.

Uma das maiores vantagens dele em cima de outros sistemas, é não requerer
privilégios de super usuário (root) para funcionar, e qualquer usuário pode
implementa-lo. Ele também não precisa criar um arquivo simples e criar um
sistema de arquivos dentro dele; É usado um sistema de arquivos atual sem
modificações.

Ele também é cross plataforma (enquanto o eCryptfs é ligado ao Linux), a
criptografia é feita arquivo a arquivo, o que permite inúmeras vantagens como a
criptografia de arquivos armazenados em storage de objetos (Dropbox, Google
Drive, OneDrive, etc)

É possível também fazer um 2FA armazenando a chave de volume fora do sistema de
arquivos de origem do EnCFS.

Outra vantagem; como a criptografia é feita individualmente, por arquivo, isso
reduz o risco de corrompimento a apenas um arquivo.

Isto também cria algumas desvantagens: Como os aquivos encriptados não estão
armazenados em um arquivo único de imagem, alguém com acesso ao sistema ainda
pode ser a estrutura de diretórios, o número de arquivos, tamanhos e quando
foram modificados. Eles no entanto não poderão ver o conteúdo.

Outra vantagem em cima do eCryptfs é que não precisa se lembrar de todos os
parametros para armazenamento da criptografia (ciphers, key type, etc), pois
todos são armazenados no arquivo .encfs6.xml. Você só precisa se lembrar da
frase-senha.

OBS: A implementação atual do encfs é vulnerável a múltiplos ataques, um deles
é a dedução de dados usando redução de complexidade de descriptografia.

Limitações

O EncFS possui as seguintes limitações Qualquer um com acesso ao diretório de
origem, poderá ver o tamanho de arquivos, quantos arquivos estão armazenados,
que permissões possuem o tamanho aproximado, e quando foram modificados pela
última vez, mesmo eles estando criptografados.

Sem suprote a nomes de arquivos muito longos. Limitado a 190 caracteres.

Utilize a versão 1.9 ou superior para menos riscos de segurança do padding no
final de arquivos.

Instalando

Para instalar o encfs, execute o seguinte comando: apt install encfs

Criando a Criptografia

Para criar um sistema de arquivos criptografado, execute o seguinte comando: 
encfs /diretorio/origem /diretorio/destino

Será perguntado a opção de nível de segurança usada. Selecione p para usar o
modo paraóico. O sistema então lhe perguntará a frase-senha

Agora os arquivos podem ser gravados na pasta destino. Note que o arquivo
.encfs6.xml será gravado em cada pasta individual que utiliza a criptografia.

para desmontar o sistema de arquivos, digite: fusermount -u /diretorio/destino

Alterando a senha

Para alterar a senha definida para acesso ao sistema de arquivos encriptado com
o EncFS, use o seguinte comando: encfsctl passwd /diretorio/origem

Montando via fstab

O formato para adição da montagem automatica no /etc/fstab é o seguinte:

encfs#/diretorio/origem /diretorio/destino fuser noauto,user 0 0

Usando o eCryptfs para encriptar arquivos, montagem automatica do home

O eCryptfs permite fazer criptografia a nível do sistema de arquivos. Ele
consiste na criptografia de uma pasta dentro do sistema de arquivo chamada de
Private. O suporte nativo ao eCryptFS foi adicionado oficionalmente a partir do
kernel 2.6.19 e para ele funcionar, precisa que o suporte do kernel ao módulo
ecryptfs esteja incluído na distribuição.

OBS: No Debian, o pacote ecryptfs-utils foi removido da Buster (Debian 10)
devido a bugs na desmontagem automática do diretório Private, mantendo o
conteúdo acessível para usuários com privilégios (BUG 765854). Este problema
pode ser contornado adicionando-se o ecyrptfs-umount-private no .bash_logout
(no entanto não é possível prever esse funcionamento em quedas de conexões
inesperadas).

O pacote ecryptfs-utils pode ser instalado no sistema adicionado o repositório
da stretch em /etc/apt/sources.list.

Após isso, execute o comando: apt-get install ecryptfs-utils

O padrão do ecryptfs é a montagem automatica da pasta no login dos sistema.

É requerido o suporte a key retention no kernel. Assim como habilitar o suporte
criptográfico a CBC, ECB, MD5 e AES. Em Miscelaneous filesystem, e também
habilitar o suporte a eCrypt filesystem layer support (que gera o módulo do
kernel ecryptfs).

NOTA: O eCryptfs é ainda experimental, embora mais seguro que o EncFS. Como o
formato interno pode mudar, é recomendável manter um backup de arquivos.

Configurando o ecryptfs

Para fazer a configuração manual do eCryptfs, primeiro selecione um diretório
que receberá o conteúdo criptografado e também um ponto de montagem com o
comando:

mount -t ecryptfs ~/origem ~/destino

O sistema perguntará a forma de criptografia desejada:

1) Frase Senha
2) tspi

Selecione a opção 1, você será perguntado do cifra que será usada (a AES é uma
boa escolha):

Select cipher:
 1) aes: blocksize = 16; min keysize = 16; max keysize = 32
 2) blowfish: blocksize = 8; min keysize = 16; max keysize = 56
 3) des3_ede: blocksize = 8; min keysize = 24; max keysize = 24
 4) twofish: blocksize = 16; min keysize = 16; max keysize = 32
 5) cast6: blocksize = 16; min keysize = 16; max keysize = 32
 6) cast5: blocksize = 8; min keysize = 5; max keysize = 16

Após isso, será mostrada a mensagem pedindo para selecionar o tamanho de bits
da chave:

Select key bytes:
  1) 16
  2) 32
  3) 24

Selection [16]: 3

Após isso, selecione ser texto plano deverá ser ativado:

Enable plaintext passthrough (y/n) [n]: n

Após, ser o nome do arquivo também deverá ser encriptado (isso é importante
para reduzir risco de ataques dirigidos a arquivos específicos):

Enable filename encryption (y/n) [n]: n
Attempting to mount with the following options:
  ecryptfs_unlink_sigs
  ecryptfs_key_bytes=56
  ecryptfs_cipher=blowfish
  ecryptfs_sig=7261b2ffab9ae159
WARNING: Based on the contents of [~/.ecryptfs/sig-cache.txt],
it looks like you have never mounted with this key
before. This could mean that you have typed your
passphrase wrong.

Em seguida, o ecrypt perguntará se deseja prosseguir com a montagem:

Would you like to proceed with the mount (yes/no)? : yes

Agora você será perguntado se deseja adicionar a assinatura ao arquivo
sig-cache.txt, para evitar o warning de montagem no futuro. Responda 'yes' para
evitar novas mensagens sobre esse warning:

Would you like to append sig [9c21b2ffab9ae159] to
[/~/.ecryptfs/sig-cache.txt]
in order to avoid this warning in the future (yes/no)? : yes
Successfully appended new sig to user sig cache file
Mounted eCryptfs

Note que o cache de assinaturas é adicionado automaticamente em ~/.ecryptfs/
sig-cache.txt evitando o warning de que foi a primeira vez que montou o
arquivo. É importante observar as opções de montagem usadas:

  ecryptfs_unlink_sigs
  ecryptfs_key_bytes=56
  ecryptfs_cipher=blowfish
  ecryptfs_sig=7261b2ffab9ae159

Após isso, o diretório será montado e tudo que for gravado em ~/origem, será
gravado criptografado em ~/destino:

/dev/vda1                           ext2      236M   37M  187M  17% /boot
/dev/mapper/lpi303--debian--vg-home ext4      428M  7.9M  386M   3% /home
tmpfs                               tmpfs     100M     0  100M   0% /run/user/0
/home/guiafoca/origem                 ecryptfs  3.5G  1.7G  1.6G  52% /home/guiafoca/destino

Caso tenha obtido o erro: Error mounting eCryptFS: [-2] No such file or
directory, verifique se tanto o diretório de origem ou destino existem em sua
máquina. Caso estiver criando uma nova criptografia, crie os diretórios com o
comando mkdir -p ~/origem ~/destino e repita os passos para criar os sistema de
arquivos criptografado.

Remontando o sistema de arquivos criptografado

Na hora de remontar o sistema, ele perguntará novamente todos os dados, basta
preencher corretamente, e seu conteúdo será novamente disponibilizado na pasta
especificada. caso digite a frase senha ERRADA, o sistema mostrará o seguinte
alerta:

WARNING: Based on the contents of [~/.ecryptfs/sig-cache.txt],
it looks like you have never mounted with this key
before. This could mean that you have typed your
passphrase wrong.

Would you like to proceed with the mount (yes/no)? : no
Aborting mount.

Caso prossiga, os arquivos criptografados anteriormente serão listados, mas ao
tentar abrir o conteúdo, o ecryptfs retornará:

cat: teste2.txt: Input/output error

OBS: O sistema de criptografia garante privacidade nos arquivos, mas eles podem
ser removidos por qualquer usuário do sistema permissões aprioriadas.

ecryptfsd

O ecryptfsd é um daemon userspace que executa operações sob o ponto de montagem
eCryptfs. Ele requisita serviços de chave pública do módulo do kernel, enviando
os mesmos via /dev/ecryptfs. O ecryptfsd somente precisa ser executado quando a
monatgem é feita usando módulo chave pública.

Todas as chamadas ao

ecryptfsd

são servidas sob o contexto do usuário que rodou o daemon.

Diretório Privado Automático para o usuário

O utilitário ecryptfs-setup-private pode ser usado para configurar o diretório
privado. Nesse caso, os utilitários ecryptfs-mount-private são usados para
configurar a criptografia disponibilizando os dados de forma padronizada em ~/
Private e o ecryptfs-umount-private para desmontar o filesystem ~/Private

A seguinte estrutura é usada nessa situação:

  • ~/Private - conteúdo descriptografado do ecrypfs

  • ~/.Private - Contém o conteúdo criptografado, em diretório oculto

A seguinte estrutura é criado em ~/.ecryptfs:

-rw-r--r--   1 gleydson gleydson     0 jul  2 11:25 auto-mount
-rw-r--r--   1 gleydson gleydson     0 jul  2 11:25 auto-umount
-rw-------   1 gleydson gleydson    23 jul  2 11:25 Private.mnt
-rw-------   1 gleydson gleydson    34 jul  2 11:25 Private.sig
-rw-------   1 gleydson gleydson    42 jul  2 11:25 wrapped-passphrase

Para criar o diretório privado de usuário, execute o seguinte procedimento:

 1. Execute o >ecryptfs-setup-private

 2. Será solicitado sua senha de login no sistema para continuar

     Enter your login password [guiafoca]:


 3. Será pedido a senha para montagem do sistema de arquivos criptografado.
    Selecione uma senha cuidadosamente seguindo os critérios de NNNNNNNN:

      Enter your mount passwphrase:


    ATENÇÃO: Guarde sua frase senha e armazene-a em um local seguro. Caso perca
    a frase-senha, não conseguirá mais ter acesso aos dados!

    Será exibida as seguintes mensagens de validação da montagem/desmontagem e leitura:
    ************************************************************************
    YOU SHOULD RECORD YOUR MOUNT PASSPHRASE AND STORE IT IN A SAFE LOCATION.
      ecryptfs-unwrap-passphrase ~/.ecryptfs/wrapped-passphrase
    THIS WILL BE REQUIRED IF YOU NEED TO RECOVER YOUR DATA AT A LATER TIME.
    ************************************************************************


    Done configuring.

    Testing mount/write/umount/read...
    Inserted auth tok with sig [cffe18c2df6fd3b2] into the user session keyring
    Inserted auth tok with sig [c70fae191ab3be11] into the user session keyring
    Inserted auth tok with sig [cffe18c2df6fd3b2] into the user session keyring
    Inserted auth tok with sig [c70fae191ab3be11] into the user session keyring
    Testing succeeded.

    Logout, and log back in to begin using your encrypted directory.


 4. Agora, faça logout, e novamente login para poder começar a usar seu
    diretório ~/Private montado.

 5. Você pode desmontar o diretório no momento que desejar, mas ao invés de
    usar o comando umount, utilize: ecryptfs-umount-private. Para montar
    novamente o diretório ~/.Private sem a necessidade de logout/login, use 
    ecryptfs-mount-private.

 6. Para validar se a senha e conteúdo podem ser corretamente acessados e
    descriptografados, use o comando:

    ecryptfs-unwrap-passphrase ~/.ecryptfs/wrapped-passphrase

Migrando o home do usuário para criptografado

Caso deseje migrar um diretório home existente para criptografia, isso é
possível com o ecryptfs. Quando o home é criptografado, assim que fizer o
logon, os dados estarão disponíveis de forma automatica, e o /home/usuario
deixará de ficar montado assim que o usuário fizer logout (usando o
pam_ecryptfs):

 1. Como root, rode: ecryptfs-migrate-user -u usuario

 2. Será perguntada a passpharase do usuário, que deverá ser fornecida (siga os
    critérios de segurança em NNNNNNNN)

 3. Peça para o usuário logar no sistema e ver se o sistema montou corretamente
    seu home. Se estiver tudo ok, o diretório de migração /home/usuario.XXXXXXX
    poderá ser removido

 4. Rode ecryptfs-unwrap-passphrase e salve o código aleatório gerado

para que a montagem funcione automaticamente com o pam_ecryptfs, é necessário
que a frase senha de acesso esteja sincronizada com o login de usuário, e que o
módulo seja configurado no PAM com:

auth    required    pam_ecryptfs.so unwrap
password    optional    pam_ecryptfs.so
session    optional    pam_ecryptfs.so unwrap

PAM ecryptfs

Para configurar a montagem automática do eCryptFS, proceda da seguinte forma:

 1. Monte o sistema de arquivos atual: mount -t ecryptfs /root/testecripto /mnt

 2. Pegue os parametros de montagem do /etc/mtab:

    grep 'ecryptfs' /etc/mtab /root/testeecryptfs /mnt ecryptfs
    rw,relatime,ecryptfs_sig=5251a2b3b9ae159,ecryptfs_cipher=
    blowfish,ecryptfs_key_bytes=56,ecryptfs_unlink_sigs 0 0

 3. Adicione a linha no /etc/fstab adicionando os parâmetros, user e noauto:

 4. Desmote o compartilhamento montado

 5. Adicione sua frase-senha do keyring via utilitário ecryptfs-manager, usando
    a opção 1.

 6. Monte o diretório com: mount -i /mnt' (a opção -i impede o mount de chamar
    o helper ecryptfs externo).

 7. O diretório deverá agora ser montado automaticamente.

 8. Agora que o diretório montou usando o keyring, limpe a chave da sessão de
    usuário com o keyctl clear @u

 9. Adicione o comando mount no ~/.bash_profile: mount -i /mnt

10. Finalmente adicione isto ao seu arquivo /etc/pam/login, após o pam_unix.so:

        auth required pam_ecryptfs.so

No RedHat, pode ser usado o script src/utils/ecryptfs-setup-pam.sh para
fornecer essa montagem automática

Limitações do eCryptfs

O ecrypt não deve ser usado para criptografar dispositivos de rede NFS . O 
EncFS (veja NNNNNNNN) é uma melhor opção nessa situação.

Nomes maiores que 143 caracteres não podem ser encriptados com a opção FNEK
(File Name Encryption Key).

Caso crie arquivos de imagem com o truncate (comando muito usado para criação
de imagens em virtualização ou de arquivos vazios, por ex: truncate -s 10G
teste.img, será produzido um arquivo criptografado de 10Gb no sistema de
arquivos origem.

Criptografia usando TrueCrypt/VeraCrypt

Durante anos o TrueCrypt foi bastante popular, ele possui características muito
interessantes, e a negação plausível é um dos recursos mais famosos.
Infelizmente seu desenvolvimento foi descontinuado há bastante tempo, mas
existe uma alternativa ao TrueCrypt que herda todos os recursos e adiciona mais
recursos de segurança chamado VeraCrypt. O VeraCrypt possui as seguintes
características:

  • Executa em paralelo (usando cores no servidor)

  • Operações de leitura/gravação em Pipeline (melhor performance)

  • Possui licenca opensource

  • Negaçao plausível - Caso seja forçado a revelar sua frase-senha, o 
    VeraCrypt prove e suporta dois tipos de negação plausível.

Segundo os desenvolvedores do VeraCrypt, ele se sobressai em cima do TrueCrypt
pois utiliza 327 mil interações do altoritmo PBKDF2-RIPEMD160 contra 1000
interações no TrueCrypt, sendo que em containers, o Veracrypt usa 655 mil
interações contra 500 mil interações do sha2 e Whirlpool do VeraCrypt.

Capítulo 8. Segurança de Host

Índice

Introdução

    Segurança de Host

Chroot, Container e Virtualização

    Chroot
    Container
    Vantagens da Virtualização

Desativando softwares e serviços desnecessários
Protegendo BIOS e o GRUB2

    Senha no GRUB2
    Protegendo opçoes do prompt do Grub2
    Protegendo o sistema com senha de boot do Grub
    Protegendo entradas de menus do Grub
    Protegendo a partição de recuperação do Windows

Limitando o uso de recursos de usuários

    Módulo PAM pam_limits

Esta capítulo documenta as técnicas apresentadas para aumentar sua segurança de
host em ambiente Linux

Introdução

Segurança de host permite proteger a máquina localmente e garantir a
integridade do sistema.

Segurança de Host

Futuro conteúdo sobre Segurança de Host.

Chroot, Container e Virtualização

Esta seção documenta características técnicas, vantagens e desvantagens de cada
uma das respectivas tecnologias.

Chroot

Chroot é uma das tecnologias mais antigas entre todas, veio inspirada no BSD
Jail.

Vantagens

 1. O programa executa em um espaço separado do sistema de arquivos principal
    da máquina.
 2. Não possui perda de performance, pois é como uma pasta local no sistema
 3. Possibilita testes mais arriscados na máquina, inclusive testes com versões
    diferentes do SO (ou até de arquiteturas retro-compatíveis com o kernel,
    como testar um sistema i386 em um x86_64).
 4. Possibilita testes mais arriscados na máquina

Desvantagens

 1. O espaço do kernel é o mesmo da máquina física (não possui qualquer
    isolamento)
 2. Usa a mesma memória RAM (podendo lotar a memória)
 3. Separação de dispositivos físicos é deficiente, com isso o disco raíz pode
    ser acessado pelo chroot (escapar da jaula).

Container

Container é o que há de mais performático em termo de isolação de privilégios.
Basicamente é um Chroot que deu certo :-D

Vantagens

 1. Permite isolar totalmente os recursos de CPU, memória, disco da máquina
    host

 2. Atachar isoladamente placas de redes do host físico direto para o container

 3. Alta performance de funcionamento, identico a máquina física

 4. Não 'perde' espaço em disco, devido a alocação prévia de disco ou memória.
    Apenas o espaço requerido ou sendo executado serão efetivamente utilizados
    em máquina física.

 5. Inicialização muito rápida. É possível iniciar 250 containers em questão de
    segundos em uma máquina razoável.

Desvantagens

 1. Somente é possível utilizar o kernel da máquina hospedeira. A virtualização
    permite utilizar kernels de diferentes versões

 2. Como executa no mesmo espaço de memória do kernel da máquina física, existe
    a possibilidade de alguns tipos de vulnerabilidades escalarem privilégios
    para a máquina host (um pouco raras hoje em dia, mas já ocorreu no
    passado).

Exemplos de tecnologias de containers: lxc,vserver, openvz, containerd, Docker.

Vantagens da Virtualização

Virtualização consiste em emular totalmente uma máquina (com memória RAM,
disco, processador, video, arquitetura) com recursos alocados para sua máquina.

Vantagens da Virtualização

 1. Mesmas vantagens do chroot, exceto perda de performance (pode perder até 5%
    de performance da máquina, mesmo nos melhores sistemas de virtualização via
    hardware)
 2. Separação de kernel: O sistema host (o que roda a virtualização) pode rodar
    um kernel 5.4 e a máquina virtual (convidado) um kernel 6.0.
 3. Separação de Memória
 4. Separação de CPU
 5. Separação de Rede
 6. Permite emular outra arquiteturas (para desenvolvimento, homologação,
    testes, etc)

Desvantagens

 1. Disco e Memória precisam ser pré-alocados
 2. Perda de performance em comparação com chroot
 3. Pode haver grnade competição de recursos levando a máquina virtual a um
    starvation

Além de virtualização full, temos sistemas chamados Para-virtualização, que
carrega todas as vantagens e desvantagens da virtualização tradicional acima,
mas utiliza um kernel específicado pelo host (podendo ser ou não a mesma versão
ou arquitetura executada no host de virtualização). Um exemplo de sistema que
suporta para-virtualização é o XEN.

Exemplos de sistema de virtualização convencional/para-virtualização: KVM, XEN,
Vmware, Hyperv.

Desativando softwares e serviços desnecessários

Executar essa tarefa auxilia a manter o sistema rápido e seguro, reduzindo o
consumo de RAM, IRQs, melhorando a performance global e tempo na sequencia de
boot. Avalie sempre a função da máquina antes de decidir a desativação do
serviço, e se ele tem alguma importância no funcionamento do conjunto, caso sua
máquina seja um servidor web, não tem sentido possuir serviço de impressão CUPS
.

Serviços como portmap, rexec, rlogin, cups, avahi podem ser desativados (ou até
mesmo completamente removidos) em um servidor que precisa apenas de ssh por
exemplo (ao menos que outro serviço como o NFS esteja instalado, nesse caso o 
portmap é requerido).

O primeiro passo é parar o serviço em execução. Execute um dos comandos abaixo
para interromper o processo (técnicas organizadas de de sistemas mais novos
para mais antigos):

RedHat/Debian/Mint/Ubuntu:

systemctl stop portmap
service portmap stop
/etc/init.d/portmap stop

e em seguida, desative o serviço com: RedHat:

chkconfig portmap off
chkconfig portmap --del
systemctl disable portmap

Debian/Mint/Ubuntu:

systemctl disable portmap
service portmap stop
update-rc.d -f portmap remove

Caso deseje remover completamente o serviço, utilize o gerenciador de pacotes
apropriado de sua distribuição para fazer a remoção:

APT - apt remove rpcbind

RPM - youm remove rpcbind

Protegendo BIOS e o GRUB2

Senha no GRUB2

A proteção de senha do grub2 pode ser utilizada para:

 1. Proteger todas as entradas de menu

 2. Específicas entradas

 3. Para usuários específicos, por exemplo, o usuário Gleydson pode acessar o
    Linux, mas não o Windows no modo de recuperação, que é acessível pela
    Michelle

Para adicionar a proteção de boot no Grub, você tem as seguintes opções:

  • O administrador deve ativar a proteção de senha manualmente editando os
    arquivos de configuação do grub

  • Usuários e senhas devem ser identificados no arquivo /etc/grub.d/00_header
    ou outro arquivo de script do Grub.

  • A proteção de entradas específicas deve ser identificada em um dos arquivos
    abaixo: a - editando scripts em /etc/grub.d/10_linux e 30_os-prober b -
    Editando o aruivo de configuração customizado criado pelo usuário c - Um
    dos métodos acima fazem o grub automaticamente adicionar o requisito de
    senha se o update-grub for rodado d - Se o arquivo grub.cfg for editado
    diretamente. A proteção de senha será perdida quando o update-grub rodar

  • Se qualquer forma de proteção de senha do grub2 for ativada. O nome e senha
    de superusuario serao requeridos para ter acesso a linha de comando do 
    grub2 e modos de edição de menu

  • O username e senha pode ser diferente do login/senha de sistema

  • Até que a encriptação do grub2 seja usada, a senha é armazenada em texto
    plano em um arquivo legível, o ideal é ativar a encriptação de arquivo.

Protegendo opçoes do prompt do Grub2

Para proteção contra a entrada do menu de edição e uso de opções como single
user, etc, no grub 0.97 crie uma senha com grub-md5-crypt e então use a opção
no grub.cfg:

password --md5 hash_do_grub-md5-crypt

Desta forma, o sistema sempre lhe pedirá uma senha quando acessar o menu de
edição do grub.

Protegendo o sistema com senha de boot do Grub

Esta instruções são válidas para a versão 2 do Grub. Antes mesmo do sistema
sistema operacional ser carregado, o Grub2 permite acesso aos arquivos
armazenados no sistema de arquivos. Usuários sem permissão de root podem
acessar arquivos do Linux no qual nâo deveriam ter acesso, assim que o Grub 
carregar. Para bloquear este tipo de acesso e evitar que os usuários iniciem
certos sistemas operacionais, defina uma senha de boot.

OBS: Com o uso de senha, a splash screen tradicional não é mostrada.

O procedimento para gerar é o seguinte:

 1. Entre como root

 2. Encripte a senha usando grub2-mkpasswd-pbkdf2:

    grub2-mkpasswd-pbkdf2
    Password: ****
    Reenter password: ****
    PBKDF2 hash of your password is grub.pbkdf2.sha512.10000.3CA4611006FE96BC22..


 3. Cole a string encriptada gerada no arquivo /etc/grub.d/40_custom junto com
    o comando set superusers. As linhas comentadas devem ser mantidas no inicio
    do aquivo, pois são usadas pelos scripts de manutenção de arquivos do grub:

    set superusers="root"
    password_pbkdf2 root grub.pbkdf2.sha512.10000.9CA4611006FE96BC77A
    export superusers

    Para definir a senha em texto plano (não recomendável) a entrada a seguir
    pode ser usada:

    password root senha1234

 4. Execute em seguida: grub2-mkconfig -o /boot/grub2/grub.cfg

Agora reinicie a máquina. Após o reboot, você será perguntardo pelo usuário e
senha para tentar iniciar qualquer entrada no menu. Caso as credenciais
estiverem corretas, o sistema inicializará a entrada selecionada do menu.

Protegendo entradas de menus do Grub

As entradas menuentry do Grub podem ser protegidas com os seguintes parâmetros:

 1. A presença de --unrestricted desativa a proteção de senha

 2. A presença de --users ativa a proteção de senha para usuários específicos,
    por exemplo: --users "Jane" - autoriza o superusuario e "Jane" --users
    Jane,Sergio - autoriza o superusuario e "Jane" e "Sergio".

Seguem mais exemplos de sintaxe no menu do Grub2:

# Todos os usuários (nenhuma proteção)
menuentry 'Ubuntu, with Linux 3.6.0-14-generic' --class ubuntu -class os --unrestricted {

# Somente superusuário:
menuentry 'Ubuntu, with Linux 3.6.0-14-generic' --class ubuntu -class os --users "" {

# Superuser e gleydson:
menuentry 'Ubuntu, with Linux 3.6.0-14-generic' --class ubuntu -class os --users gleydson {

# Superuser, gleydson, foca:
menuentry 'Ubuntu, with Linux 3.2.0-24-generic' --class ubuntu -class os --users gleydson,foca {

Protegendo a partição de recuperação do Windows

Note que este método somente funciona se o Grub2 identificar uma partição de
recovery do Windows:

1 - Determine a partição recovery do Window. altere sdXY para os valores corretos
2 - No 30_os-prober:

Altere a entrada no menu de:

menuentry "${LONGNAME} (on ${DEVICE})" --class windows --class os {

Para

if [ ${DEVICE} = "/dev/sdXY" ]; then
menuentry "${LONGNAME} (on ${DEVICE})" --users "" {
else
menuentry "${LONGNAME} (on ${DEVICE})" {
fi

Finalmente, execute o update-grub para atualizar o /boot/grub/grub.cfg.

Limitando o uso de recursos de usuários

Usuários requerem recursos como tempo de CPU, memória e espaço em disco para
fazer o tarbalho. Em muitods sistemas é possível aos usuários usarem todos os
recursos, atrapalhando o funcionamento do sistema e de outros usuários e
algumas vezes deixando o servidor muito lento ao ponto de trava-lo.

O uso grande de recursos pode ser grandes core dumps, usar toda memória. Uma
coisa para ser lembrada: limites globais se aplicam ao root, assim se não
permitir ao root executar processos os suficientes, você poderá ter problemas
até mesmo para entrar na máquina para corrigir falhas.

Módulo PAM pam_limits

O módulo usado para fornecer lmites aos usuários no pam é o pam_limits.so:

session         required        /lib/security/pam_limits.so

O aruquivo de configuração padrão se encontra em /etc/security/limits.conf.
Como muitos dos limites são forçados pelo shell, o sistema Não registrará todas
as violações de limites (voce receberá tentativas de acesso indevida, mas não
receberá um alerta se o usuário tnetar usar mais espaço em disco que é
permitido).

Um exemplo da limitação de recurso do usuário "foca" a 4Mb de RAM:

# Dominio   Tipo    Item            Valor
foca            hard    memlock         4096

Onde:

  • Dominio - Pode ser usuario, @grupo, 1000-2000 (Uid Range), @1000-2000 (GID
    Range), % é aplicavel para maxlogins somente (é eqivalente equivalente ao
    '*').

  • Tipo - Pode ser hard, soft, ou - (especific ambos)

  • Item - Pode ser um dos abaixo:

      □ core - Limita o tmanho do arquivo core (KB). Geralmente ajustado para 0
        para evitar core dumps

      □ data - Tamanho máximo de dados em memória (KB)

      □ fsize - Tamanho máximo de arquivo no disco (KB)

      □ memlock - Tamanho máximo do espaço de memória locked (KB)

      □ nofile - Nùmero máximo de arquivos abertos

      □ rss - Tamanho máximo de arquivos residentes (KB) (Ignorado no 2.4.30 e
        superiores)

      □ stack - Tamnho máximo da pilha (KB)

      □ cpu - Tempo máximo da CPU (MIN)

      □ nproc - Número máximo de processos

      □ as - Limite do Address Space

      □ maxlogins - Número máximo de logins para este usuário ou grupo

      □ maxsyslogins - Número maximo de todos os logins do sistema. Nenhum
        usuário pode conectar se o número estiver maior que o definido.

      □ priority - A prioridade de execução de processos deste usuário.

      □ nice - Prioridade máxima permitida para aumentar. Valores entre -20 a 
        19. Linux 2.6.12 e maiores

      □ rtprio - prioridade em tempo real máxima permitida para processos não
        privilegiados (Linux 2.6.12 e superiores)

  • Valor - O valor que deve ser apliado

Em geral, limites individuais tem mais prioridade que limite de grupos. Assim
se os limites do grupo @admins não tiver limite, mas existir um limite para seu
usuário em particular, o particular será usado. Os limites também são definidos
por sessão de login.

Grupos podem eser especificados usando a sintaxe @grupo no campo nome. Caso
seja usado *, a limitação se aplicará a todos os usuários.

Arquivos core podem ser criados quando um programa trava. Eles são usados por
exploits de segurança, sobrescrevendo arquivos de sistemas, ou contendo
informações sensíveis (como senhas). Você pode facilmente desativar core dumps
usando PAM, e geralmente, a maioria dos usuários nem notará isto. No entanto,
se tiver desenvolvedores de softwares, eles reclamarão:

*               hard    core            0

O fsize é uma bom parametro ser usado, muitos usuários tem uma quota grande de
sistemas, no entanto se eles tiverem permissões de criar um arquivo gigantes,
eles poderão facilmente tomar o I/O de recursos de disco (pena intensiva
operação combinada de I/O). O ajuste deste limite globalmente evita o invasor
tentar lotar as opartições onde seus logs são aramzanados. Por isto é uma boa
política usar partições separadas do / para log e outros dados.

A cpu é uma limitação classica de administração, é muito útil para evitar que
processos sejam disparados consumindo todo o tempo de cpu, caso o usuário
deixar coisas rodando em segundo plano (como um sniffer de pacotes), ele será
morto pelo sistema. A limitaçao do tempo de CPU tem muitos efeitos, no entanto,
caso os usuário passar muito tempo logado na máquina, ele poderá ser afetado.
Dependendo da CPU da sua máquina, este tempo pode variar fortemente (um minuto
no 386 é bem mais longo do que um minuto no i7).

Exemplo:

@guiafoca hard cpu 2

A limitação do número de logins simultâneos que o usuário pode usar, é
extremamente recomendável, a maioria das situações os usuários podem nem
precisar de muitos logins, assim eles poderão estar consumindo mais recursos do
que realmente precisam. Isto também pode ser usado para detectar atividades
suspeitas, caso os usuários sabem que o sistema utiliza esta limitações:

Apr 15 15:09:32 stench pam_limits[10015]: Too many logins (max 1) for test


Os limites aplicados ao usuário podem ser visualizados através do comando 
ulimit -S -a (para listar limites suaves - soft) e ulimit -H -a (para listar
limites rígidos - hard).

Caso os parâmetros -S ou -H sejam omitidos, os limites listados serão os suaves
(soft).

Capítulo 9. Controle de Acesso

Índice

Introdução

    Controle de Acesso

Esta capítulo documenta as técnicas apresentadas para garantir um excelente
controle de acesso no Linux.

Introdução

Controle de acesso

Controle de Acesso

Futuro conteúdo sobre controle de Acesso

Capítulo 10. Segurança de Rede

Índice

Introdução

    Segurança em Redes

Sniffer

    Detectando a presença de sniffers

Esta capítulo documenta as técnicas apresentadas para aumentar sua segurança de
rede em ambiente Linux

Introdução

Segurança de rede permite que proteja o conteúdo dos pacotes durante a
transmissão da máquina de origem a máquina destino na rede.

Segurança em Redes

Futuro conteúdo sobre Segurança em redes

Sniffer

O sniffer (farejador) é um programa que monitoram/registram a passagem de dados
entre as interfaces de rede instaladas no computador. Os dados coletados por
sniffers são usados para obtenção de detalhes úteis para solução de problemas
em rede (quando usado com boas intenções pelo administrador do sistema) ou para
ataques ao sistema (quando usado pelo cracker para obter nomes/senhas e outros
detalhes úteis para espionagem).

Os sniffers mais conhecidos para sistemas Linux são tcpdump, ethereal. Este
último apresenta uma interface gráfica GTK para fácil operação em máquinas que
executam o servidor X. Para explicar o funcionamento de um sniffer, vou assumir
o ethereal instalado (ele não requer modificações no sistema além de ser fácil
de executar e fazer pesquisa de expressões específicas). Instale o ethereal com
o comando apt-get install ethereal.

Agora vamos a prática para entender como o sniffer funciona e a importância da
criptografia de dados (só assim mesmo, não da para entender falando muita
teoria :-):

 1. Conecte-se a Internet

 2. Execute o ethereal como usuário root.

 3. Pressione CTRL+K para abrir a tela de captura de pacotes. Em Interface
    selecione sua interface de internet. Nesta tela clique no botão "FILE" e
    coloque um nome de arquivo que a captura será gravada. Opcionalmente marque
    a opção "Update list of packets in real time" para monitorar a passagem de
    pacotes em tempo real.

 4. Clique em "OK". A captura de pacotes será iniciada

 5. Conecte-se a um site ftp qualquer (digamos ftp.debian.org.br). Entre com o
    usuário "anonymous" e senha "minhasenha@segura.com.br"

 6. Finalize a captura de pacotes clicando no botão "STOP"

Agora vá em "File"/"Open" e abra o arquivo capturado. Ele está no formato usado
pelo sniffer tcpdump como padrão. Procure no campo "INFO" a linha "Request:
USER anonymous", logo abaixo você verá a senha digitada pelo usuário. Entendeu
agora a importância da criptografia na transferência segura de dados? não só o
nome/senha pode ser capturado mas toda a seções feitas pelo usuário. Scanners
como o tcpdump e ethereal são flexivelmente configuráveis para procurar por
dados específicos nas conexões e salva-los para posterior recuperação.

Detectando a presença de sniffers

Uma característica comum de sniffers é mudar o modo de operação das interfaces
monitoradas para o "Modo Promíscuo" com o objetivo de analisar todo o tráfego
que passa por aquele segmento de rede (mesmo não sendo destinados para aquela
máquina).

A entrada/saída de interfaces no modo promíscuo é monitorada nos logs do
sistema:

Sep 25 16:53:37 myserver kernel: device eth0 left promiscuous mode
Sep 25 16:53:56 myserver kernel: device eth0 entered promiscuous mode
Sep 25 16:54:18 myserver kernel: device eth0 left promiscuous mode
Sep 25 16:54:31 myserver kernel: device eth0 entered promiscuous mode

O logcheck monitora estas atividades e classificam esta mensagem como
prioridade "Violação" (dependendo da configuração dos seus filtros em /etc/
logcheck. Veja “logcheck” para detalhes sobre este programa.

OBS: A utilização de switches dificulta a captura de pacotes em redes
distribuídas porque somente os dados destinados a máquina onde o sniffer está
instalado poderão ser capturados.

Capítulo 11. Apêndice

Índice

Sobre este guia
Sobre o Autor
Referências de auxílio ao desenvolvimento do guia
Onde encontrar a versão mais nova do guia?
Colaboradores do Guia e Agradecimentos
Marcas Registradas
Futuras Versões
Licença CC BY-NC-SA
Chave Pública PGP

Este capítulo contém considerações sobre o guia Foca GNU/Linux.

Sobre este guia

O Guia Foca é uma série de livros disponíveis gratuitamente, sendo que a
primeira versão foi lançado pela primeira vez em 12 de Novembro de 1999. A
versão que está lendo contém o(s) nível(is) de aprendizado (Iniciante,
Intermediario, Avançado, Segurança):

  • Segurança

A versão que esta lendo agora foi gerada com as seguintes opções:

  • Descrição detalhada de comandos

  • Opções usadas em comandos e programas

  • Observações sobre comandos e configurações

  • Exemplos para a melhor compreensão do assunto discutido.

A versão que está lendo tem o objetivo de servir como referência a usuários:

  • Segurança - que já possuem conhecimento basico de Linux e desejam implantar
    metodologias e técnicas que aprimorem a segurança de seu ambiente,
    realização de hardening, proteção dos dados que trafegam em rede e
    melhorias das técnicas de gerenciamento de segurança.

Uma versão que abrange um diferente nível de aprendizado ou mais completa pode
ser baixada de Página Oficial do Guia Foca Segurança.

O Guia Foca Segurança é atualizado frequentemente, por este motivo recomendo
que assine um dos canais de comunicação (ou todos :-))para ser informado de
novas versões:

  • Siga o Guia Foca no Twitter @guiafoca

  • Inscreva-se em novidades, na página web em Página Oficial do Guia Foca
    Segurança no fim da página principal. Após preencher a ficha do aviso de
    atualizações, você será notificado sobre novidades do Guia Foca.

  • Siga os avisos do Guia Foca no Telegram: Avisos de Atualização do Guia Foca
    no Telegram

  • Siga a página do @guiafoca no Facebook: Página do Guia Foca no Facebook

Versões diferentes deste guia podem ser geradas a partir do código fonte XML ou
obtidas através da home page principal (para detalhes veja “Onde encontrar a
versão mais nova do guia?”).

Sobre o Autor

Gleydson Mazioli da Silva é Capixaba, nascido em Vila Velha. Amante de
eletrônica desde criança, foi atraido para a informática através da curiosidade
em funcionamento e reparo de hardware.

Se dedica ao sistema Linux desde 1997. determinado na realização de testes de
ferramentas e sistemas avaliando pontos fortes e fracos de cada uma. Logo que
iniciou em Linux passou a estudar exaustivamente aspectos técnicos de
distribuições e rede em Linux/BSD.

Entre coisas que gosta de fazer/implementar em Linux: possibilidade de pesquisa
e atualização de conhecimento constante, automatização e tomada inteligente de
decisões, níveis de segurança da informação (tanto físico e lógico), firewalls,
virtualização, redes virtuais, integração de sistemas, forense computacional,
documentação de processos, desenvolvimento de ferramentas GPL para a
comunidade, depuração, desenvolvimento de documentações, etc.

Um dos desenvolvedores da distribuição Liberdade, CAETECT, Debian-BR e
desenvolvedor oficial da distribuição Debian. Atuou como tradutor do LDP-BR,
traduzindo vários HOW-TOs importantes para a comunidade Linux Brasileira.
Também é um tdos administradores do projeto CIPSGA, cuidando de uma infinidade
de serviços que o projeto oferece a comunidade que deseja estrutura para
hospedar, fortalecer e manter projetos em software livre.

Trabalhou para algumas empresas do Espírito Santo, no Governo Federal e de
estados na implantação de sistemas em software livre. Atualmente atua como
gerente de tecnologia da SpiritSec, uma empresa focada em segurança e alta
performance, avaliação e integração de ferramentas de código aberto junto a
seus clientes.

Concorda com certificações, mas destaca que o mais importante é aproveitar a
oportunidade dada pela certificação para estudo e auto avaliação de seus pontos
fracos e assim procurar melhora-los. Possui certificação LPI nível 3 e um
ISO9001 internacional em Administração Linux, como primeiro no ranking
Brasileiro.

E-mail: E-mail: <gleydson@guiafoca.org>, Twitter: @gleydsonmazioli.

Referências de auxílio ao desenvolvimento do guia

  • A maioria dos capítulos existentes no Guia Foca segurança foram escritos
    após testes exaustivos, uso e observação de comportamento dos comandos,
    programas e métodos de implantação. Em geral, sempre me baseio na
    documentação oficial para entender e escrever sobre um tópico, mas em
    especial listo abaixo as seguintes referencias mais específicas:

  • Documentação oficial dos respectivos programas.

  • Wiki Public Key Certificate.

  • SSL Cookbook.

  • How-tos do Linux (principalmente o Networking Howto, Security-Howto)
    ajudaram a formar a base de desenvolvimento do guia e desenvolver algumas
    seções (versões Intermediário e Avançado somente).

Onde encontrar a versão mais nova do guia?

Novas versões deste guia, avisos de lançamento, outros níveis de aprendizado
(Iniciante, Intermediário e Avançado), versões para outras distribuições Linux
podem ser encontradas em: Página Oficial do guia Foca GNU/Linux.

Se quiser receber notificações de novas versões, use uma das formas a seguir:

  • Siga a página do @guiafoca no Facebook: Página do Guia Foca no Facebook

  • Siga os avisos do Guia Foca no Telegram: Avisos de Atualização do Guia Foca
    no Telegram

  • O formulário dos aviso de atualizações na página web em Página Oficial do
    Guia Foca Linux no fim da página principal. Após preencher a ficha do aviso
    de atualizações, você será notificado sobre novidades do Guia Foca.

  • por E-Mail: envie uma mensagem para <gleydson@guiafoca.org> pedindo para
    ser incluído na lista de atualizações do guia ou assine as novidades
    clicando no menu Novidades na Página Oficial do Guia Foca Linux.

  • Twitter: Assine o Twitter do guia Foca: @focalinux

Colaboradores do Guia e Agradecimentos

Entre as principais colaborações do Guia Foca Segurança até a versão atual,
posso citar as seguintes (classificação cronológica):

  • A atenciosa revisão dispensada e inúmeras correções enviadas por esses
    renomados profissionais de segurança que se uniram antes do lançamento do 
    @guiafoca no Telegram para que conseguisse entregar o melhor conteúdo,
    desde o primeiro lançamento:

      □ Ayr Miller

      □ Caroline Figueiredo

      □ Gustavo Roberto (Tux)

      □ Gabriela Fonseca

      □ Gian Cavalcante

      □ Giovani Balarini

      □ Jeferson Fernando Noronha

      □ Leonardo Berbert

      □ Lucas Nunes

      □ Zoziel Freire

  • Michelle Ribeiro <michellemazioli@gmail.com> - Por dispensar parte de seu
    atencioso tempo enviando revisões e sugestões que estão melhorando bastante
    a qualidade do guia. Entre eles detalhes que passaram despercebidos durante
    muito tempo no guia e página principal.

    E também por cuidar do fonte do guia ;-)

  • Rafael Gomes (Twitter @gomex) - Muito a agradecer a ele, mas em especial
    por me introduzir do jeito certo ao mundo DevOps, mostrando que a
    colaboração e espírito de comunidade se sobressaem acima de tudo e pelo
    incentivo a voltar a lançar atualizações do guia de forma colaborativa no
    github. Gomex (como é popularmente chamado) mantém um guia referencia
    Docker na Internet: https://github.com/gomex/docker-para-desenvolvedores.
    Merece uma visita para conhecer o conteúdo, extrema qualidade para quem
    deseja se aprofundar no Docker.

  • Jeferson Fernando Noronha (https://www.youtube.com/user/linuxtipscanal) -
    Pela divulgação do Guia Foca no canal LinuxTips (YouTube). O trabalho que o
    Jeferson realiza é extraordinário, mantendo a tradicional filosofia do
    Software Livre em uma época de desenvolvimento ágil, nuvem e
    orquestradores. Vários cursos e videos gratuitos no canal com qualidade de
    conteúdo que não se encontra em qualquer outro canal de YouTube. Conteúdo
    merece ser acessado pelos leitores do Guia Foca.

  • Ayr Miller - Pelos constantes envios de materiais, referencias, indicando
    conteúdo que falta para complementar seções escritas, além de envio de
    traduções e materiais de referencia para novos capítulos.

Marcas Registradas

Todas as marcas registradas citadas neste guia são propriedades de seus
respectivos autores.

Futuras Versões

Estes são os materiais que pretendo adicionar em futuras versões do guia:

  • Detalhar ainda mais sobre sistemas de segurança em rede (apenas foram
    cobertos os essenciais até o momento, e requeridos para a LPI 303)

  • Entre outros ítens que venho estudando para verificar se encaixam no perfil
    do guia.

Esta é uma futura implementação que venho estudando para acompanhar o
crescimento do guia. Sugestões são bem vindas e podem ser enviadas para <
gleydson@guiafoca.org>.

Licença CC BY-NC-SA

O Guia Foca Segurança é licenciado segundo os termos do Creative Commons
BY-NC-SA, onde você tem o direito:

  • Compartilhar — copiar e redistribuir o material em qualquer suporte ou
    formato

  • Adaptar — remixar, transformar, e criar a partir do material.

De acordo com os seguintes termos:

  • Atribuição — Você deve dar o crédito apropriado, prover um link para a
    licença e indicar se mudanças foram feitas. Você deve fazê-lo em qualquer
    circunstância razoável, mas de nenhuma maneira que sugira que o licenciante
    apoia você ou o seu uso.

  • NãoComercial - Você não pode usar o material para fins comerciais.

  • CompartilhaIgual — Se você remixar, transformar, ou criar a partir do
    material, tem de distribuir as suas contribuições sob a mesma licença que o
    original.

Chave Pública PGP

Chaves PGP são usadas para criptografar arquivos, e-mails ou qualquer outra
coisa que desejamos que somente uma pessoa tenha acesso. O PGP segue o padrão
de chave pública/privada; a chave pública é distribuída a todos e a chave
privada permanece na posse do criador para que ele seja o único a ter acesso
aos dados criptografados após digitar a "frase de acesso" correta.

Minha chave PGP segue abaixo, ela também pode ser encontrada em http://
pgp.ai.mit.edu.

-----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBF4NBqoBEAC//7HIpbF21OOrrFMBOISNNMvntdeEO4Ea4YmGF2epEQYWh+aC
8eOAP0+XrjTyZV0b4V6Q9vcTd2xw2qChHHVcp2jbVjlxjaTFTGNM8rAU1/2iFFPn
vJ29svh653MexpCzL/iDrI6F9mB+t1pQN7RwjnHRFiBcEk57SwjqIQzFHdk0W78V
ihmhNR/+wVTufy7noTfTB8MYHO3eLIzy66Ck/xQLFS+liPsXymZ5UFbbK8r43AOK
x987tnr1xL1sUMxjKPwMW/WtZTu21SoQmhEweOou0U2KedMX608/UyDQ6f1zyDXz
d8MUqNKDOI7RRJTn3fLAKhXASnQCbIC5nrA6HmUAsCrvg51ErE8aXvyHZaO8cRhs
2yb3Gn2/RL/mNmDxHpSmJ+iFK5ELGGqhIL7cUfvrOyPOsVt5ufEa7Poc94vBRJiv
awp178zkIefR7hOeTKRCbr0a7/7UvXc0nJ2crpWTG0/iFT6O7gHHH/COb7X/61Pn
Oefv9wxkc365iBIFN3Pg0fO4tXKHs3tUH2xhfc9/qXdVgJpme0wvJbZAzHG6piJo
0H17eijz/MWpf4o6PTJPpc9r6qBKmh9pezKnnBxNmrqgg9jms+CObWsziM7/tP22
i4Ywz17RTgd7j6EbCa3Vr6SL4HSLGcxikXpYJEFF1ZXxH+nn0y/jfZf0awARAQAB
tExHbGV5ZHNvbiBNYXppb2xpIGRhIFNpbHZhIChDaGF2ZSBNYXN0ZXIgUGVzc29h
bCkgPGdsZXlkc29ubWF6aW9saUBnbWFpbC5jb20+iQJNBBMBCgA3FiEEhdKAjm/j
o+PVj5Eq+T22P0ZikksFAl4NBqoCGwEECwkKBAUVCgkIAwUWAgMBAAIeAQIXgAAK
CRD5PbY/RmKSS7LxD/9aDxE8JSAKRgUrCjRMeCXTaCOryhQAZSl/V0HzTwrzSTeC
IHJfa1Vq7NoEE5shvttwrOIMK0UnjT8fXKJYnfCtjbQsFtnOd+mGsgh3H9/r1DhA
TqHrBXOUb4oxrLLyB8n11gAET+yLEYkPnrX2wyaFHpQTyJbrUsY6Nibs69eaZljY
4OtWx/eg8RiEX/GHh9SoM8BxXgxoJSLnOU+c0/QZeEoxVX1oZXE1E6lgRe9Kvv7r
6HiGC1lrauul5SZbSBQgJK+a0I96HK329C9+utDjSKrTuu7C1SmcCWbNjC0/Xxcs
SXcalMU3oj0/O+SgOxSypahjlxgYHYP1d36IhKsgqSHc8znORz0sprCtuGiMgjxm
2ENOikf0EM/FkICIS91fCfrumEm5CBrFXS0hokPh6GUFWGfhGJGAEoyi7591VKcv
254j0SytPDJzML1ETZydaIfS+3y+gxOibDo2Fn0sQ2mpFt3m8x2sAWVq/fhB5KwN
KdnFYPFwfUmerOPEXh2yamaOXEC7xMkl58x6vjTnE9uh6SlCpAqxBbrVJGMTPBTQ
jWv5Hbq4ux/zuraQbAnKBdhwggHD8sxkyqwxBLunR0PK9weT/lVeam9O5uBJXLoZ
xfOmhBL38PZmNkKEmKUHA+JvebBdFmQxLit8DqTVS7FhaAdR2QX9cfTHw/EvI7kC
DQReDQoeARAAwcQqN7oGokcrmL87uqiaEq0jpLLOfmcEUneqyE8i5ek2k4EvbUHs
8y3UIKfsAGzGvM5lLmZzQnYiUutiRZjYvVVZpImMY48Ss+8ilVw6HttjhJhwOOwn
2ZX8NED39gkdNY3XimtzyjS1DpsmixpilCRZLC103L8UzpH7kJHPSUvF/9wqLV6O
n9BGj7wa7EueTqsctKof7JEUFYMmdh1KRqQktoSu+ukRN5XQoH/vOqgkUP2BsPFN
m2pLZYFRFcL5dOZeeSzRWvOUwtdG8zHCQab7Ku6AYXih/qbBpzTX2Yiy5NnW/Ezg
6cjErC8OFOAumvtoV5xwPH2csv4aI3YapsRZ8xoNv+00TFgGBGm9w5CiRkriU9AR
nxnkIFDDO/C0Cb7dG/+MpJSLV03tNlXVxBhbG0UZa/1IupdtW+0uKv58PP7Nwsvw
1c6/Ejr9S63paJTv56jGyWasUIOpZXk23iqpxyHwmX3MIOey3H/qXRhgzdJreXlW
ywnaI0bZTybsLAHrE9KwukCS2mSi1PKOyGVhj/pDdA0w17sUFakFtipj60HswJjN
8ssqs85n6js3/nyGky02bNJEahFmQrCbTWQ3C4Wdn9h1wXpwM+KXLaBf5xjMX/rD
z/3M3b69Y2tsJoYhpW4B3u23Fuusg891GkvPvm0bKXerfVDONg7E4xMAEQEAAYkE
cgQYAQoAJhYhBIXSgI5v46Pj1Y+RKvk9tj9GYpJLBQJeDQoeAhsuBQku/geAAkAJ
EPk9tj9GYpJLwXQgBBkBCgAdFiEEuRHBS7LV8V4bMGoAghcsoyjAH2cFAl4NCh4A
CgkQghcsoyjAH2dLBg//fkh8JWdEXvd2M6RrU9V5mYLMXrzp5sCXnfjTKTLo8u3C
Soe02kTPHW2cBOzS6DL/fzUw0JTqEWXJUC3RLYmlcJ6+nx8cjH/AljaW8FZ6VMaV
BmQh36AtoNBp58Rl7RT+2qXjq1gqhNu7XaUwQHrYkhxSow3NueO7m3ZpGuWYyiGJ
ESbYw2sooBD5iHMLkYIjFQdsRKivurpF82JmD3mfif+eivINNNsI0c54Ls5ElM9a
P4KjLxkkXk+bTutzGG8JWq8FNYo+oVTTdZ1jb3TiulEVyKRum8FNZymEW6DADVF8
cAohyq94UUPbRErU7c43z5DOVcV95kDhFE/RzBEau4ry3Udz6KzFMSUMn23sY/bu
uGEugrxvTQcuoVfuNElsvivkhNEHDlTafD35PW4jVoqZAVMOkpM/ZF+pSt0Gt5We
sOoG3BVCB9tltjanY+PChySh1TKJzkk1lzIVp9PfTfUL/HZhsNxok/CjTr9dYzcL
G5jKkU5Gjp+1o2s4JNK1DtURX1ifJ5Gb2DN5pA2mGHgKBPxKbnXopjbZ9kJtGrul
lMRJ7QA68z3WmUUnELaoUSPINs1Al3eNzuH+8Y/CCKFxp+LLh0Hz8UL8nBEBIe+Q
aARrOY9TklZIx8JUqZWbI0n2rLrFyDXEeqcYbUdb9poy233Ucul/zE48i7n2bJw8
EBAAidlDMFSZbRjLvUIEoUfpqN9eKhmGMsmk/j7qi8qSrvZAg8Yev7nd7scuOjEo
H2b/q73MKDuEAZss6NkEEbfE4mKKczoGUkTIUKdFArzoL1Lgd1Mmvq0M2rt34q81
8qo0CNkR34HkYcIGcUoLsrl93WPTvk7P3GKQnP6MEKOigfezII3+1GzspG929J03
ayDmzCUz7hkNp/CjXD1DM+PmIqWWORbpAyYnBOLSfZVOwW31xHykZcm20UknZvt7
HHaHrxEs0grt4NmfX7Z0Z17RLfB88FoPPNbXVS1L/wjEvaIvPNURpfEArtCFl0tA
iQ0nA5ia7acluQc1CybLmCMfHuhlRHz9ZWS+l84On+o0pFGySzll2uq6XZnGHnlY
OEuV72g7hGNh78rUOJSM0WeZ1LaJ9iQqHSb1AbKgfJ1lKQIy7css25YQKe4MjC3/
Gahdr6njOovwALKyGB2YYTVACjdp8YCMFMMoJdb9RJsbTcAkoRMbpL2rS9T63dtM
Z1ufMuR4bYhhGGpAtHNJ2DlQFzMn/V3W7bUT3Im4MnCelFeuWBBZkuZZEVgW7ce2
l2k1Ftw9QjnLCNkJE10gKZqOzR9sHBdiORB0DTF0F++dzdQq1ugcjPvfcSL5Nx5a
70+F0YKM9onTVYfkr0N8uK3CQOECp6LFbIuy/pk6Ue/XQeo=
=DkuQ
-----END PGP PUBLIC KEY BLOCK-----


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Copyright © 1999-2020 - Gleydson Mazioli da Silva

